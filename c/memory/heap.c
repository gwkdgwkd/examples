#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，
// 它们大小固定，不能分配和释放，只能等到程序结束由操作系统回收，这称为静态内存分配。
// 栈区和堆区的内存在程序运行期间可以根据实际需求来分配和释放，
// 不用在程序刚启动时就备足所有内存，这称为动态内存分配。
// 使用静态内存的优点是速度快，省去了向操作系统申请内存的时间，
// 缺点是不灵活，缺乏表现力，例如不能控制数据的作用范围，不能使用较大的内存。
// 而使用动态内存可以让程序对内存的管理更加灵活和高效，需要内存就立即分配，
// 而且需要多少就分配多少，从几个字节到几个GB不等，不需要时就立即回收，再分配给其他程序使用。

// 栈和堆的区别
// 栈区和堆区的管理模式有所不同：
// 栈区内存由系统分配和释放，不受程序员控制；
// 堆区内存完全由程序员掌控，想分配多少就分配多少，想什么时候释放就什么时候释放，非常灵活。
// 程序启动时会为栈区分配一块大小适当的内存，对于一般的函数调用这已经足够了，
// 函数进栈出栈只是ebp、esp寄存器指向的变换，或者是向已有的内存中写入数据，不涉及内存的分配和释放。
// 当函数中有较大的局部数组时，比如1024*10个元素，
// 编译器就会在函数代码中插入针对栈的动态内存分配函数，这样函数被调用时才分配内存，不调用就不分配。
// 经常听说栈内存的分配效率要高于堆就是这个道理，
// 因为大部分情况下并没有真的分配栈内存，仅仅是对已有内存的操作。

// 动态内存分配函数
// 堆（Heap）是唯一由程序员控制的内存区域，常说的动态内存分配也是在这个区域。
// 在堆上分配和释放内存需要用到C语言标准库中的几个函数：
// malloc()、calloc()、realloc()和free()。
// 1.void* malloc (size_t size);
//   功能：在堆区分配size字节的内存空间。
//   返回值：成功返回分配的内存地址，失败则返回NULL。
//   注意：分配内存在动态存储区（堆区），手动分配，手动释放，
//   申请时空间可能有也可能没有，需要自行判断，由于返回的是void*，建议手动强制类型转换。
// 2.void* calloc(size_t n, size_t size);
//   功能：在堆区分配n*size字节的连续空间。
//   返回值：成功返回分配的内存地址，失败则返回NULL。
//   注意：calloc()函数是对malloc()函数的简单封装，参数不同，
//   使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。
// 3.void* realloc(void *ptr, size_t size);
//   功能：对ptr指向的内存重新分配size大小的空间，
//   size可比原来的大或者小，还可以不变（如果无聊的话）。
//   返回值：成功返回更改后的内存地址，失败则返回NULL。
// 4.void free(void* ptr);
//   功能：释放由malloc()、calloc()、realloc()申请的内存空间。
// 几点注意：
// 1.每个内存分配函数必须有相应的free函数，释放后不能再次使用被释放的内存；
// 2.在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植，
//   因为在不同的操作系统中，同一数据类型的长度可能不一样，为了解决这个问题，
//   C语言提供了一个判断数据类型长度的操作符，就是sizeof；
// 3.free(p)并不改变p的值，依然指向以前的内存，为了防止再次使用该内存，建议将p的值手动置为NULL。
// sizeof是单目操作符，不是函数，必须加括号，例如sizeof(int)、sizeof(char)等。

// 相对于栈而言，堆这片内存面临着一个稍微复杂的行为模式：
// 在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，
// 而且申请的大小从几个字节到几个GB都有可能，不能假设申请多少堆空间，因此，堆的管理显得较为复杂。
// malloc()相当于向操作系统批发了一块较大的内存空间，然后零售给程序用。
// 当全部售完或程序有大量的内存需求时，再根据实际需求向操作系统进货。
// 当然malloc()在向程序零售堆空间时，必须管理它批发来的堆空间，
// 不能把同一块地址出售两次，导致地址的冲突。
// 于是malloc()需要一个算法来管理堆空间，这个算法就是堆的分配算法。

// malloc()和free()的分配算法
// 在程序运行过程中，堆内存从低地址向高地址连续分配，随着内存的释放，会出现不连续的空闲区域。
// 程序需要内存时，malloc()首先遍历空闲区域，看是否有大小合适的内存块，
// 如果有，就分配，如果没有，就向操作系统申请（发生系统调用）。
// 为了保证分配给程序的内存的连续性，malloc()只会在空闲区域中分配，而不能将多个空闲区域联合起来。
// 内存块（包括已分配和空闲的）的结构类似于链表，它们通过指针连接在一起。
// malloc()和free()所做的工作主要是对已有内存块的分拆和合并，
// 并没有频繁地向操作系统申请内存，这大大提高了内存分配的效率。
// 由于单向链表只能向一个方向搜索，在合并或拆分内存块时不方便，
// 所以大部分malloc()实现都会在内存块中增加pre指针，构成双向链表。
// 栈内存的分配类似于数据结构中的栈，而堆内存的分配却类似于数据结构中的链表。
// 链表式内存管理虽然思路简单，容易理解，但存在很多问题，例如：
// 1.一旦链表中的pre或next指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到；
// 2.小的空闲区域往往不容易再次分配，形成很多内存碎片；
// 3.经常分配和释放内存会造成链表过长，增加遍历的时间。
// 针对链表的缺点，后来人们提出了位图和对象池的管理方式，而现在的malloc()往往采用多种方式复合而成，
// 不同大小的内存块往往采用不同的措施，以保证内存分配的安全和效率。
// 不管具体的分配算法是怎样的，为了减少系统调用，减少物理内存碎片，
// malloc()的整体思想是先向操作系统申请一块大小适当的内存，然后自己管理，这就是内存池（Memory Pool）。
// 内存泄露的问题往往难于调试和发现，或者只有在特定条件下才会复现，这给代码修改带来了不少障碍。
// 为了提高程序的稳定性和健壮性，后来的Java、Python、C#、JavaScript、
// PHP等使用了虚拟机机制的非编译型语言都加入了垃圾内存自动回收机制，
// 这样程序员就不需要管理内存了，系统会自动识别不再使用的内存并把它们释放掉，避免内存泄露。
// 可以说，这些高级语言在底层都实现了自己的内存池，也即有自己的内存管理机制。
// 在计算机中，有很多使用池这种技术的地方，除了内存池，还有连接池、线程池、对象池等。
// 所谓池化技术，就是程序先向系统申请过量的资源，然后自己管理，以备不时之需。
// 之所以要申请过量的资源，是因为每次申请该资源都有较大的开销，
// 不如提前申请好了，这样使用时就会变得非常快捷，大大提高程序运行效率。

// 如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，
// 那么就无法对该指针进行操作，这样的指针称为野指针（Wild Pointer）。
// 要想规避野指针，就要养成良好的编程习惯：
// 1.指针变量如果暂时不需要赋值，一定要初始化为NULL，
//   因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的；
// 2.当指针指向的内存被释放掉时，要将指针的值设置为NULL，
//   因为free()只是释放掉了内存，并为改变指针的值。

// C语言内存泄露（内存丢失）
// 使用malloc()、calloc()、realloc()动态分配的内存，如果没有指针指向它，
// 就无法进行任何操作，这段内存会一直被程序占用，直到程序结束由操作系统回收。
// free()函数的用处在于实时地回收内存，如果程序很简单，程序结束之前也不会使用过多的内存，
// 不会降低系统的性能，那么也可以不用写free()函数，当程序结束后，操作系统会释放内存。
// 在程序中使用malloc()分配内存时都对应地写出一个free()是一个良好的编程习惯。
// 这不但体现在处理大型程序时的必要性，并能在一定程度上体现程序优美的风格和健壮性。

void func(char **pp) {
  char arr[] = "C语言中文网";
  *pp = arr;
}

#define N (5)
#define N1 (7)
#define N2 (3)
int main() {
  int flag = 4;
  if (0 == flag) {
    int *ip;
    int *large_ip;
    int *small_ip;
    if ((ip = (int *)malloc(N * sizeof(int))) == NULL) {
      printf("memory allocated failed!\n");
      exit(1);
    }
    int i;
    for (i = 0; i < N; i++) {
      ip[i] = i;
      printf("ip[%d] = %d\t", i, ip[i]);
    }
    printf("\n");
    if ((large_ip = (int *)realloc(ip, N1 * sizeof(int))) == NULL) {
      printf("memory allocated failed!\n");
      exit(1);
    }
    for (i = N; i < N1; i++) large_ip[i] = 9;
    for (i = 0; i < N1; i++) printf("large_ip[%d] = %d\t", i, large_ip[i]);
    printf("\n");
    if ((small_ip = (int *)realloc(large_ip, N2 * sizeof(int))) == NULL) {
      printf("memory allocated failed!\n");
      exit(1);
    }
    for (i = 0; i < N2; i++) printf("small_ip[%d] = %d\t", i, small_ip[i]);
    printf("\n");
    free(small_ip);
    small_ip = NULL;
  } else if (1 == flag) {
    // 指向没有访问权限的内存
    // str是局部变量，它的值是不确定的，是随机的，不知道指向哪块内存。
    // 一般情况下，这块内存要么没有访问权限，要么还没有分配，
    // 当gets()函数试图将读取到的字符串写入这块内存时，必然会发生错误。
    // 当然，如果足够幸运的话，程序就运行成功了，
    // 表示str可能恰好指向一段分配好的、并且有读写权限的内存，但这是小概率事件，一般不会发生。
    char *str;
    gets(str);
    puts(str);
  } else if (2 == flag) {
    // 指向释放掉的内存
    char *str = (char *)malloc(20 * sizeof(char));
    strcpy(str, "C语言中文网");
    puts(str);
    // 使用free()释放内存的同时要将指针置为NULL，否则下次就无法判断指向的内存是否有效。
    free(str);
    if (str) {
      puts(str);
    }
  } else if (3 == flag) {
    // 函数外部指针指向函数内部的变量、数组等。
    char *pstr;
    func(&pstr);
    puts(pstr);
  } else if (4 == flag) {
    // 这就是内存泄露（Memory Leak），
    // 可以理解为程序和内存失去了联系，再也无法对它进行任何操作。
    // 第一次分配的100字节的内存没有指针指向它了，而且也不知道这块内存的地址，
    // 所以就再也无法找回了，也没法释放了，这块内存就成了垃圾内存，虽然毫无用处，
    // 但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。
    char *p = (char *)malloc(100 * sizeof(char));
    p = (char *)malloc(50 * sizeof(char));
    free(p);
    p = NULL;
  } else if (5 == flag) {
    // 一种内存泄露的情况：
    int *pOld = (int *)malloc(sizeof(int));
    int *pNew = (int *)malloc(sizeof(int));
    pOld = pNew;
    free(pOld);
  } else if (6 == flag) {
    // 不应该进行类似这面这样的操作：
    malloc(100 * sizeof(int));
    // 这样的操作没有意义，因为没有指针指向分配的内存，
    // 无法使用，而且无法通过free()释放掉，造成了内存泄露。
  }

  return 0;
}