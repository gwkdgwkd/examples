#include <iostream>
#include <string>

using namespace std;

// 类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例（Instance），拥有类的成员变量和成员函数。
// 类的成员变量称为类的属性（Property），类的成员函数称为类的方法（Method）。在面向对象的编程语言中，经常把函数（Function）称为方法（Method）。
// 与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。
// class是C++中新增的关键字，专门用来定义类。Student是类的名称；类名的首字母一般大写，以和其他的标识符区分开。
class Student {  // 由{}包围起来的部分有时也称为类体，和函数体的概念类似。
 public:  // public也是C++的新增关键字，它只能用在类的定义中。
  char *name;
  int age;
  float score;
  void say() {
    cout << name << "的年龄是" << age << "，成绩是" << score << endl;
  }
};  // 类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略。
// 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
// 类可以理解为一种新的数据类型，该数据类型的名称是Student。与char、int、float等不同的是，Student是一种复杂数据类型，可以包含基本类型，而且还有很多基本类型中没有的特性
// C语言中经典的指针在C++中仍然广泛使用，尤其是指向对象的指针，没有它就不能实现某些功能。
// 在栈上创建出来的对象都有一个名字，比如stu，使用指针指向它不是必须的。但是通过new创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，
// 所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用new在堆上创建出来的对象是匿名的，没法直接使用，必须要用一
// 个指针指向它，再借助指针来访问它的成员变量或成员函数。
// 栈内存是程序自动管理的，不能使用delete删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过delete删除。
// 在实际开发中，new和delete往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。
// 创建对象以后，可以使用点号.来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似
// 有了对象指针后，可以通过箭头->来访问对象的成员变量和成员函数，这和通过结构体指针来访问它的成员类似

// 类可以看做是一种数据类型，它类似于普通的数据类型，但是又有别于普通的数据类型。类这种数据类型是一个包含成员变量和成员函数的集合。
// 类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。
// 但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。
// 类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；
// 而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。
// 可以在类体中定义成员函数。也可以只在类体中声明函数，而将函数定义放在类体外面。
// 在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。
// 但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。
// 成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。
// 在类体中和类体外定义成员函数是有区别的：
// 在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加inline关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。
// 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是良好的编程习惯，实际开发中也是这样做的。
// 除非函数比较短小，希望定义为内联函数，那也没有什么不妥的。
// 如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加inline关键字。
// 当然你也可以在函数声明处加inline，不过这样做没有效果，编译器会忽略函数声明处的inline。
// 在类体外定义inline函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）。
// 虽然C++支持将内联函数定义在类的外部，但强烈建议将函数定义在类的内部，这样它会自动成为内联函数，何必费力不讨好地将它定义在类的外部呢，这样并没有任何优势。

// C++通过public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。
// 所谓访问权限，就是你能不能使用该类中的成员。
// Java、C#程序员注意，C++中的public、private、protected只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。
// 在类的内部（定义类的代码内部），无论成员被声明为public、protected还是private，都是可以互相访问的，没有访问权限的限制。
// 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private、protected属性的成员。
// 类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。
// 成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。
// private关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为public，
// 不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为private。
// 根据C++软件设计规范，项目中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为private，而只将允许通过对象调用的成员函数声明为public。
// 声明为protected的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问。
// 将成员变量声明为private、将部分成员函数声明为public的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。
// 声明为private的成员和声明为public的成员的次序任意，既可以先出现private部分，也可以先出现public部分。如果既不写private也不写public，就默认为private。
// 在一个类体中，private和public可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。
// 但是为了使程序清晰，应该养成这样的习惯，使每一种成员访问限定符在类定义体中只出现一次。

// 编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。
// 成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。
class Student1 {
 private:
  char *m_name;
  int m_age;
  float m_score;

 public:
  void setname(char *name);
  void setage(int age);
  void setscore(float score);
  void show();
};
// 类可以看做是一种复杂的数据类型，也可以使用sizeof求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。
// 和结构体非常类似，对象也会有内存对齐的问题。

// C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线_（不同的编译器有不同的实现），例如，func()编译后为func()或_func()。
// 而C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。
// 这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码（Name Mangling），是通过一种特殊的算法来实现的。
// Name Mangling的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。
// Name Mangling可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。
// 希望看到经Name Mangling产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。
// 成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。
// 如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。
// C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。
// 这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。
// 这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。

// 有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函数（Constructor）。
// 构造函数必须是public属性的，否则创建对象时无法调用。当然，设置为private、protected属性也不会报错，但是没有意义。
// 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：
//  不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void也不允许；
//  函数体中不能有return语句。
// 和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。
// 构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造
// 函数匹配；反过来说，创建对象时只有一个构造函数会被调用。
// 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。
// 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
// 实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。
// 最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。
class Student2 {
 private:
  char *m_name;
  int m_age;
  float m_score;

 public:
  Student2();
  Student2(char *name, int age, float score);
  void setname(char *name);
  void setage(int age);
  void setscore(float score);
  void show();
};
Student2::Student2() {
  cout << "default" << endl;
  m_name = NULL;
  m_age = 0;
  m_score = 0.0;
}
Student2::Student2(char *name, int age, float score) {
  m_name = name;
  m_age = age;
  m_score = score;
}
void Student2::setname(char *name) { m_name = name; }
void Student2::setage(int age) { m_age = age; }
void Student2::setscore(float score) { m_score = score; }
void Student2::show() {
  if (m_name == NULL || m_age <= 0) {
    cout << "成员变量还未初始化" << endl;
  } else {
    cout << m_name << "的年龄是" << m_age << "，成绩是" << m_score << endl;
  }
}

// 构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。
// 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
// 初始化列表可以用于全部成员变量，也可以只用于部分成员变量。
// 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。
// 构造函数初始化列表还有一个很重要的作用，那就是初始化const成员变量。初始化const成员变量的唯一方法就是使用初始化列表。
class Demo {
 private:
  int m_a;
  int m_b;

 public:
  Demo(int b);
  Demo(int a, int b);
  void show();
};
Demo::Demo(int b) : m_b(b), m_a(m_b) {}
Demo::Demo(int a, int b) : m_a(a) { m_b = 0; }
void Demo::show() { cout << m_a << ", " << m_b << endl; }

// 例如VS/VC不支持变长数组（数组长度不能是变量），我们自己定义了一个VLA类，用于模拟变长数组
class VLA {
 private:
  const int m_len;
  int *m_arr;

 public:
  VLA(int len);
  ~VLA();
};
VLA::~VLA() {
  delete[] m_arr;
  cout << "d" << endl;
}
VLA::VLA(int len) : m_len(len) {
  m_arr = new int[len];
  cout << "n" << endl;
}
// m_len加了const修饰，只能使用初始化列表的方式赋值，如果写作下面的形式是错误的：
// VLA::VLA(int len) {
//   m_len = len;
//   m_arr = new int[len];
// }

// 创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
// 析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。
// 构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。
// 析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
// 函数名是标识符的一种，原则上标识符的命名中不允许出现~符号，在析构函数的名字中出现的~可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。
// C++中的new和delete分别用来分配和释放内存，它们与C语言中malloc()、free()最大的一个不同之处在于：用new分配内存时会调用构造函数，用delete释放内存时会调用析构函数。
// 构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用new和delete。
// 析构函数的执行时机:
//  析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关。
//  在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。
//  在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。
//  new创建的对象位于堆区，通过delete删除时才会调用析构函数；如果没有delete，析构函数就不会被执行。
class Demo1 {
 public:
  Demo1(string s);
  ~Demo1();

 private:
  string m_s;
};
Demo1::Demo1(string s) : m_s(s) {}
Demo1::~Demo1() { cout << m_s << endl; }
void func() { Demo1 obj1("1"); }
Demo1 obj2("2");

int main() {
  // 在创建对象时，class关键字可要可不要，但是出于习惯我们通常会省略掉class关键字
  class Student LiLei1;
  Student liLei2;
  Student allStu[100];
  Student *pStu1 = &LiLei1;
  Student *pStu2 = new Student;  // 在堆上创建对象

  Student1 stu;
  cout << sizeof(stu) << endl;  // 16
  Student1 *pstu = new Student1();
  cout << sizeof(*pstu) << endl;     // 16
  cout << sizeof(Student1) << endl;  // 16

  // 在栈上创建对象时，实参位于对象名后面；在堆上创建对象时，实参位于类名后面。
  Student2 stu1((char *)"小明", 15, 92.5f);
  stu1.show();
  Student2 *pstu1 = new Student2((char *)"李华", 16, 96);
  pstu1->show();

  Student2 *pstu2 = new Student2();
  pstu2->show();  // 成员变量还未初始化
  pstu2->setname((char *)"李华");
  pstu2->setage(16);
  pstu2->setscore(96);
  pstu2->show();  // 李华的年龄是16，成绩是96

  Student2 s1();  // 为什么这个不调用？这是个函数声明？
  Student2 s2;    // default
  Student2 *p1 = new Student2();  // default
  Student2 *p2 = new Student2;    // default

  Demo obj(100);  // 成员变量的赋值顺序由它们在类中的声明顺序决定
  obj.show();  // 32523, 100

  VLA *parr = new VLA(5);  // n
  delete parr;             // d

  Demo1 obj3("3");
  Demo1 *pobj4 = new Demo1("4");
  func();
  cout << "main" << endl;
  // 1
  // main
  // 3
  // 2

  return 0;
}