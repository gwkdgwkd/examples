#include <iostream>

// 指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码。
// 这里有一个关键词需要强调，就是内存，指针只能指向内存，
// 不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。
// 其实C++代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、
// 字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，
// 这些内容都可以用&来获取地址，进而用指针指向它们。
// 除此之外，还有一些平时不太留意的临时数据，例如表达式的结果、
// 函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。
// 一旦被放到了寄存器中，就没法用&获取地址了，也就没法用指针指向它们了。

// 寄存器离CPU近并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。
// 但是寄存器的数量是非常有限的，容纳不下较大的数据，
// 所以只能将较小的临时数据放在寄存器中。
// int、double、bool、char等基本类型的数据往往不超过8个字节，
// 用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；
// 而对象、结构体变量是自定义类型的数据，大小不可预测，
// 所以这些类型的临时数据通常会放到内存中。

// 常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。
// 编译器不会分配单独的内存来存储常量表达式的值，
// 而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。
// 从汇编的角度看，常量表达式的值就是一个立即数，会被硬编码到指令中，不能寻址。
// 总起来说，常量表达式的值虽然在内存中，但是没有办法寻址，
// 所以也不能使用&来获取它的地址，更不能用指针指向它。

namespace n1 {
// 引用和指针在本质上是一样的，仅仅是对指针进行了简单的封装。
// 引用和指针都不能绑定到无法寻址的临时数据，C++对引用的要求更加严格，
// 在某些编译器下甚至连放在内存中的临时数据都不能指代。
// 在GCC下，引用不能指代任何临时数据，不管它保存到哪里；
// 在Visual C++下，引用只能指代位于内存中（非代码区）的临时数据，
// 不能指代寄存器中的临时数据。
// 当引用作为函数参数时，有时候很容易给它传递临时数据。
typedef struct {
  int a;
  int b;
} S;
S operator+(const S &A, const S &B) {
  S C;
  C.a = A.a + B.a;
  C.b = A.b + B.b;
  return C;
}
int func_int() {
  int n = 100;
  return n;
}
S func_s() {
  S s;
  s.a = 100;
  s.b = 200;
  return s;
}
int n = 100, m = 200;

void func1() {
  // 这些表达式的结果都会被放到寄存器中，尝试用&获取它们的地址都是错误的：
  // int *p1 = &(m + n);    // m + n的结果为300
  // int *p2 = &(n + 100);  // n + 100的结果为200
  // bool *p3 = &(m < n);   // m < n的结果为false

  // 函数的返回值也被放到寄存器中，也没法用&获取它的地址：
  // int *p4 = &(func_int());

  // S s1 = {23, 45};
  // S s2 = {90, 75};
  // S *p5 = &(s1 + s2);
  // error: taking address of rvalue [-fpermissive]

  // int *p6 = &(100);
  // int *p7 = &(23 + 45 * 2);
}

void func2() {
  // 下面的代码在GCC和Visual C++下都是错误的：
  // int &r1 = m + n;
  // int &r2 = m + 28;
  // int &r3 = 12 * 3;
  // int &r4 = 50;
  // int &r5 = func_int();

  // 下面的代码在GCC下是错误的，在Visual C++下是正确的：
  // S s1 = {23, 45};
  // S s2 = {90, 75};
  // S &r6 = func_s();
  // S &r7 = s1 + s2;
}

// 引用不能绑定到临时数据，这在大多数情况下是正确的，
// 但是当使用const关键字对引用加以限定后，引用就可以绑定到临时数据了。
// 将常引用绑定到临时数据时，编译器采取了一种妥协机制：
// 编译器会为临时数据创建一个新的、无名的临时变量，
// 并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。
// 注意，临时变量也是变量，所有的变量都会被分配内存。
// 为什么为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？
// 1.将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，
//   包括读取和写入（修改），尤其是写入操作，会改变数据的值。
//   而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，
//   那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，
//   这样就使得引用所绑定到的数据和原来的数据不能同步更新，
//   最终产生了两份不同的数据，失去了引用的意义。
//   总起来说，不管是从引用的语义这个角度看，还是从实际应用的效果这个角度看，
//   为普通引用创建临时变量都没有任何意义，所以编译器不会这么做。
// 2.const引用和普通引用不一样，只能读取数据的值，而不能修改它的值，
//   所以不用考虑同步更新的问题，也不会产生两份不同的数据，
//   为const引用创建临时变量反而会使得引用更加灵活和通用。
void func3() {
  // GCC和Visual C++下都能够编译通过：
  const int &r1 = m + n;
  const int &r2 = m + 28;
  const int &r3 = 12 * 3;
  const int &r4 = 50;
  const int &r5 = func_int();
  S s1 = {23, 45};
  S s2 = {90, 75};
  const S &r6 = func_s();
  const S &r7 = s1 + s2;
}

void func4() {
  // 不同类型的数据占用的内存数量不一样，处理方式也不一样，
  // 指针的类型要与它指向的数据的类型严格对应。
  // 虽然int可以自动转换为float，char也可以自动转换为int，
  // 但是float*类型的指针不能指向int，int*类型的指针也不能指向char。
  // 为什么编译器禁止指针指向不同类型的数据是合理的呢？
  // 让指针指向相关的（相近的）但不是严格对应的类型，表面上看起来是合理的，
  // 但是细思极恐，这样会给程序留下很多意想不到的、难以发现的Bug，
  // 所以编译器禁止这样做是非常合理的。
  // 当然，如果想通过强制类型转换达到目的，那编译器也不会管，允许自由发挥。

  // 让float *类型的指针强制指向int类型的数据
  int n1 = 100;
  float *p = (float *)&n1;
  *p = 19.625;
  std::cout << n1 << std::endl;  // 1100808192
  std::cout << *p << std::endl;  // 19.625
  // 虽然int和float类型都占用4个字节的内存，
  // 但是程序对它们的处理方式却大相径庭：
  // 1.对于int，程序把最高1位作为符号位，把剩下的31位作为数值位；
  // 2.对于float，程序把最高1位作为符号位，
  //   把最低的23位作为尾数位，把中间的8位作为指数位。
}

void func() {
  func1();
  func2();
  func3();
  func4();
}
}  // namespace n1

namespace n2 {
// 类型严格一致这条规则同样也适用于引用。
// 类型严格一致是为了防止发生让人匪夷所思的操作，
// 但是这条规则仅仅适用于普通引用，当对引用添加const限定后，
// 情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。
// 当引用的类型和数据的类型不一致时，如果它们的类型是相近的，
// 并且遵守数据类型的自动转换规则，那么编译器就会创建一个临时变量，
// 并将数据赋值给这个临时变量（这时候会发生自动类型转换），
// 然后再将引用绑定到这个临时的变量，
// 这与将const引用绑定到临时数据时采用的方案是一样的。
// 注意，临时变量的类型和引用的类型是一样的，
// 在将数据赋值给临时变量时会发生自动类型转换。
// 当引用的类型和数据的类型不遵守数据类型的自动转换规则，报错，绑定失败。

// 总结：
// 给引用添加const限定后，不但可以将引用绑定到临时数据，
// 还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，
// 它们背后的机制都是临时变量。
void func1() {
  int i = 7;
  int &ri = i;
  // float &rf = i;  // 错误
  const float crf = i;  // 正确

  char c = '@';
  char &rc = c;  // 正确
  // int &ri = c;         // 错误
  const int &cri = c;  // 正确
}

// 参数是引用类型，只能传递变量，不能传递常量或者表达式：
bool isOdd1(int &n) {
  if (n % 2 == 0) {
    return false;
  } else {
    return true;
  }
}
// 改为常引用，就可以接受常量或者表达式：
bool isOdd2(const int &n) {
  if (n / 2 == 0) {
    return false;
  } else {
    return true;
  }
}

void func2() {
  int a = 100;
  const int c = 101;

  // 来判断奇数的函数不能接受一个数字又让人感觉很奇怪：
  isOdd1(a);  // 正确
  // isOdd1(c);        // 错误
  // isOdd1(a + 9);    // 错误
  // isOdd1(27);       // 错误
  // isOdd1(23 + 55);  // 错误
  // isOdd1(2.4);      // 错误

  isOdd2(a);  // 正确，编译器不会创建临时变量，会直接绑定到变量a
  isOdd2(c);        // 正确
  isOdd2(a + 9);    // 正确
  isOdd2(27);       // 正确
  isOdd2(23 + 55);  // 正确
  isOdd2(2.4);      // 正确
  // 上面4行，编译器会创建临时变量（只有必要时才这样做）来存储临时数据。
}

void func() {
  func1();
  func2();
}
}  // namespace n2

namespace n3 {
// 当引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，
// 那么请尽量为该引用添加const限制。
// 概括起来说，将引用类型的形参添加const限制的理由有三个：
// 1.使用const可以避免无意中修改数据的编程错误；
// 2.使用const能让函数接收const和非const类型的实参，
//   否则将只能接收非const类型的实参；
// 3.使用const引用能够让函数正确生成并使用临时变量，
//   也就是说，调用时可以使用表达式或者可以自动转换的相近类型。
double func1(double &len, double &width, double &hei) {
  return len * width * 2 + len * hei * 2 + width * hei * 2;
}
double func2(const double &len, const double &width, const double &hei) {
  return len * width * 2 + len * hei * 2 + width * hei * 2;
}

void func() {
  int a = 12, b = 3;
  const int c = 20;

  // std::cout << func1(a, b, c) << std::endl;
  // std::cout << func1(10, 20, 30) << std::endl;
  // std::cout << func1(89.4, 32.7, 19) << std::endl;
  // std::cout << func1(a + 12.5, b + 23.4, 16.78) << std::endl;
  // std::cout << func1(a + b, a + c, b + c) << std::endl;

  std::cout << func2(a, b, c) << std::endl;                    // 672
  std::cout << func2(10, 20, 30) << std::endl;                 // 2200
  std::cout << func2(89.4, 32.7, 19) << std::endl;             // 10486.6
  std::cout << func2(a + 12.5, b + 23.4, 16.78) << std::endl;  // 3001.8
  std::cout << func2(a + b, a + c, b + c) << std::endl;        // 3001.8
}
}  // namespace n3

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 2]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';
  switch (type) {
    case 0:
      n1::func();
      break;
    case 1:
      n2::func();
      break;
    case 2:
      n3::func();
      break;
    default:
      std::cout << "invalid type" << std::endl;
      break;
  }

  return 0;
}