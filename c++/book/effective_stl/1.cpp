#include <iostream>

// 慎重选择容器类型

// 标准STL序列容器：vector、string、deque和list；
// 标准STL关联容器：set、multiset、map和multimap；
// 非标准的关联容器：hash_set、hash_multiset、hash_map和hash_multimap；
// 非标准序列容器：slist（单向链表）和rope（重型string）；
// 标准的非STL容器：数组、bitset、valarray、stack、queue和priority_queue。

// C++标准就如何在vector、deque和list中选择提供了如下建议：
// vector、deque和list提供了不同的复杂性，使用时要对此做出权衡。
// vector是默认使用的序列类型，当需要频繁地在中间插入和删除时，应使用list；
// 当大多数插入和删除操作发生在序列的头部和尾部时，deque是应考虑的数据结构。

// 连续内存容器，或称为基于数组的容器，把元素存放在一或多块（动态分配的）内存中，
// 每块内存中存有多个元素：
// 1.新元素被插入或已有元素被删除时，需要移动元素，这种移动影响效率和异常安全性。
// 2.vector、string、deque和非标准的rope都是连续内存容器。
// 基于节点的容器在每一个（动态分配的）内存块中只存放一个元素：
// 1.插入和删除只影响到指向节点的指针，不影响节点本身，不需要移动节点。
// 2.list、slist、所有标准的关联容器、非标准的哈希容器都使用基于节点的实现。

// 1.是否关心容器中的元素是如何排序的？
//   如果不关心，则哈希容器是一个可行的选择方案，否则，要避免哈希容器。
// 2.必须是标准容器么？
//   如果必须是，排除哈希容器、slist和rope。
// 3.需要哪种类型的迭代器？
//   必须是随机的，则只能是vector、deque和string。
//   如果要使用双向迭代器，必须避免slist和哈希容器的一个常见实现。
// 4.当发生插入时，避免移动是否重要？
//   如果是，要避免连续内存的容器。
// 5.容器中数据布局是否需要和C兼容？
//   如果需要，就只能选择vector。
// 6.元素查找速度是否是关键的考虑因素？
//   如果是，就要考虑哈希容器、排序的vector和标准关联容器，或许这就是优先顺序。
// 7.如果容器内部使用了引用计数技术，是否介意？
//   如果是，避免使用string和rope，可以考虑vector<char>。
// 8.对插入和删除操作，需要事物语义么？也就是说，在插入和删除失败时需要回滚能力吗？
//   如果需要，使用基于节点的容器，如果对多个元素的插入操作需要事物语义，
//   需要选择list，只有list对多个元素的插入操作提供了事物语义。
//   对希望编写异常安全代码的人来说，事物语义显得尤为重要。
//   使用连续内存的容器也可以获得事物语义，但是性能代价很大，也不直截了当。
// 9.需要使用迭代器、指针和引用变为无效的次数最少么？
//   如果是，使用基于节点的容器，插入和删除从来不会使迭代器、指针和引用失效。
//   连续内存的插入和删除通常会导致代器、指针和引用失效。
// 10.如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，
//   且插入操作只发生在末尾，则指向数据的指针和引用就不会失效，这样的容器是否有帮助？
//   如果是，选择deque，当插入仅在容器末尾发生时，deque的迭代器有可能失效。
//   deque是唯一的、迭代器可能失效而指针和引用不会失效的STL标准容器。

int main() { return 0; }