#include <iostream>

using namespace std;

// 指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码。这里有一个关键词需要强调，就是内存，指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。
// 其实C++代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，这些内容都可以用&来获取地址，进而用指针
// 指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它
// 们的地址了，也就没法用指针指向它们了。
// 表达式所产生的临时结果：
// int n = 100, m = 200;
// int *p1 = &(m + n);    // m + n的结果为300
// int *p2 = &(n + 100);  // n + 100的结果为200
// bool *p4 = &(m < n);   // m < n的结果为false
// 这些表达式的结果都会被放到寄存器中，尝试用&获取它们的地址都是错误的。
// int func() {
//   int n = 100;
//   return n;
// }
// int *p = &(func());
// func()的返回值100也会被放到寄存器中，也没法用&获取它的地址。

// 寄存器离CPU近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。
// int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；
// 而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

// 常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。
// 从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。
// 总起来说，常量表达式的值虽然在内存中，但是没有办法寻址，所以也不能使用&来获取它的地址，更不能用指针指向它。下面代码是错误的：
// int *p1 = &(100);
// int *p2 = &(23 + 45 * 2);

// 引用和指针在本质上是一样的，仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，C++对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代。
// 在GCC下，引用不能指代任何临时数据，不管它保存到哪里；
// 在Visual C++下，引用只能指代位于内存中（非代码区）的临时数据，不能指代寄存器中的临时数据。

// 当引用作为函数参数时，有时候很容易给它传递临时数据。

// 引用不能绑定到临时数据，这在大多数情况下是正确的，但是当使用const关键字对引用加以限定后，引用就可以绑定到临时数据了。
// 将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。
// 注意，临时变量也是变量，所有的变量都会被分配内存。
// 为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？
//  1 将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）； 尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建
//    了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。
//    总起来说，不管是从“引用的语义”这个角度看，还是从“实际应用的效果”这个角度看，为普通引用创建临时变量都没有任何意义，所以编译器不会这么做。
//  2 const引用和普通引用不一样，只能读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为const引用创建临时变量反而会使得引用更加灵活和通用。

// 不同类型的数据占用的内存数量不一样，处理方式也不一样，指针的类型要与它指向的数据的类型严格对应。
// 虽然int可以自动转换为float，char也可以自动转换为int，但是float *类型的指针不能指向int类型的数据，int *类型的指针也不能指向char类型的数据。
// 为什么「编译器禁止指针指向不同类型的数据」是合理的呢？
// 让指针指向「相关的（相近的）但不是严格对应的」类型的数据，表面上看起来是合理的，但是细思极恐，这样会给程序留下很多意想不到的、难以发现的Bug，所以编译器禁止这样做是非常合理的。
// 当然，如果你想通过强制类型转换达到这个目的，那编译器也会放任不管，给你自由发挥的余地。
// 引用（Reference）和指针（Pointer）在本质上是一样的，引用仅仅是对指针进行了简单的封装，「类型严格一致」这条规则同样也适用于引用。
// 「类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加const限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。
// 当引用的类型和数据的类型不一致时，如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则，那么编译器就会创建一个临时变量，并将数据赋值给这个临时变量（这时候会发生自动类型
// 转换），然后再将引用绑定到这个临时的变量，这与「将const引用绑定到临时数据时」采用的方案是一样的。
// 注意，临时变量的类型和引用的类型是一样的，在将数据赋值给临时变量时会发生自动类型转换。
// 当引用的类型和数据的类型不遵守「数据类型的自动转换」规则，那么编译器将报错，绑定失败:
// char *str = "http://c.biancheng.net";
// const int &r = str;
// 总结起来说，给引用添加const限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。

// 当引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，那么请尽量为该引用添加const限制。
// 概括起来说，将引用类型的形参添加const限制的理由有三个：
//  使用const可以避免无意中修改数据的编程错误；
//  使用const能让函数接收const和非const类型的实参，否则将只能接收非const类型的实参；
//  使用const引用能够让函数正确生成并使用临时变量。
double volume(const double &len, const double &width, const double &hei) {
  return len * width * 2 + len * hei * 2 + width * hei * 2;
}

typedef struct {
  int a;
  int b;
} S;
S operator+(const S &A, const S &B) {
  S C;
  C.a = A.a + B.a;
  C.b = A.b + B.b;
  return C;
}
S func() {
  S a;
  a.a = 100;
  a.b = 200;
  return a;
}
int func_int() {
  int n = 100;
  return n;
}
S func_s() {
  S a;
  a.a = 100;
  a.b = 200;
  return a;
}

// 参数是引用类型，只能传递变量，不能传递常量或者表达式。但用来判断奇数的函数不能接受一个数字又让人感觉很奇怪，所以类似这样的函数应该坚持使用值传递，而不是引用传递。
bool isOdd(int &n) {
  if (n % 2 == 0) {
    return false;
  } else {
    return true;
  }
}

bool isOdd1(const int &n) {  // 改为常引用
  if (n / 2 == 0) {
    return false;
  } else {
    return true;
  }
}

int main() {
  // S s1 = {23, 45};
  // S s2 = {90, 75};
  // S *p1 = &(s1 + s2);  // error: taking address of rvalue [-fpermissive]
  // S *p2 = &(func());   // error: taking address of rvalue [-fpermissive]
  // cout << p1 << ", " << p2 << endl;
  // 错误的，怎么证明结构他的临时变量保存在内存中？

  // 下面的代码在GCC和Visual C++下都是错误的
  // int m = 100, n = 36;
  // int &r1 = m + n;
  // int &r2 = m + 28;
  // int &r3 = 12 * 3;
  // int &r4 = 50;
  // int &r5 = func_int();

  // 下面的代码在GCC下是错误的，在Visual C++下是正确的
  // S s1 = {23, 45};
  // S s2 = {90, 75};
  // S &r6 = func_s();
  // S &r7 = s1 + s2;

  int a = 100;
  isOdd(a);  // 正确
  // isOdd(a + 9);    // 错误
  // isOdd(27);       // 错误
  // isOdd(23 + 55);  // 错误
  isOdd1(a);  // 正确，编译器不会创建临时变量，会直接绑定到变量a
  isOdd1(a + 9);    // 正确
  isOdd1(27);       // 正确
  isOdd1(23 + 55);  // 正确
  // 上面3行，编译器会创建临时变量来存储临时数据。也就是说，编译器只有在必要时才会创建临时变量。

  // GCC和Visual C++下都能够编译通过
  int m = 100, n = 36;
  const int &r1 = m + n;
  const int &r2 = m + 28;
  const int &r3 = 12 * 3;
  const int &r4 = 50;
  const int &r5 = func_int();
  S s1 = {23, 45};
  S s2 = {90, 75};
  const S &r6 = func_s();
  const S &r7 = s1 + s2;

  // 让float *类型的指针强制指向int类型的数据
  int n1 = 100;
  float *p = (float *)&n1;
  *p = 19.625;
  printf("%d\n", n1);  // 1100808192
  printf("%f\n", *p);  // 19.625000
  // 虽然int和float类型都占用4个字节的内存，但是程序对它们的处理方式却大相径庭：
  //  对于int，程序把最高1位作为符号位，把剩下的31位作为数值位；
  //  对于float，程序把最高1位作为符号位，把最低的23位作为尾数位，把中间的8位作为指数位。

  int n32 = 100;
  int &r32 = n32;          // 正确
  const float &r33 = n32;  // 正确
  char c = '@';
  char &r43 = c;       // 正确
  const int &r53 = c;  // 正确

  int ad = 12, bd = 3, cd = 20;
  double v1 = volume(ad, bd, cd);
  double v2 = volume(10, 20, 30);
  double v3 = volume(89.4, 32.7, 19);
  double v4 = volume(ad + 12.5, bd + 23.4, 16.78);
  double v5 = volume(ad + bd, ad + cd, bd + cd);
  printf("%lf, %lf, %lf, %lf, %lf\n", v1, v2, v3, v4, v5);

  return 0;
}