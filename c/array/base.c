#include <stdio.h>

// 数组（Array）就是一些列具有相同类型的数据的集合，
// 这些数据在内存中依次挨着存放，彼此之间没有缝隙。
// 数组不是C语言的专利，
// Java、C++、C#、JavaScript、PHP等其他编程语言也有数组。
// 数组属于构造数据类型。
// 一个数组可以分解为多个数组元素，数组元素可以是基本数据类型或是构造类型。
// 因此按数组元素的类型不同，
// 数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。

// 需要注意的是：
// 1.数组中每个元素的数据类型必须相同，
//   对于int a[4];，每个元素都必须为int。
// 2.数组长度length最好是整数或者常量表达式，例如10、20*4等，
//   这样在所有编译器下都能运行通过；如果length中包含了变量，
//   例如n、4*m等，在某些编译器下就会报错。
// 3.访问数组元素时，下标的取值范围为0≤index<length，
//   过大或过小都会越界，导致数组溢出，发生不可预测的情况。

// 数组内存是连续的
// 数组是一个整体，它的内存是连续的；
// 也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。
// 连续的内存为下面操作提供了便利：
// 1.指针操作，通过指针来访问数组元素；
// 2.内存处理，整块内存的复制、写入等。
// 这使得数组可以作为缓存（临时存储数据的一块内存）使用。

// 数组的初始化
// 在定义数组的同时赋值：int a[4] = {20, 345, 700, 22};
// 对于数组的初始化需要注意以下几点：
// 1.可以只给部分元素赋值。
//   当{}中值的个数少于元素个数时，只给前面部分元素赋值。
//   当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为0：
//   对于short、int、long，就是整数0；
//   对于char，就是字符'\0'；
//   对于float、double，就是小数0.0。
//   可以通过下面的形式将数组的所有元素初始化为 0：
//   int nums[10] = {0};
//   char str[10] = {0};
//   float scores[10] = {0.0};
//   由于剩余的元素会自动初始化为0，所以只需要给第0个元素赋值为0即可。
// 2.只能给元素逐个赋值，不能给数组整体赋值。
//   给10个元素全部赋值为1，只能写作：
//   int a[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
//   而不能写作int a[10] = 1;
// 3.如给全部元素赋值，那么在定义数组时可以不给出数组长度。
//   int a[] = {1, 2, 3, 4, 5};
//   等价于int a[5] = {1, 2, 3, 4, 5};

// C语言标准库没有提供与数组查询相关的函数，所以只能自己编写代码。
// 对无序数组的查询，所谓无序数组，就是数组元素的排列没有规律。
// 无序数组元素查询的思路也很简单，
// 就是用循环遍历数组中的每个元素，把要查询的值挨个比较一遍。
// 对有序数组的查询，只需要遍历其中一部分元素。

// 在C语言中，数组一旦被定义后，占用的内存空间就是固定的，
// 容量就是不可改变的，既不能在任何位置插入元素，
// 也不能在任何位置删除元素，只能读取和修改元素，这样的数组称为静态数组。
// 反过来说，如果数组在定义后可以改变容量，
// 允许在任意位置插入或者删除元素，那么这样的数组称为动态数组。
// PHP、JavaScript等解释型的脚本语言一般都支持动态数组，
// 而C、C++等编译型的语言一般不支持动态数组。
// C语言中的数组是静态的，一旦定义后长度就不能改变了。
// C语言数组为什么是静态的？
// 1.数组元素都是紧挨着排布的，中间没有空隙，
//   不管是插入元素还是删除元素，都得移动该元素后面的内存。
// 2.插入和删除数组元素都要移动内存，
//   甚至重新开辟一块内存，这是相当消耗资源的。
// 3.很多时候需要把数组的地址保存到一个变量里面，如果数组重新开辟了内存，
//   而变量里面的地址不跟着改变的话，后续再使用该变量就会导致错误。
// 4.让C语言本身去维护这些变量的值，以保持同步更新，
//   这又是不可能做到的，所以这个矛盾无法从根本上解决。
// 总之，为了保证程序执行效率，为了防止操作错误，
// C语言只支持静态数组，不支持动态数组。

// C语言数组的越界和溢出
// C语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，
// 就发生了越界（Out Of Bounds），访问到数组以外的内存。
// 如果下标小于零，就会发生下限越界（Off Normal Lower）；
// 如果下标大于等于数组长度，就会发生上限越界（Off Normal Upper）。
// C语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，
// 即使越界了，也能够正常编译，只有在运行期间才可能会发生问题。
// 越界访问的数组元素的值都是不确定的，没有实际的含义，
// 因为数组之外的内存我们并不知道是什么，可能是其它变量的值，
// 可能是函数参数，可能是一个地址，这些都是不可控的。
// 当发生数组越界时，如果对该内存有使用权限，
// 那么程序将正常运行，但会出现不可控的结果；
// 如果对该内存没有使用权限，或者该内存压根就没有被分配，那么程序将会崩溃。
// 当赋予数组的元素个数超过数组长度时，就会发生溢出（Overflow）。
// GCC、LLVM/Clang、低版本的VS（VS2010）发现数组溢出只会警告，并不会报错。
// 但是高版本的VS（VS2015、VS2017）发现数组溢出时会报错，
// 禁止编译通过，微软终于聪明了一次。
// 在用字符串给字符数组赋值时，要保证数组长度大于字符串长度，以容纳'\0'。

// C语言变长数组：使用变量指明数组的长度
// 在C89中，必须使用常量表达式指明数组长度；
// 也就是说，数组长度中不能包含变量，不管该变量有没有初始化。
// 而在C99中，可以使用变量指明数组长度。
// 变量的值在编译期间并不能确定，只有等到程序运行后，
// 根据计算结果才能知道它的值到底是什么，所以数组长度中一旦包含了变量，
// 那么数组长度在编译期间就不能确定了，也就不能为数组分配内存了，
// 只有等到程序运行后，得到了变量的值，确定了具体的长度，才能给数组分配内存，
// 将这样的数组称为变长数组(VLA, Variable Length Array)。
// 普通数组（固定长度的数组）是在编译期间分配内存的，
// 而变长数组是在运行期间分配内存的。
// 注意，变长数组是说数组的长度在定义之前可以改变，一旦定义了，
// 就不能再改变了，所以变长数组的容量也是不能扩大或缩小的，它仍然是静态数组。

// 数组（Array）是一系列相同类型的数据的集合，可以是一维的、二维的、多维的；
// 最常用的是一维数组和二维数组，多维数组较少用到。
// 数组长度length最好是常量表达式。
// 数组是一个整体，它的内存是连续的；
// 也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。
// 一般情况下，数组名会转换为数组的地址，需要使用地址的地方，使用数组名即可。

int main() { return 0; }