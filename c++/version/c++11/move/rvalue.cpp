#include <iostream>

// C++左值和右值：
// 在C/C++中，一个表达式根据其使用场景不同，分为左值表达式和右值表达式。
// 确切的说C++中左值和右值的概念是从C语言继承过来的。
// 值得一提的是，左值的英文简写为lvalue，右值的英文简写为rvalue。
// 很多人认为它们分别是left value、right value的缩写，其实不然。
// lvalue是loactor value，可意为存储在内存中、有明确存储地址的数据；
// 而rvalue是read value，指的是那些可以提供数据值的数据，
// 不一定可以寻址，例如存储于寄存器中的数据。

// 初学者都感觉右值引用晦涩难懂，其实不然，右值引用只不过是一种新的C++语法。
// 真正理解起来有难度的是基于右值引用引申出的2种C++编程技巧：
// 1.移动语义；
// 2.完美转发。

namespace n1 {
// 在C++中，一个表达式不是左值就是右值。
// 判断表达式是左值还是右值，最常用的有以下2种方法（只适用于大部分场景）:
// 1.可位于赋值号左侧的表达式就是左值，反之，只能位于赋值号右侧的表达式就是右值。
// 2.有名称的、可以获取到存储地址的表达式即为左值，反之则是右值。
void func() {
  int a = 5;  // 其中，变量a就是一个左值，而字面量5就是一个右值
  // 5 = a; // 错误，5不能为左值
  int b = 10;  // b是一个左值
  a = b;       // a、b都是左值，只不过可以把左值b当右值使用

  // 从2的角度看：
  // 1.a和b是变量名，且通过&a和&b可以获得他们的存储地址，因此a和b都是左值；
  // 2.字面量5、10，既无名称，也无法获取其存储地址，所以是右值，
  //   通常存储在寄存器中，或者和代码存储在一起。
}
}  // namespace n1

namespace n2 {
int num = 10;
namespace test1 {
// C++98/03标准中就有引用，使用&表示。
void func1() {
  // 非常量左值引用有一个缺陷，即正常情况下只能引用左值，不能引用右值：
  int &r1 = num;  // 引用左值，正确
  // int &c2 = 10; // 引用右值，错误

  // 因此，C++98/03标准中的引用又称为左值引用。
}
void func2() {
  // C++98/03不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。
  // 也就是说，常量左值引用既可以操作左值，也可以操作右值：
  const int &r1 = num;
  const int &r2 = 10;
  // r2 = 20;  // 常量左值引用不能对右值进行修改
}
}  // namespace test1

namespace test2 {
// 右值往往是没有名称的，因此要使用它只能借助引用的方式。
// 这就产生一个问题，可能需要对右值进行修改（实现移动语义时就需要），
// 显然常量左值引用的方式是行不通的。
// 为此，C++11标准新引入了另一种引用方式，称为右值引用，用&&表示。
// C++标准委员会在选定右值引用符号时，既希望能选用现有C++内部已有的符号，
// 还不能与C++98/03标准产生冲突，最终选定了2个&表示右值引用。
// 和左值引用一样，右值引用也必须立即初始化，且只能使用右值进行初始化。

// 右值引用可以从字面意思上理解，指的是以引用传递（非传值）的方式使用C++右值。
void func1() {
  // int &&r1 = num;  // 右值引用不能初始化为左值
  int &&r2 = 10;
  // 和常量左值引用不同的是，右值引用还可以对右值进行修改：
  r2 = 100;
  std::cout << r2 << std::endl;  // 100
}
void func2() {
  // C++语法上是支持定义常量右值引用的：
  const int &&a2 = 10;  // 编译器不会报错
  // 但这种定义出来的右值引用并无实际用处：
  // 1.右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；
  // 2.常量右值引用的作用就是引用一个不可修改的右值，可以用常量左值引用代替。
}
}  // namespace test2

void func() {
  test1::func1();
  test1::func2();
  test2::func1();
  test2::func2();
}
}  // namespace n2

namespace n3 {
// 引用类型 	                可以引用的值类型 	         使用场景
//                 非常量左值 常量左值 非常量右值 常量右值
// 1.非常量左值引用 	 Y 	       N 	     N 	      N 	  无
// 2.常量左值引用 	   Y 	       Y 	     Y 	      Y     类中拷贝构造函数，没有移动构造函数时，也可接受右值引用 
// 3.非常量右值引用    N         N       Y 	      N 	  移动语义、完美转发（模板中使用时，也可以接收左值）
// 4.常量右值引用 	   N 	       N 	     Y 	      Y     无实际用途

// C++11标准中对右值做了更细致的划分：
// 1.分别称为纯右值pure value，简称pvalue，就是C++98/03标准中的右值；
// 2.将亡值expiring value，简称xvalue，指的是和右值引用相关的表达式，
//   比如某函数返回的T&&类型的表达式。

const int cl = 1;    // 常量左值
int l = 2;           // 非常量左值
const int &&cr = 6;  // 常量右值，是这样的么？
// constexpr int cr = 6;  // 常量右值？

void func1() {  // 非常量左值引用
  int &lr1 = l;
  // int &lr2 = cl;
  // int &lr3 = 5;
  // int &lr4 = cr;
}
void func2() {  // 常量左值引用
  const int &clr1 = l;
  const int &clr2 = cl;
  const int &clr3 = 5;  // 不能修改右值
  const int &clr4 = cr;
}
void func3() {  // 非常量右值引用
  // int &&rr1 = l;
  // int &&rr2 = cl;
  int &&rr3 = 5;  // 可以修改右值
  // int &&rr4 = cr;
}
void func4() {  // 常量右值引用
  // const int &&crr1 = l;
  // const int &&crr2 = cl;
  const int &&crr3 = 5;
  // const int &&crr4 = cr;  // 这个怎么不行？
}

void func() {
  func1();
  func2();
  func3();
  func4();
}
}  // namespace n3

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 2]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';
  switch (type) {
    case 0:
      n1::func();
      break;
    case 1:
      n2::func();
      break;
    case 2:
      n3::func();
      break;
    default:
      std::cout << "invalid type" << std::endl;
      break;
  }

  return 0;
}