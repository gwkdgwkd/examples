# 设计模式

## 什么是设计模式
“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。
这样，你就能一次又一次地使用该方案而不必做重复劳动”。
——Christopher Alexander

## GOF设计模式
- 历史性著作《设计模式：可复用面向对象软件的基础》一书中描述了23种经典面向对象设计模式，创立了模式在软件设计中的地位。
- 由于《设计模式》一书确定了设计模式的地位，通常所说的设计模式隐含地表示“面向对象设计模式”。
  但这并不意味“设计模式”就等于“面向对象设计模式”。

## 从面向对象谈起
1. 底层思维：向下，如何把握机器底层从微观理解对象构造
- 语言构造 
- 编译转换
- 内存模型
- 运行时机制

2. 抽象思维：向上，如何将我们的周围，世界抽象为程序代码
- 面向对象
- 组件封装
- 设计模式
- 架构模式

## 深入理解面向对象
1. 向下：深入理解三大面向对象机制
- 封装，隐藏内部实现
- 继承，复用现有代码
- 多态，改写对象行为
2. 向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”

## 软件设计固有的复杂性
建筑商从来不会去想给一栋已建好的100层高的楼房底下再新修一个小地下室——这样做花费极大而且注定要失败。
然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。
——Object-Oriented Analysis and Designwith Applications

## 软件设计复杂的根本原因
- 客户需求的变化
- 技术平台的变化
- 开发团队的变化
- 市场环境的变化
- ...

## 如何解决复杂性？
两种手段：
1. 分解
人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。
2. 抽象
更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。
由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。

## 软件设计的目标
什么是好的软件设计？软件设计的金科玉律：复用！（编译单元即二进制的复用，不是单纯的代码复用）
一个目标：管理变化，提高复用！

# 面向对象设计原则

## 面向对象设计，为什么？
面向对象设计，为什么？变化是复用的天敌！面向对象设计最大的优势在于：抵御变化！

## 重新认识面向对象
1. 理解隔离变化
从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
2. 各司其职
从微观层面来看，面向对象的方式更强调各个类的“责任”。
由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
3. 对象是什么？
- 从语言实现层面来看，对象封装了代码和数据。
- 从规格层面讲，对象是一系列可被使用的公共接口。
- 从概念层面讲，对象是某种拥有责任的抽象
  
## 面向对象设计原则
1. 依赖倒置原则（DIP）
- 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
- 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。
2. 开放封闭原则（OCP）
- 对扩展开放，对更改封闭。
- 类模块应该是可扩展的，但是不可修改。
3. 单一职责原则（SRP）
- 一个类应该仅有一个引起它变化的原因。
- 变化的方向隐含着类的责任。
4. Liskov 替换原则（LSP）
- 子类必须能够替换它们的基类(IS-A)。
- 继承表达类型抽象。
5. 接口隔离原则（ISP）
- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。
6. 优先使用对象组合，而不是类继承
- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
7. 封装变化点
- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
8. 针对接口编程，而不是针对实现编程
- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

## 将设计原则提升为设计经验
1. 设计习语Design Idioms
Design Idioms描述与特定编程语言相关的低层模式，技巧，惯用法。
2. 设计模式Design Patterns
Design Patterns主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。
3. 架构模式Architectural Patterns
Architectural Patterns描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。

# 分类

## GOF-23模式分类
1. 从目的来看：
- 创建型（Creational）模式：
  将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
- 结构型（Structural）模式：
  通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
- 行为型（Behavioral）模式：
  通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
  
1. 从范围来看：
- 类模式处理类与子类的静态关系。
- 对象模式处理对象间的动态关系。

## 从封装变化角度对模式分类
1. 组件协作：
- Template Method
- Observer / Event
- Strategy
2. 单一职责：
- Decorator
- Bridge
3. 对象创建:
- Factory Method
- Abstract Factory
- Prototype
- Builder
4. 对象性能：
- Singleton
- Flyweight
5. 接口隔离:
- Façade
- Proxy
- Mediator
- Adapter
6. 状态变化：
- Memento
- State
7. 数据结构：
- Composite
- Iterator
- Chain of Resposibility
8. 行为变化：
- Command
- Visitor
9. 领域问题：
- Interpreter

## 重构关键技术
- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

对上面关键词的理解，比理解具体某个设计模式要重要。
境界到了，就会理解上面的5条说的是同一件事。

## 重构获得模式 Refactoring to Patterns
- 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“应对变化，提高复用”的设计。
- 现代软件设计的特征是“需求的频繁变化”：
  - 设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”。
  - “什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
- 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用：
  - 没有一步到位的设计模式。
  - 敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。

# 总结

## C++对象模型
```
class A:B{ // 继承
  // ...
}
内存模型：[B A]
class A{ // 组合对象
  B b;
  // ...
}
内存模型：[B A]
class A{ // 组合指针
  B *pb
  // ...
}
           B
内存模型：[A ↑]
```
- 继承和对象组合的内存模型没什么区别，几乎一样，性能也一样。
- 几乎所有模式的类图都是使用的组合指针的模型。
- 继承和对象组合没有灵活性，传递子类对象的话，会发生对象切割。
- 指针执行多态对象变成了松耦合结构的对象模型基础。

## 什么时候不用模式
- 代码可读性很差时
- 需求理解还很浅时
- 变化没有显现时
- 不是系统的关键依赖点
- 项目没有复用价值时
- 项目将要发布时

## 经验之谈
- 不要为模式而模式
- 关注抽象类&接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有Framework和Application的区隔思维
- 良好的设计是演化的结果

## 设计模式成长之路
- “手中无剑，心中无剑”：见模式而不知
- “手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式
- “手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式
- “手中无剑，心中无剑”：忘掉模式，只有原则