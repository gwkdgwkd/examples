#include <iostream>
#include <string>

using namespace std;

// 类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例（Instance），拥有类的成员变量和成员函数。
// 类的成员变量称为类的属性（Property），类的成员函数称为类的方法（Method）。在面向对象的编程语言中，经常把函数（Function）称为方法（Method）。
// 与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。
// class是C++中新增的关键字，专门用来定义类。Student是类的名称；类名的首字母一般大写，以和其他的标识符区分开。
class Student {  // 由{}包围起来的部分有时也称为类体，和函数体的概念类似。
 public:  // public也是C++的新增关键字，它只能用在类的定义中。
  char *name;
  int age;
  float score;
  void say() {
    cout << name << "的年龄是" << age << "，成绩是" << score << endl;
  }
};  // 类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略。
// 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
// 类可以理解为一种新的数据类型，该数据类型的名称是Student。与char、int、float等不同的是，Student是一种复杂数据类型，可以包含基本类型，而且还有很多基本类型中没有的特性
// C语言中经典的指针在C++中仍然广泛使用，尤其是指向对象的指针，没有它就不能实现某些功能。
// 在栈上创建出来的对象都有一个名字，比如stu，使用指针指向它不是必须的。但是通过new创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，
// 所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用new在堆上创建出来的对象是匿名的，没法直接使用，必须要用一
// 个指针指向它，再借助指针来访问它的成员变量或成员函数。
// 栈内存是程序自动管理的，不能使用delete删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过delete删除。
// 在实际开发中，new和delete往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。
// 创建对象以后，可以使用点号.来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似
// 有了对象指针后，可以通过箭头->来访问对象的成员变量和成员函数，这和通过结构体指针来访问它的成员类似

// 类可以看做是一种数据类型，它类似于普通的数据类型，但是又有别于普通的数据类型。类这种数据类型是一个包含成员变量和成员函数的集合。
// 类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。
// 但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。
// 类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；
// 而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。
// 可以在类体中定义成员函数。也可以只在类体中声明函数，而将函数定义放在类体外面。
// 在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。
// 但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。
// 成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。
// 在类体中和类体外定义成员函数是有区别的：
// 在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加inline关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。
// 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是良好的编程习惯，实际开发中也是这样做的。
// 除非函数比较短小，希望定义为内联函数，那也没有什么不妥的。
// 如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加inline关键字。
// 当然你也可以在函数声明处加inline，不过这样做没有效果，编译器会忽略函数声明处的inline。
// 在类体外定义inline函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）。
// 虽然C++支持将内联函数定义在类的外部，但强烈建议将函数定义在类的内部，这样它会自动成为内联函数，何必费力不讨好地将它定义在类的外部呢，这样并没有任何优势。

// C++通过public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。
// 所谓访问权限，就是你能不能使用该类中的成员。
// Java、C#程序员注意，C++中的public、private、protected只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。
// 在类的内部（定义类的代码内部），无论成员被声明为public、protected还是private，都是可以互相访问的，没有访问权限的限制。
// 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private、protected属性的成员。
// 类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。
// 成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。
// private关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为public，
// 不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为private。
// 根据C++软件设计规范，项目中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为private，而只将允许通过对象调用的成员函数声明为public。
// 声明为protected的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问。
// 将成员变量声明为private、将部分成员函数声明为public的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。
// 声明为private的成员和声明为public的成员的次序任意，既可以先出现private部分，也可以先出现public部分。如果既不写private也不写public，就默认为private。
// 在一个类体中，private和public可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。
// 但是为了使程序清晰，应该养成这样的习惯，使每一种成员访问限定符在类定义体中只出现一次。

// 编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。
// 成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。
class Student1 {
 private:
  char *m_name;
  int m_age;
  float m_score;

 public:
  void setname(char *name);
  void setage(int age);
  void setscore(float score);
  void show();
};
// 类可以看做是一种复杂的数据类型，也可以使用sizeof求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。
// 和结构体非常类似，对象也会有内存对齐的问题。

// C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线_（不同的编译器有不同的实现），例如，func()编译后为func()或_func()。
// 而C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。
// 这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码（Name Mangling），是通过一种特殊的算法来实现的。
// Name Mangling的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。
// Name Mangling可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。
// 希望看到经Name Mangling产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。
// 成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。
// 如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。
// C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。
// 这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。
// 这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。

// 有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函数（Constructor）。
// 构造函数必须是public属性的，否则创建对象时无法调用。当然，设置为private、protected属性也不会报错，但是没有意义。
// 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：
//  不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void也不允许；
//  函数体中不能有return语句。
// 和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。
// 构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造
// 函数匹配；反过来说，创建对象时只有一个构造函数会被调用。
// 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。
// 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
// 实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。
// 最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。
class Student2 {
 private:
  char *m_name;
  int m_age;
  float m_score;

 public:
  Student2();
  Student2(char *name, int age, float score);
  void setname(char *name);
  void setage(int age);
  void setscore(float score);
  void show();
};
Student2::Student2() {
  cout << "default" << endl;
  m_name = NULL;
  m_age = 0;
  m_score = 0.0;
}
Student2::Student2(char *name, int age, float score) {
  m_name = name;
  m_age = age;
  m_score = score;
}
void Student2::setname(char *name) { m_name = name; }
void Student2::setage(int age) { m_age = age; }
void Student2::setscore(float score) { m_score = score; }
void Student2::show() {
  if (m_name == NULL || m_age <= 0) {
    cout << "成员变量还未初始化" << endl;
  } else {
    cout << m_name << "的年龄是" << m_age << "，成绩是" << m_score << endl;
  }
}

// 构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。
// 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
// 初始化列表可以用于全部成员变量，也可以只用于部分成员变量。
// 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。
// 构造函数初始化列表还有一个很重要的作用，那就是初始化const成员变量。初始化const成员变量的唯一方法就是使用初始化列表。
class Demo {
 private:
  int m_a;
  int m_b;

 public:
  Demo(int b);
  Demo(int a, int b);
  void show();
};
Demo::Demo(int b) : m_b(b), m_a(m_b) {}
Demo::Demo(int a, int b) : m_a(a) { m_b = 0; }
void Demo::show() { cout << m_a << ", " << m_b << endl; }

// 例如VS/VC不支持变长数组（数组长度不能是变量），我们自己定义了一个VLA类，用于模拟变长数组
class VLA {
 private:
  const int m_len;
  int *m_arr;

 public:
  VLA(int len);
  ~VLA();
};
VLA::~VLA() {
  delete[] m_arr;
  cout << "d" << endl;
}
VLA::VLA(int len) : m_len(len) {
  m_arr = new int[len];
  cout << "n" << endl;
}
// m_len加了const修饰，只能使用初始化列表的方式赋值，如果写作下面的形式是错误的：
// VLA::VLA(int len) {
//   m_len = len;
//   m_arr = new int[len];
// }

// 创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
// 析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。
// 构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。
// 析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
// 函数名是标识符的一种，原则上标识符的命名中不允许出现~符号，在析构函数的名字中出现的~可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。
// C++中的new和delete分别用来分配和释放内存，它们与C语言中malloc()、free()最大的一个不同之处在于：用new分配内存时会调用构造函数，用delete释放内存时会调用析构函数。
// 构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用new和delete。
// 析构函数的执行时机:
//  析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关。
//  在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。
//  在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。
//  new创建的对象位于堆区，通过delete删除时才会调用析构函数；如果没有delete，析构函数就不会被执行。
class Demo1 {
 public:
  Demo1(string s);
  ~Demo1();

 private:
  string m_s;
};
Demo1::Demo1(string s) : m_s(s) {}
Demo1::~Demo1() { cout << m_s << endl; }
void func() { Demo1 obj1("1"); }
Demo1 obj2("2");

// C++允许数组的每个元素都是对象，这样的数组称为对象数组。
class CSample {
 public:
  CSample() {  // 构造函数1
    cout << "Constructor 1 Called" << endl;
  }
  CSample(int n) {  // 构造函数2
    cout << "Constructor 2 Called" << endl;
  }
};
// 在构造函数有多个参数时，数组的初始化列表中要显式地包含对构造函数的调用。
class CTest {
 public:
  CTest(int n) {}         // 构造函数(1)
  CTest(int n, int m) {}  // 构造函数(2)
  CTest() {}              // 构造函数(3)
};

// 一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）。
// 创建封闭类的对象时，它包含的成员对象也需要被创建，这就会引发成员对象构造函数的调用。成员对象到底是用哪个构造函数初始化的呢？需要借助封闭类构造函数的初始化列表。
//  对于基本类型的成员变量，“参数表”中只有一个值，就是初始值，在调用构造函数时，会把这个初始值直接赋给成员变量。
//  但是对于成员对象，“参数表”中存放的是构造函数的参数，它可能是一个值，也可能是多个值，它指明了该成员对象如何被初始化。
// 总之，生成封闭类对象的语句一定要让编译器能够弄明白其成员对象是如何初始化的，否则就会编译错误。
class Tyre {
 public:
  Tyre(int radius, int width);
  void show() const;

 private:
  int m_radius;
  int m_width;
};
Tyre::Tyre(int radius, int width) : m_radius(radius), m_width(width) {}
void Tyre::show() const {
  cout << "轮毂半径：" << this->m_radius << "吋" << endl;
  cout << "轮胎宽度：" << this->m_width << "mm" << endl;
}
class Engine {
 public:
  Engine(float displacement = 2.0);
  void show() const;

 private:
  float m_displacement;
};
Engine::Engine(float displacement) : m_displacement(displacement) {}
void Engine::show() const {
  cout << "排量：" << this->m_displacement << "L" << endl;
}
class Car {
 public:
  Car(int price, int radius, int width);
  void show() const;

 private:
  int m_price;
  Tyre m_tyre;
  Engine m_engine;
};
Car::Car(int price, int radius, int width)
    : m_price(price), m_tyre(radius, width){};
void Car::show() const {
  cout << "价格：" << this->m_price << "￥" << endl;
  this->m_tyre.show();
  this->m_engine.show();
}
// 封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化
// 列表中出现的次序无关。当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后
// 析构，这是C++处理此类次序问题的一般规律。
class Tyre1 {
 public:
  Tyre1() { cout << "Tyre constructor" << endl; }
  ~Tyre1() { cout << "Tyre destructor" << endl; }
};
class Engine1 {
 public:
  Engine1() { cout << "Engine constructor" << endl; }
  ~Engine1() { cout << "Engine destructor" << endl; }
};
class Car1 {
 private:
  Engine1 engine;
  Tyre1 tyre;

 public:
  Car1() { cout << "Car constructor" << endl; }
  ~Car1() { cout << "Car destructor" << endl; }
};

// this是C++中的一个关键字，也是一个const指针，它指向当前对象，通过它可以访问当前对象的所有成员。所谓当前对象，是指正在使用的对象。
// this只能用在类的内部，通过this可以访问类的所有成员，包括private、protected、public属性的。this是一个指针，要用->来访问成员变量或成员函数。
// this虽然用在类的内部，但是只有在对象被创建以后才会给this赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给this赋值。
// 注意：
//  this是const指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
//  this只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
//  只有当对象被创建后this才有意义，因此不能在static成员函数中使用
// this实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给this。
// 不过this这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
// this作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给this赋值。
// 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。
// 这个额外的参数，实际上就是this，它是成员函数和成员变量关联的桥梁。
class S {
 public:
  void setname(char *name);
  void show();
  void printThis();

 private:
  char *name;
};
void S::setname(char *name) { this->name = name; }
void S::show() { cout << this->name << endl; }
void S::printThis() { cout << this << endl; }

// 类其实也是一种作用域，每个类都会定义它自己的作用域。在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员既可以通过对象访问，
// 又可以通过类访问，而typedef定义的类型只能通过类来访问。
// 一个类就是一个作用域的事实能够很好的解释为什么我们在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，类内部成员的名字是不可见的。
class A {
 public:
  typedef int INT;
  static void show();
  INT work();

 private:
  int n;
};
void A::show() { cout << "show()" << endl; }
// 函数的返回值类型出现在函数名之前，当成员函数定义在类的外部时，返回值类型中使用的名字都位于类的作用域之外，此时必须指明该名字是哪个类的成员。
A::INT A::work() {
  cout << "work()" << endl;
  // 一旦遇到类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，可以直接使用类的其他成员而无需再次授权了。
  n = 10;
  return n;
}

// C++中保留了C语言的struct关键字，并且加以扩充。在C语言中，struct只能包含成员变量，不能包含成员函数。
// 而在C++中，struct类似于class，既可以包含成员变量，又可以包含成员函数。
// C++中的struct和class基本是通用的，唯有几个细节不同：
//  使用class时，类中的成员默认都是private属性的；而使用struct时，结构体中的成员默认都是public属性的。
//  class继承默认是private继承，而struct继承默认是public继承。
//  class可以使用模板，而struct不能。
// C++没有抛弃C语言中的struct关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。
// 在编写C++代码时，我强烈建议使用class来定义类，而使用struct来定义结构体，这样做语义更加明确。

int main() {
  // 在创建对象时，class关键字可要可不要，但是出于习惯我们通常会省略掉class关键字
  class Student LiLei1;
  Student liLei2;
  Student allStu[100];
  Student *pStu1 = &LiLei1;
  Student *pStu2 = new Student;  // 在堆上创建对象

  Student1 stu;
  cout << sizeof(stu) << endl;  // 16
  Student1 *pstu = new Student1();
  cout << sizeof(*pstu) << endl;     // 16
  cout << sizeof(Student1) << endl;  // 16

  // 在栈上创建对象时，实参位于对象名后面；在堆上创建对象时，实参位于类名后面。
  Student2 stu1((char *)"小明", 15, 92.5f);
  stu1.show();
  Student2 *pstu1 = new Student2((char *)"李华", 16, 96);
  pstu1->show();

  Student2 *pstu2 = new Student2();
  pstu2->show();  // 成员变量还未初始化
  pstu2->setname((char *)"李华");
  pstu2->setage(16);
  pstu2->setscore(96);
  pstu2->show();  // 李华的年龄是16，成绩是96

  Student2 s1();  // 为什么这个不调用？这是个函数声明？
  Student2 s2;    // default
  Student2 *p1 = new Student2();  // default
  Student2 *p2 = new Student2;    // default

  Demo obj(100);  // 成员变量的赋值顺序由它们在类中的声明顺序决定
  obj.show();  // 32523, 100

  VLA *parr = new VLA(5);  // n
  delete parr;             // d

  Demo1 obj3("3");
  Demo1 *pobj4 = new Demo1("4");
  func();
  cout << "main" << endl;
  // 1
  // main
  // 3
  // 2

  // 对象数组中的每个元素都需要用构造函数初始化。具体哪些元素用哪些构造函数初始化，取决于定义数组时的写法
  cout << "step1" << endl;
  CSample array1[2];
  cout << "step2" << endl;
  CSample array2[2] = {4, 5};
  cout << "step3" << endl;
  CSample array3[2] = {3};
  cout << "step4" << endl;
  CSample *array4 = new CSample[2];
  delete[] array4;
  // step1
  // Constructor 1 Called
  // Constructor 1 Called
  // step2
  // Constructor 2 Called
  // Constructor 2 Called
  // step3
  // Constructor 2 Called
  // Constructor 1 Called
  // step4
  // Constructor 1 Called
  // Constructor 1 Called

  CTest array5[3] = {1, CTest(1, 2)};
  CTest array6[3] = {CTest(2, 3), CTest(1, 2), 1};
  CTest *pArray[3] = {new CTest(4), new CTest(1, 2)};

  Car car(200000, 19, 245);
  car.show();
  // 价格：200000￥
  // 轮毂半径：19吋
  // 轮胎宽度：245mm
  // 排量：2L

  Car1 car1;
  // Engine constructor
  // Tyre constructor
  // Car constructor
  // Car destructor
  // Tyre destructor
  // Engine destructor

  S *ps = new S;
  ps->setname((char *)"李华");
  ps->show();

  ps->printThis();     // 0x8ad160
  cout << ps << endl;  // 0x8ad160
  S *ps2 = new S;
  ps2->printThis();     // 0x8ad180
  cout << ps2 << endl;  // 0x8ad180

  A a;
  a.work();       // 通过对象访问普通成员
  a.show();       // 通过对象访问静态成员
  A::show();      // 通过类访问静态成员
  A::INT n = 10;  // 通过类访问typedef定义的类型

  return 0;
}

// 总结：
// 类的成员有成员变量和成员函数两种。
// 成员函数之间可以互相调用，成员函数内部可以访问成员变量。
// 私有成员只能在类的成员函数内部访问。默认情况下，class类的成员是私有的，struct类的成员是公有的。
// 可以用“对象名.成员名”、“引用名.成员名”、“对象指针->成员名”的方法访问对象的成员变量或调用成员函数。成员函数被调用时，可以用上述三种方法指定函数是作用在哪个对象上的。
// 对象所占用的存储空间的大小等于各成员变量所占用的存储空间的大小之和（如果不考虑成员变量对齐问题的话）。
// 定义类时，如果一个构造函数都不写，则编译器自动生成默认（无参）构造函数和复制构造函数。如果编写了构造函数，则编译器不自动生成默认构造函数。
// 一个类不一定会有默认构造函数，但一定会有复制构造函数。
// 任何生成对象的语句都要说明对象是用哪个构造函数初始化的。即便定义对象数组，也要对数组中的每个元素如何初始化进行说明。如果不说明，则编译器认为对象是用默认构造函数或参数
// 全部可以省略的构造函数初始化。在这种情况下，如果类没有默认构造函数或参数全部可以省略的构造函数，则编译出错。
// 对象在消亡时会调用析构函数。
// 每个对象有各自的一份普通成员变量，但是静态成员变量只有一份，被所有对象所共享。静态成员函数不具体作用于某个对象。即便对象不存在，也可以访问类的静态成员。静态成员函数内
// 部不能访问非静态成员变量，也不能调用非静态成员函数。
// 常量对象上面不能执行非常量成员函数，只能执行常量成员函数。
// 包含成员对象的类叫封闭类。任何能够生成封闭类对象的语句，都要说明对象中包含的成员对象是如何初始化的。如果不说明，则编译器认为成员对象是用默认构造函数或参数全部可以省略
// 的构造函数初始化。
// 在封闭类的构造函数的初始化列表中可以说明成员对象如何初始化。封闭类对象生成时，先执行成员对象的构造函数，再执行自身的构造函数；封闭类对象消亡时，先执行自身的析构函数，
// 再执行成员对象的析构函数。
// const 成员和引用成员必须在构造函数的初始化列表中初始化，此后值不可修改。
// 友元分为友元函数和友元类。友元关系不能传递。
// 成员函数中出现的this指针，就是指向成员函数所作用的对象的指针。因此，静态成员函数内部不能出现this指针。成员函数实际上的参数个数比表面上看到的多一个this指针。