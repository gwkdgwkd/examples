#include <iostream>

// 函数是一个可以重复使用的代码块，CPU会一条一条地挨着执行其中的代码。
// CPU在执行主调函数时遇到了被调函数，主调函数会暂停，CPU转而执行被调函数；
// 被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。
// 一个C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，
// 它们形成了一个或简单或复杂的调用链条，起点是main()，终点也是main()。
// 当main()调用完了所有函数，会return一个值来结束自己，从而结束整个程序。

// 函数调用是有时间和空间开销的，程序执行函数前需要做些准备工作，
// 将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才执行函数体中的代码；
// 函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，
// 才能接着执行函数调用位置以后的代码。
// 如果函数体代码比较多，需要较长的执行时间，那么函数调用的耗时可以忽略；
// 如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，
// 这种时间开销就不容忽视，为了消除函数调用的时空开销，C++提供了提高效率的方法，
// 即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。
// 这种在函数调用处直接嵌入函数体的函数称为内联函数，又称内嵌函数或者内置函数。
// 要在函数定义处添加inline关键字，在函数声明处添加inline关键字虽然没有错，
// 但这种做法是无效的，编译器会忽略函数声明处的inline关键字。
// 当函数比较复杂时，函数调用的时空开销可以忽略，
// 大部分的时间都会花费在执行函数体上，所以一般是将非常短小的函数声明为内联函数。
// 由于内联函数比较短小，通常的做法是省略函数原型，
// 将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。
// 使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，
// 如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，
// 所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。
// 对函数作inline声明只是程序员对编译器提出的一个建议，
// 而不是强制性的，并非一经指定为inline编译器就必须这样做。
// 编译器有自己的判断能力，它会根据具体情况决定是否这样做。
// 指定内联函数的方法很简单，只需要在函数定义处增加inline关键字。

// 宏是可以带参数的，它在形式上和函数非常相似，宏定义是一项细思极密的工作，
// 一不小心就会踩坑，而且在编译和运行时难发现，给程序埋下隐患。
// 不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意：
#define SQ1(y) y *y
#define SQ2(y) (y) * (y)
#define SQ3(y) ((y) * (y))
void func1() {
  int n = 9;
  std::cout << SQ1(9) << std::endl;  // 81
  std::cout << SQ1(n + 1) << std::endl;  // 19
  // SQ(n+1)在宏展开后会变为sq=n+1*n+1

  std::cout << SQ2(n + 1) << std::endl;  // 100
  std::cout << 200 / SQ2(n + 1) << std::endl;  // 200
  // 200/SQ(n+1)会被展开为sq=200/(n+1)*(n+1)

  std::cout << SQ3(9) << std::endl;            // 81
  std::cout << SQ3(n + 1) << std::endl;        // 100
  std::cout << 200 / SQ3(n + 1) << std::endl;  // 2
}

// 将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余：
inline int SQ(int y) { return y * y; }
void func2() {
  int n = 9;
  std::cout << SQ(9) << std::endl;            // 81
  std::cout << SQ(n + 1) << std::endl;        // 100
  std::cout << 200 / SQ(n + 1) << std::endl;  // 2
}

// 编写C++代码时推荐使用内联函数来替换带参数的宏。
// 和宏一样，内联函数可以定义在头文件中（不用加static），
// 并且头文件被多次#include后也不会引发重复定义错误。
// 这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，
// 它所在的头文件被多次#include后会引发重复定义错误。
// 内联函数在编译时会将函数调用处用函数体替换，
// 编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。
// 这一点和宏很像，宏在预处理时被展开，编译时就不存在了。
// 从这个角度讲，内联函数更像是编译期间的宏。
// 内联函数主要有两个作用：
// 1.消除函数调用时的开销；
// 2.取代带参数的宏。

// inline关键字：
// 1.可以只在函数定义处添加；
// 2.可以只在函数声明处添加；
// 3.也可以在函数声明处和函数定义处同时添加，
// 但是在函数声明处的inline是无效的，编译器会忽略函数声明处的inline。
// 也就是说，inline是一种用于实现的关键字，而不是一种用于声明的关键字。
// 尽管大多数教科书中在函数声明和函数定义处都增加了inline关键字，
// 但inline关键字不应该出现在函数声明处。
// 这虽然不会影响函数的功能，但是体现了高质量C++程序设计风格的基本原则：
// 1.声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联；
// 2.更为严格地说，内联函数不应该有声明，
//   应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格。
// 在多文件编程中，通常将函数的定义放在源文件中，将函数的声明放在头文件中，
// 调用函数时，引入头文件即可，鼓励这种将函数定义和函数声明分开的做法。
// 但这并不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错。
// main.cpp
// void func();
// int main(){ func(); return 0;}
// module.cpp
// inline void func(){ cout<<"inline function"<<endl;}
// 代码能够正常编译，但在链接时会出错。
// func()是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，
// 链接器在将多个目标文件合并成可执行文件时找不到func()的定义，会产生链接错误。
// 内联函数也叫做函数，定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。
// 函数是一段可以重复使用的代码，位于虚拟地址空间中的代码区，也占用可执行文件的体积，
// 而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。
// 内联函数看起来简单，但是有很多细节需要注意，
// 从代码重复利用的角度讲，内联函数已经不再是函数了。
// 将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用。
// 在多文件编程时，建议将内联函数的定义直接放在头文件中，并且不要声明内联函数。

int main() {
  func1();
  func2();

  return 0;
}