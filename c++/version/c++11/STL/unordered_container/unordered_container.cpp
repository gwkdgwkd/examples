#include <iostream>
#include <unordered_map>

// 一类特殊的关联式容器，它们常被称为无序容器、哈希容器或者无序关联容器。
// 无序容器是C++11标准才正式引入到STL标准库中的，
// 这意味着如果要使用该类容器，则必须选择支持C++11标准的编译器。
// 和关联式容器一样，无序容器也使用键值对（pair类型）的方式存储数据。
// 不过它们有本质上的不同：
// 1.关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；
// 2.无序容器的底层实现采用的是哈希表的存储结构。

// STL底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，
// 并且当数据存储位置发生冲突时，解决方法选用的是链地址法（又称开链法）。
// 基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下2个特点：
// 1.无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，
//   和关联式容器相比，无序容器擅长通过指定键查找对应的值，平均时间复杂度为O(1)；
// 2.对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

// STL无序容器种类：
// 和关联式容器一样，无序容器只是一类容器的统称，其包含有4个具体容器，
// 为unordered_map、unordered_multimap、unordered_set及unordered_multiset。
// unordered_map存储键值对<key,value>类型的元素，
// 其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。
// unordered_multimap和unordered_map唯一的区别在于，允许存储多个键相同的键值对。
// unordered_set不再存储键值对，而是直接存储数据本身，元素不能重复，而且是无序的。
// unordered_multiset和unordered_set唯一的区别在于，该容器允许存储值相同的元素。

// C++11在4种关联式容器的基础上，又新增了各自的unordered版，提高了查找元素的效率。
// 它们仅有一个区别，即是否会对存储的键值对进行排序。
// 实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；
// 反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。

int main() { return 0; }