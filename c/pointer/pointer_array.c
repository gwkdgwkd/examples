#include <stdio.h>

// 如果一个数组中的所有元素保存的都是指针，那么就称它为指针数组。
// 指针数组的定义形式一般为：
// dataType *arrayName[length];
// []的优先级高于*，该定义形式应该理解为：
// dataType *(arrayName[length]);
// 括号里面说明arrayName是一个数组，包含了length个元素，
// 括号外面说明每个元素的类型为dataType*。
// 除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的。

// 二维数组在概念上是二维的，有行和列，
// 但在内存中所有的数组元素都是连续排列的，它们之间没有缝隙。
// int a[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};
// 从概念上理解，a的分布像一个矩阵：
//   0   1   2   3
//   4   5   6   7
//   8   9  10  11
// 但在内存中，a的分布是一维线性的，整个数组占用一块连续的内存：
//  0 1 2 3 4 5 6 7 8 9 10 11
// C语言允许把一个二维数组分解成多个一维数组来处理。
// 对于数组a，它可以分解成三个一维数组，即a[0]、a[1]、a[2]。
// 每一个一维数组又包含了4个元素，
// 例如a[0]包含a[0][0]、a[0][1]、a[0][2]、a[0][3]。
// 定义指针int (*p)[4] = a;可以推断出：
// a+i == p+i
// a[i] == p[i] == *(a+i) == *(p+i)
// a[i][j]==p[i][j]==*(a[i]+j)==*(p[i]+j)==*(*(a+i)+j)==*(*(p+i)+j)

// 指针数组和二维数组指针的区别
// 指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：
//  int *(p1[5]);  // 指针数组，可以去掉括号直接写作int *p1[5];
//  int (*p2)[5];  // 二维数组指针，不能去掉括号
// 指针数组和二维数组指针有着本质上的区别：
// 指针数组是一个数组，只是每个元素保存的都是指针，
// 以上面的p1为例，在32位环境下它占用4×5 = 20个字节的内存。
// 二维数组指针是一个指针，它指向一个二维数组，
// 以上面的p2为例，它占用4个字节的内存。

// main()是C程序的入口函数，有且只能有一个，它实际上有两种标准的原型：
//  int main();
//  int main(int argc, char *argv[]);
// argc表示传递的字符串的数目，argv是一个指针数组，
// 每个指针指向一个字符串（一份数据）。

int main() {
  int a = 16, b = 932, c = 100;
  // 定义一个指针数组：
  int *arr[3] = {&a, &b, &c};  // 也可以不指定长度，直接写作int *arr[]
  // 定义一个指向指针数组的指针：
  int **parr = arr;
  printf("%d,%d,%d\n", *arr[0], *arr[1], *arr[2]);                 // 16,932,100
  printf("%d,%d,%d\n", **(parr + 0), **(parr + 1), **(parr + 2));  // 16,932,100

  // 指针数组还可以和字符串数组结合使用：
  char *str[3] = {"c.biancheng.net", "C语言中文网", "C Language"};
  printf("%s %s %s\n", str[0], str[1], str[2]);
  // c.biancheng.net C语言中文网 C Language
  // 字符数组str中存放的是字符串的首地址，不是字符串本身，
  // 字符串本身位于其他的内存区域，和字符数组是分开的。
  // 也只有当指针数组中每个元素的类型都是char *时，
  // 才能像上面那样给指针数组赋值，其他类型不行。

  // 在表达式中使用lines时，它会转换为一个类型为char**的指针，
  // 这样*lines就表示一个指向字符的指针，而**lines表示一个具体的字符。
  // 指针是可以进行运算的，lines表示数组的首地址（第0个元素的地址），
  // lines+0、lines+1、lines+2...分别表示第0、1、2...个元素的地址，
  // *(lines+0)或lines[0]、*(lines+1)或lines[1]、
  // *(lines+2)或lines[2]...分别是字符串string0,
  // string1, string2...的首地址。
  // 所以：
  //  *lines == *(lines+0) == lines[0] == string0
  //  *(lines+1) == lines[1] == string1
  //  *(lines+2) == lines[2] == string2
  // 注意：
  // lines是二级指针，*(lines+i)是一级指针，**(lines+i)才是具体的字符。
  char *lines[5] = {"COSC1283/1284", "Programming", "Techniques", "is",
                    "great fun"};
  char *str1 = lines[1];
  char *str2 = *(lines + 3);
  // *(lines + 4) + 6 == lines[4] + 6 == string4 + 6，
  // 表示字符串string4中第6个字符的地址，即f的地址，
  // 所以*(*(lines + 4) + 6)就表示字符f。
  char c1 = *(*(lines + 4) + 6);
  // (*lines + 5)[5]：*lines + 5为字符串string0中第5个字符的地址，
  // 即2的地址，(*lines + 5)[5]等价于*(*lines + 5 + 5)，
  // 表示第10个字符，即2。
  char c2 = (*lines + 5)[5];
  // *lines[0] + 2：lines[0]为字符串string0中第0个字符的地址，
  // 即C的地址，*lines[0]也就表示第0个字符，即字符C。
  // 字符与整数运算，首先转换为该字符对应的ASCII码，然后再运算，
  // 所以*lines[0] + 2 = 67 + 2 = 69，69对应的字符为E。
  char c3 = *lines[0] + 2;
  printf("str1 = %s\n", str1);  // str1 = Programming
  printf("str2 = %s\n", str2);  // str2 = is
  printf("  c1 = %c\n", c1);    // c1 = f
  printf("  c2 = %c\n", c2);    // c2 = 2
  printf("  c3 = %c\n", c3);    // c3 = E

  int aa[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};
  int(*p)[4] = aa;
  // 括号中的*表明p是一个指针，它指向一个数组，数组的类型为int[4]，
  // 这正是a所包含的每个一维数组的类型。
  // []的优先级高于*，()是必须要加的，如果赤裸裸地写作int *p[4]，
  // 那应该理解为int *(p[4])，p就成了指针数组，而不是二维数组指针。
  int *pp[4];
  printf("aap: %d, pp: %d\n", sizeof(p), sizeof(pp));  // aap: 8, pp: 32
  // 对指针进行加法（减法）运算时，
  // 它前进（后退）的步长与它指向的数据类型有关，
  // p指向的数据类型是int[4]，
  // 那么p+1就前进4×4 = 16个字节，p-1就后退16个字节，
  // 这正好是数组a所包含的每个一维数组的长度。
  // 也就是说，p+1会使得指针指向二维数组的下一行，
  // p-1会使得指针指向数组的上一行。
  // 数组名a在表达式中也会被转换为和p等价的指针！
  // 1.p指向数组a的开头，也即第0行；p+1前进一行，指向第1行。
  // 2.*(p+1)表示取地址上的数据，也就是整个第1行数据。
  //   注意是一行数据，是多个数据，不是第1行中的第0个元素。
  printf("%x(%ld),%x(%ld)\n", p, p, p + 1, p + 1);
  // cde63300(140736647803648),cde63310(140736647803664)
  printf("%d\n", sizeof(*(p + 1)));  // 16
  // 3.*(p+1)+1表示第1行第1个元素的地址。
  //   *(p+1)单独使用时表示的是第1行数据，
  //   放在表达式中会被转换为第1行数据的首地址，
  //   也就是第1行第0个元素的地址，因为使用整行数据没有实际的含义，
  //   编译器会转换为指向该行第0个元素的指针；
  //   就像一维数组的名字，在定义时或者和sizeof、&一起使用时才表示整个数组，
  //   出现在表达式中就会被转换为指向数组第0个元素的指针。
  // 4.*(*(p+1)+1)表示第1行第1个元素的值。
  //   很明显，增加一个*表示取地址上的数据。
  printf("%d\n", *(*(p + 1) + 1));  // 5

  int i = 1, j = 2;
  // a+i == p+i
  printf("a+i : %x\n", aa + i);  // 2c1fa450
  printf("p+i : %x\n", p + i);   // 2c1fa450
  // a[i] == p[i] == *(a+i) == *(p+i)
  printf("a[i] : %x\n", aa[i]);        // 2c1fa450
  printf("p[i] : %x\n", p[i]);         // 2c1fa450
  printf("*(a+i) : %x\n", *(aa + i));  // 2c1fa450
  printf("*(p+i) : %x\n", *(p + i));   // 2c1fa450
  // a[i][j]==p[i][j]==*(a[i]+j)==*(p[i]+j)==*(*(a+i)+j)==*(*(p+i)+j)
  printf("a[i][j] : %d\n", aa[i][j]);              // 6
  printf("p[i][j] : %d\n", p[i][j]);               // 6
  printf("*(a[i]+j) : %d\n", *(aa[i] + j));        // 6
  printf("*(p[i]+j) : %d\n", *(p[i] + j));         // 6
  printf("*(*(a+i)+j) : %d\n", *(*(aa + i) + j));  // 6
  printf("*(*(p+i)+j) : %d\n", *(*(p + i) + j));   // 6

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 4; j++) printf("%2d  ", *(*(p + i) + j));
    printf("\n");
  }
  //  0   1   2   3
  //  4   5   6   7
  //  8   9  10  11

  return 0;
}