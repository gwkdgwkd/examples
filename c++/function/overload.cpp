#include <iostream>

using namespace std;

// 在实际开发中，有时候我们需要实现几个功能类似的函数，只是有些细节不同。例如希望交换两个变量的值，这两个变量有多种类型，可以是int、float、char、bool等
// 在C语言中，程序员往往需要分别设计出三个不同名的函数，其函数原型：
//  void swap1(int *a, int *b);
//  void swap2(float *a, float *b);
//  void swap3(char *a, char *b);
//  void swap4(bool *a, bool *b);
// 但在C++中，这完全没有必要。C++允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。
// 参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。
//  void Swap(int *a, int *b);
//  void Swap(float *a, float *b);
//  void Swap(char *a, char *b);
//  void Swap(bool *a, bool *b);
// 重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。
// 重载的结果是让一个函数名拥有了多种用途，使得命名更加方便（在中大型项目中，给变量、函数、类起名字是一件让人苦恼的问题），调用更加灵活。
// 在使用重载函数时，同名函数的功能应当相同或相近，不要用同一函数名去实现完全不相干的功能，虽然程序也能运行，但可读性不好，使人觉得莫名其妙。
// 参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据。重载的规则：
//  1 函数名称必须相同。
//  2 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
//  3 函数的返回类型可以相同也可以不相同。
//  4 仅仅返回类型不同不足以成为函数的重载。
// C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。
// 当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。
// 不同的编译器有不同的重命名方式。从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

// 发生函数调用时编译器会根据传入的实参的个数、类型、顺序等信息去匹配要调用的函数，这在大部分情况下都能够精确匹配。
// 但当实参的类型和形参的类型不一致时情况就会变得稍微复杂，例如函数形参的类型是int，调用函数时却将short类型的数据交给了它，编译器就需要先将short类型转换为int类型才能匹配成功。
void func(char ch) { cout << "#1" << endl; }
void func(int n) { cout << "#2" << endl; }
void func(long m) { cout << "#3" << endl; }
void func(double f) { cout << "#4" << endl; }
// 将2号函数void func(int n)去掉,编译时发生了错误，大概的意思是：func(s)和func(49)这两个函数发生调用错误，它们可以匹配三个重载函数中的任何一个，编译器不知道如何抉择。
// 根据以往的编程经验，s和49不都应该被转换成long类型，从而匹配3号函数void func(long m)吗？这种推论在一般的函数调用或者四则运算中确实没错，但它不一定适用于重载函数！
// C++标准规定，在进行重载决议时编译器应该按照下面的优先级顺序来处理实参的类型：
// 优先级 	                    包含的内容 	                  举例说明
// 精确匹配 	                不做类型转换，直接匹配 	       （暂无说明）
//                             只是做微不足道的转换 	      从数组名到数组指针、从函数名到指向函数的指针、从非const类型到const类型。
// 类型提升后匹配 	              整型提升 	                   从bool、char、short提升为int，或者从char16_t、char32_t、wchar_t提升为int、long、long long。
//                             小数提升 	                从float提升为double。
// 使用自动类型转换后匹配 	        整型转换 	                从char到long、short到long、int到short、long到char。
//                              小数转换 	                从double到float。
//                              整数和小数转换 	             从int到double、short到float、float到int、double到long。
//                              指针转换 	                从int *到void *。
// C++还规定，编译器应该按照从高到低的顺序来搜索重载函数，首先是精确匹配，然后是类型提升，最后才是类型转换；一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。
// 如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，
// 因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。
// 类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。
// 当重载函数有多个参数时也会产生二义性，而且情况更加复杂。C++标准规定，如果有且只有一个函数满足下列条件，则匹配成功：
//  该函数对每个实参的匹配都不劣于其他函数；
//  至少有一个实参的匹配优于其他函数。
// void func2(int, int);  // ①
// void func2(char, int, float);  // ②
// void func2(char, long, double);  // ③
// short n = 99;
// func2('@', n, 99);
// func2('@', n, 99.5);
// 函数原型func(int, int)只有两个参数，而函数调用有三个参数，很容易看出来不匹配，在初次筛选时就会被过滤掉，接下来我们只讨论②③个函数原型。
// 先来看第一个函数调用:
//  如果只考虑第一个实参'@'，那么②③两个函数都能够精确匹配，谁也不比谁优秀，是平等的；如果只考虑第二个实参n，对于②，需要把short提升为int（类型提升），对于③，需要把short转换
//  为long（类型转换），类型提升的优先级高于类型转换，所以②胜出；如果只考虑第三个实参99，②③都要进行类型转换，没有哪一个能胜出，它们是平等的。
//  从整体上看，②③在第一、三个实参的匹配中是平等的，但②在第二个实参的匹配中胜出，也就是说，②对每个实参的匹配都不劣于③，但有一个实参的匹配优于③，所以②最终脱颖而出，成为被调用函数。
// 再来看第二个函数调用:
//  只考虑第一个实参时②③是平等的，没有谁胜出；只考虑第二个实参时②胜出；只考虑第三个实参时，②需要类型转换，③能够精确匹配，精确匹配的优先级高于类型转换，所以③胜出。
//  从整体上看，②③在第一个实参的匹配中是平等的，②在第二个实参的匹配中胜出，③在第三个实参的匹配中胜出，它们最终“打成了平手”，分不清孰优孰劣，所以编译器不知道如何抉择，会产生二义性错误。
// 在设计重载函数时，参数类型过少或者过多都容易引起二义性错误，因为这些类型相近，彼此之间会相互转换。

// 在一个项目中，能否既包含C++程序又包含C程序呢？换句话说，C++和C可以进行混合编程吗？
// 在C++出现之前，很多实用的功能都是用C语言开发的，很多底层的库也是用C语言编写的。这意味着，如果能在C++代码中兼容C语言代码，无疑能极大地提高C++程序员的开发效率。
// C++和C可以进行混合编程。但需要注意的是，由于C++和C在程序的编译、链接等方面都存在一定的差异，而这些差异往往会导致程序运行失败。
// C++支持函数的重载，是因为C++会在程序的编译阶段对函数的函数名进行“再次重命名”。但是，C语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动。
// 不同的编译器有不同的重命名方式，但根据C++标准编译后的函数名几乎都由原有函数名和各个参数的数据类型构成，而根据C语言标准编译后的函数名则仅有原函数名构成。
// 这也就意味着，使用C和C++进行混合编程时，考虑到对函数名的处理方式不同，势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。
// 幸运的是，C++给出了相应的解决方案，即借助extern "C"，就可以轻松解决C++和C在处理代码方式上的差异性。
// extern是C和C++的一个关键字，但对于extern "C"，大可以将其看做一个整体，和extern毫无关系。
// extern "C"既可以修饰一句C++代码，也可以修饰一段C++代码，它的功能是让编译器以处理C语言代码的方式来处理修饰的C++代码。
// myfun.h：
//  #ifdef __cplusplus
//  extern "C" void display();
//  #else
//  void display();
//  #endif
// 无论display()函数位于C++程序还是C语言程序，都保证了display()函数可以按照C语言的标准来处理。
// 解决C++和C混合编程的问题，通常在头文件中使用如下格式：
// #ifdef __cplusplus
// extern "C" {
// #endif
// void display();
// #ifdef __cplusplus
// }
// #endif
// extern "C"大致有2种用法:
//  当仅修饰一句C++代码时，直接将其添加到该函数代码的开头即可；
//  如果用于修饰一段C++代码，只需为extern "C"添加一对大括号{}，并将要修饰的代码囊括到括号内即可。

int main() {
  short s = 99;
  float f = 84.6;

  func('a');  // #1 不需要类型转换，调用func(char)
  func(s);    // #2 将short转换成int，调用func(int)
  func(49);   // #2 不需要类型转换，调用func(int)
  func(f);    // #4 将float转换成double，调用func(double)

  return 0;
}