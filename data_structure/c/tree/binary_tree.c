#include <stdio.h>
#include <stdlib.h>

// 简单地理解，满足以下两个条件的树就是二叉树：
// 1.本身是有序树；
// 2.树中包含的各个节点的度不能超过2，即只能是0、1或者2；

// 二叉树的性质
// 1.二叉树中，第i层最多有2^(i-1)个结点。
// 2.如果二叉树的深度为K，那么此二叉树最多有2^K-1个结点。
// 3.二叉树中，终端结点数（叶子结点数）为n0，度为2的结点数为n2，则n0=n2+1。
// 性质3的计算方法为：
// 对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点（设为n1），那么总结点n=n0+n1+n2。
// 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数n=B+1。
// 而分枝数是可以通过n1和n2表示的，即B=n1+2*n2。
// 所以，n用另外一种方式表示为n=n1+2*n2+1。两种方式得到的n值组成一个方程组，就可以得出n0=n2+1。

// 满二叉树
// 如果二叉树中除了叶子结点，每个结点的度都为2，则此二叉树称为满二叉树。
// 满二叉树除了满足普通二叉树的性质，还具有以下性质：
// 1.满二叉树中第i层的节点数为2^(i-1)个。
// 2.深度为k的满二叉树必有2^k-1个节点，叶子数为2^(k-1)。
// 3.满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
// 4.具有n个节点的满二叉树的深度为log2(n+1)。

// 完全二叉树
// 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。
// 完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n个结点的完全二叉树的深度为log2n+1。
// log2n表示取小于log2n的最大整数。例如，log24=2，而log25结果也是2。
// 对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点i，完全二叉树还有以下几个结论成立：
// 1.当i>1时，父亲结点为结点[i/2]。（i=1时，表示的是根结点，无父亲结点）
// 2.如果2*i>n（总结点的个数），则结点i肯定没有左孩子（为叶子结点）；否则其左孩子是结点2*i 。
// 3.如果2*i+1>n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1 。

// 二叉树的存储结构有两种，分别为顺序存储和链式存储。
// 二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。
// 需要注意的是，顺序存储只适用于完全二叉树。
// 换句话说，只有完全二叉树才可以使用顺序表存储。
// 因此，如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。
// 满二叉树也可以使用顺序存储。要知道，满二叉树也是完全二叉树，因为它满足完全二叉树的所有特征。
// 普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其"拼凑"成完全二叉树即可。
// 完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。
// 从顺序表中还原完全二叉树也很简单。
// 完全二叉树具有这样的性质，将树中节点按照层次并从左到右依次标号（1,2,3,...），
// 若节点i有左右孩子，则其左孩子节点为2*i，右孩子节点为2*i+1。
// 此性质可用于还原数组中存储的完全二叉树。

// 其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，
// 普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。
// 采用链式存储二叉树时，其节点结构由3部分构成：
// 1.指向左孩子节点的指针（Lchild）；
// 2.节点存储的数据（data）；
// 3.指向右孩子节点的指针（Rchild）；
// 在某些实际场景中，可能会做"查找某节点的父节点"的操作，这时可以在节点结构中再添加一个指针域，
// 用于各个节点指向其父亲节点。这样的链表结构，通常称为三叉链表。
#define TElemType int
typedef struct BiTNode {
  TElemType data;                   // 数据域
  struct BiTNode *lchild, *rchild;  // 左右孩子指针
  struct BiTNode *parent;
} BiTNode, *BiTree;

void CreateBiTree(BiTree *T) {
  *T = (BiTNode *)malloc(sizeof(BiTNode));
  (*T)->data = 1;
  (*T)->lchild = (BiTNode *)malloc(sizeof(BiTNode));
  (*T)->lchild->data = 2;
  (*T)->rchild = (BiTNode *)malloc(sizeof(BiTNode));
  (*T)->rchild->data = 3;
  (*T)->rchild->lchild = NULL;
  (*T)->rchild->rchild = NULL;
  (*T)->lchild->lchild = (BiTNode *)malloc(sizeof(BiTNode));
  (*T)->lchild->lchild->data = 4;
  (*T)->lchild->rchild = NULL;
  (*T)->lchild->lchild->lchild = NULL;
  (*T)->lchild->lchild->rchild = NULL;
}

int main() {
  BiTree Tree;
  CreateBiTree(&Tree);
  printf("%d\n", Tree->lchild->lchild->data);  // 4

  return 0;
}

// 森林，指的是由n（n>=2）棵互不相交的树组成的集合。
// 在某些实际场景中，为了便于操作具有森林结构的数据，往往需要将森林转化为一整棵二叉树。
// 任意一棵普通树都可以转化为二叉树，而森林是由多棵普通树构成的，因此自然也可以转化为二叉树，其转化方法是：
// 1.首先将森林中所有的普通树各自转化为二叉树；
// 2.将森林中第一棵树的树根作为整个森林的树根，其他树的根节点看作是第一棵树根节点的兄弟节点，
//   采用孩子兄弟表示法将所有树进行连接；

// 普通树组成的森林：
//              A            E         G
//            / | \          |        / \
//           B  C  D         F       H   I
//                                       |
//                                       J
// 含有多个二叉树的森林：
//             A             E         G
//            /             /         /
//           B             F         H
//            \                       \
//             C                       I
//              \                     /
//               D                   J
// 二叉树：
//                        A
//                      /   \
//                    B       E
//                     \     / \
//                      C   F   G
//                       \     /
//                        D   H
//                             \
//                              I
//                             /
//                            J

// 森林转化为二叉树，更多的是为了对森林中的节点做遍历操作。
// 遍历二叉树有4种方法，分别是层次遍历、先序遍历、中序遍历和后序遍历。
// 转化前的森林与转化后的二叉树相比，其层次遍历和后序遍历的访问节点顺序不同，
// 而前序遍历和中序遍历访问节点的顺序是相同的。
// 由二叉树转化为森林的过程也就是森林转化二叉树的逆过程。

// 如果两棵树中各个结点的位置都一一对应，可以说这两棵树相似。
// 如果两棵树不仅相似，而且对应结点上的数据也相同，就可以说这两棵树等价。
// 当给定n（n>=0）个结点时，可以构建多少种形态不同的树。
// 对于任意一棵普通树，通过孩子兄弟表示法的转化，都可以找到唯一的一棵二叉树与之对应。
// 所以等价于n个结点可以构建多少种形态不同的二叉树。
// Cn=C(2n,n)/(n+1) 注：C(n,r)=n!/[r!(n-r)!]
