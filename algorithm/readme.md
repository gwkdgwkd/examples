# 算法是什么
代指解决问题的过程（步骤、方案），规定了解决某个问题的具体步骤，先做什么、再做什么、最后做什么，只要依次完成这些步骤，问题就可以得到解决。

# 时间复杂度和空间复杂度
算法本身是不分“好坏”的，所谓“最好”的算法，指的是最适合当前场景的算法。挑选算法时，主要考虑以下两方面因素：
执行效率：根据算法所编写的程序，执行时间越短，执行效率就越高；
占用的内存空间：不同算法编写出的程序，运行时占用的内存空间也不相同。如果实际场景中仅能使用少量的内存空间，就应该优先选择占用空间最少的算法。
## 时间复杂度
计算它的时间复杂度，只需经历以下几个步骤：
1. 统计算法中各个步骤的执行次数
    ```
    输入 n           <- 执行1次
    p <- 1          <- 执行1次
    for i<-1 to n： <- i的值从1遍历到n，当i的值为n+1的时候退出循环，总共执行n+1次
      p <- p * i    <- i从1到n的过程，共执行n次
    Print p         <- 执行1次
    ```
   所有伪指令执行的总次数，结果为2*n+4。
2. 简化算法的执行次数
   通过统计各个算法中每条伪指令的执行次数，每个算法的运行时间都可以用类似2*n+4、3*n2+4*n+5这样的表达式表示。
   这就产生一个问题，如何比较各个表达式的大小呢？
   首先，我们可以尝试对每个表达式进行简化，简化方法是：
   假设表达式中变量的值无限大时，去除掉那些对表达式结果影响较小的项。以3*n2+4*n+5为例，简化过程为：
   - 当n无限大时，3*n^2+4*n与3*n^2+4*n+5的值非常接近，是否加5对表达式的值影响不大，因此表达式可以简化为3*n^2+4*n；
   - 当n无限大时，3*n^2的值要远远大于4*n的值，它们之间类似于10000和1之间的关系，因此是否加4*n对表达式最终的值影响不大，整个表达式可以简化为3*n^2；
   - 当n无限大时，n^2的值已经超级大，是否乘3对最终结果影响不大，整个表达式可以简化为n^2。
  
   简化表达式的过程可以总结为：
   - 去掉表达式中所有的加法常数项，3*n^2+4*n+5中的5就是加法常数项；
   - 只保留表达式中变量指数最大的项，3*n^2+4*n中n的最大指数为2，所以只保留3*n^2；
   - 去掉常数系数，3*n^2中的3就是n^2的常数系数。
   基于“n值无限大”的思想，3*n^2+4*n+5最终可以简化为n^2。无论多么复杂的表达式，都可以采用这种方式进行简化。
3. 大O记法表示时间复杂度
   都用n作为表达式中的变量，并采用大O记法表示算法的执行时间。采用大O记法表示算法的执行时间，直接套用如下的格式即可：
    ```
    O(频度)
    频度指的就是简化后的表达式。
    ```

   采用大O记法，2*n+4可以用O(n)表示，3*n^2 +4*n+5可以用O(n^2)表示。
   注意，如果一个算法对应的表达式中没有变量（比如10，100等），则用O(1)表示算法的执行时间。
   如果一个算法的执行时间最终估算为O(n)，那么该算法的时间复杂度就是O(n)。如下列举了常用的几种时间复杂度以及它们之间的大小关系：
    ```
    O(1)< O(logn) < O(n) < O(n^2) < O(n^3) < O(2^n)
    O(1)是最小的，对应的算法的执行时间最短，执行效率最高。
    ```
## 空间复杂度
空间复杂度衡量的是算法执行过程占用的内存空间的大小。
与时间复杂度的表示方法一样，空间复杂度也采用大O记法表示。算法空间复杂度的估算方法是：
- 如果算法中额外申请的内存空间不受用户输入值的影响（是一个固定值），那么该算法的空间复杂度用O(1)表示；
- 如果随着输入值n的增大，算法申请的存储空间成线性增长，则程序的空间复杂度用O(n)表示;
- 如果随着输入值n的增大，程序申请的存储空间成n^2关系增长，则程序的空间复杂度用O(n^2)表示；
- 如果随着输入值n的增大，程序申请的存储空间成n^3关系增长，则程序的空间复杂度用O(n^3)表示；
多数场景中，挑选"好"算法往往更注重的是时间复杂度，空间复杂度只要处于一个合理的范围即可。

 
