#include <stdio.h>
#include <stdlib.h>

// 线性表，数据结构中最简单的一种存储结构，专门用于存储逻辑关系为"一对一"的数据。
// 线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。
// 使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全部都是整形，要么全部都是字符串。
// 一半是整形，另一半是字符串的一组数据无法使用线性表存储。

// 线性表，基于数据在实际物理空间中的存储状态，又可细分为顺序表（顺序存储结构）和链表（链式存储结构）。
//  将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；
//  数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；

// 对于具有“一对一”逻辑关系的数据，一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：
//  某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
//  某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；

// 顺序表，全名顺序存储结构，是线性表的一种。
// 顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。
// 使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下2项数据：
//  顺序表申请的存储容量；
//  顺序表的长度，也就是表中存储数据元素的个数；
typedef struct Table {
  int* head;  // 声明了一个名为head的长度不确定的数组，也叫“动态数组”
  int length;  // 记录当前顺序表的长度
  int size;    // 记录顺序表分配的存储容量
} table;

// 顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：
//  给head动态数据申请足够大小的物理空间；
//  给size和length赋初值；
#define Size 5  // 对Size进行宏定义，表示顺序表申请空间的大小
table initTable() {
  table t;
  // 构造一个空的顺序表，动态申请存储空间
  t.head = (int*)malloc(Size * sizeof(int));
  if (!t.head) {  // 如果申请失败，作出提示并直接退出程序
    printf("初始化失败");
    exit(0);
  }
  t.length = 0;   // 空表的长度初始化为0
  t.size = Size;  // 空表的初始存储空间为Size
  return t;
}

// 输出顺序表中元素的函数
void displayTable(table t) {
  for (int i = 0; i < t.length; i++) {
    printf("%d ", t.head[i]);
  }
  printf("\n");
}

// 顺序表插入元素
// 向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下3种情况：
//  插入到顺序表的表头；
//  在表的中间位置插入元素；
//  尾随顺序表中已有元素，作为顺序表中的最后一个元素；
// 虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：
//  将要插入位置元素以及后续的元素整体向后移动一个位置；
//  将元素放到腾出来的位置上；
// 插入函数，其中，elem为插入的元素，add为插入到顺序表的位置
table addTable(table t, int elem, int add) {
  // 判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）
  if (add > t.length + 1 || add < 1) {
    printf("插入位置有问题\n");
    return t;
  }
  // 做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请
  if (t.length == t.size) {
    t.head = (int*)realloc(t.head, (t.size + 1) * sizeof(int));
    if (!t.head) {
      printf("存储分配失败\n");
      return t;
    }
    t.size += 1;
  }
  // 插入操作，需要将从插入位置开始的后续元素，逐个后移
  for (int i = t.length - 1; i >= add - 1; i--) {
    t.head[i + 1] = t.head[i];
  }
  // 后移完成后，直接将所需插入元素，添加到顺序表的相应位置
  t.head[add - 1] = elem;
  // 由于添加了元素，所以长度+1
  t.length++;
  return t;
}

// 顺序表删除元素
// 从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移1个位置即可。
table delTable(table t, int add) {
  if (add > t.length || add < 1) {
    printf("被删除元素的位置有误\n");
    return t;
  }
  //删除操作
  for (int i = add; i < t.length; i++) {
    t.head[i - 1] = t.head[i];
  }
  t.length--;
  return t;
}

// 顺序表查找元素
// 顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。
// 查找函数（顺序查找算法），其中，elem表示要查找的数据元素的值
int selectTable(table t, int elem) {
  for (int i = 0; i < t.length; i++) {
    if (t.head[i] == elem) {
      return i + 1;
    }
  }
  return -1;  // 如果查找失败，返回-1
}

// 顺序表更改元素
// 顺序表更改元素的实现过程是：
//  找到目标元素；
//  直接修改该元素的值；
// 更改函数，其中，elem为要更改的元素，newElem为新的数据元素
table amendTable(table t, int elem, int newElem) {
  int add = selectTable(t, elem);
  t.head[add - 1] =
      newElem;  // 由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标
  return t;
}

int main() {
  table t1 = initTable();
  for (int i = 1; i <= Size; i++) {
    t1.head[i - 1] = i;
    t1.length++;
  }
  printf("原顺序表：\n");
  displayTable(t1);  // 1 2 3 4 5

  printf("删除元素1:\n");
  t1 = delTable(t1, 1);
  displayTable(t1);  // 2 3 4 5

  printf("在第2的位置插入元素5:\n");
  t1 = addTable(t1, 5, 2);
  displayTable(t1);  // 2 5 3 4 5

  printf("查找元素3的位置:\n");
  int add = selectTable(t1, 3);
  printf("%d\n", add);  // 3

  printf("将元素3改为6:\n");
  t1 = amendTable(t1, 3, 6);
  displayTable(t1);  // 2 5 6 4 5

  return 0;
}

// 顺序表和链表由于存储结构上的差异，导致它们具有不同的特点，适用于不同的场景。
// 顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙。
// 链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持。
// 顺序表和链表有以下几种不同：
// 1 开辟空间的方式
//   顺序表存储数据实行的是"一次开辟，永久使用"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。
//   而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。
//   因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。
// 2 空间利用率
//   从空间利用率的角度上看，顺序表的空间利用率显然要比链表高。
//   链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的。这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。
//   不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。
// 3 时间复杂度，解决不同类型的问题，顺序表和链表对应的时间复杂度也不同。
//   根据顺序表和链表在存储结构上的差异，问题类型主要分为以下2类：
//    问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；
//    问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；
//    第1类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为O(1)；
//    而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为O(n);
//    第2类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，
//    因此链表中插入、删除或移动数据所耗费的时间复杂度为O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为O(n);
// 综上所述，不同类型的场景，选择合适的存储结构会使解决问题效率成倍数地提高。

// 存储结构和存取结构，完全不是一码事！
// 所谓存储结构，指的是数据在内存中真实的存储状态，具体可分为2类，即顺序存储结构和链式存储结构。
// 而存取结构，指的是存取数据的方式，具体也可以分为2类，分别为顺序存取结构和随机存取结构。
// 线性表的顺序存储结构是随机存取结构，而不是顺序存取结构；线性表的链式存储结构，又可以称为顺序存取结构，而不是随机存取结构。
// 顺序存储结构最大的特点是，我们可以随机存或者取数据。
// 总之，线性表的顺序存储结构，又可以称为随机存取结构；而线性表的链式存储结构（栈和队列），又可以称为顺序存取结构。