// 包声明：在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其
// 它包导入时默认的标识符(也称为包名)。
package main

// 导入声明:可以在一个Go语言源文件包声明语句之后,其它非导入声明语句之前,包含零到多个导入包
// 声明语句。每个导入声明可以单独指定一个导入路径,也可以通过圆括号同时导入多个导入
// 路径。下面两个导入形式是等价的,但是第二种形式更为常见。
// import "fmt"
// import "os"
// import (
// 	"fmt"
// 	"os"
// )
// 导入的包之间可以通过添加空行来分组;通常将来自不同组织的包独自分组。包的导入顺序
// 无关紧要,但是在每个分组中一般会根据字符串顺序排列。(gofmt和goimports工具都可以将
// 不同分组导入的包独立排序。)

// 如果我们想同时导入两个有着名字相同的包,例如math/rand包和crypto/rand包,那么导入声
// 明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。
// import (
// 	"crypto/rand"
// 	mrand "math/rand" // alternative name mrand avoids conflict
// )
// 导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包,可以用导入包原
// 本默认的名字或重命名为另一个完全不同的名字。
// 导入包重命名是一个有用的特性,它不仅仅只是为了解决名字冲突。如果导入的一个包名很
// 笨重,特别是在一些自动生成的代码中,这时候用一个简短名称会更方便。选择用简短名称
// 重命名导入包时候最好统一,以避免包名混乱。选择另一个包名称还可以帮助避免和本地普
// 通变量名产生冲突。

// 每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的
// 情况,Go语言的构建工具将报告错误。

// 包的匿名导入:
// 如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利
// 用导入包而产生的副作用:它会计算包级变量的初始化表达式和执行导入包的init初始化函数。
// 这时候我们需要抑制“unused import”编译错误,我们可以用下划线_来重命名导入的包。
// 像往常一样,下划线_为空白标识符,并不能被访问。
import (
	"fmt"
	_ "image/png" // register PNG decoder
	"runtime"
)

// 通常是用来实现一个编译时机制,然后通过在main主程序入口选择性地导入附加的包。

// Go语言有超过100个的标准包(可以用go list std | wc -l	命令查看标准包的具体数
// 目),标准库为大多数的程序提供了必要的基础构件。

// Go还自带了工具箱,里面有很多用来简化工作区和包管理的小工具。

// 每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关
// 联到一个特定的包,让我们给类型、函数等选择简短明了的名字,这样可以在使用它们的时
// 候减少和其它部分名字的冲突。
// 每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性
// 并隐藏包API的具体实现,将允许包的维护者在不影响外部包用户的前提下调整包的内部实
// 现。通过限制包内变量的可见性,还可以强制用户通过某些特定函数来访问和更新内部变
// 量,这样可以保证内部变量的一致性和并发时的互斥约束。

// 当修改了一个源文件,必须重新编译该源文件对应的包和所有依赖该包的其他包。
// 即使是从头构建,Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编
// 译速度主要得益于三个语言特性。第一点,所有导入的包必须在每个文件的开头显式声明,
// 这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点,禁止包的
// 环状依赖,因为没有循环依赖,包的依赖关系形成一个有向无环图,每个包可以被独立编
// 译,而且很可能是被并发编译。第三点,编译后包的目标文件不仅仅记录包本身的导出信
// 息,目标文件同时还记录了包的依赖关系。因此,在编译一个包的时候,编译器只需要读取
// 每个直接导入包的目标文件,而不需要遍历所有依赖的的文件(很多都是重复的间接依赖)。

// 每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。
// Go语言的规范并没有指明包的导入路径字符串的具体含义,导入路径的具体含义是由构建工具来解释的。

// 如果你计划分享或发布包,那么导入路径最好是全球唯一的。为了避免冲突,所有非标准库
// 包的导入路径建议以所在组织的互联网域名为前缀;而且这样也有利于包的检索。

// 通常来说,默认的包名就是包导入路径名的最后一段,因此即使两个包的导入路径不同,它
// 们依然可能有一个相同的包名。例如,math/rand包和crypto/rand包的包名都是rand。
// 关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外,包对
// 应一个可执行程序,也就是main包,这时候main包本身的导入路径是无关紧要的。名字为
// main的包是给go build构建命令一个信息,这个包编译完之后必须调用连接器生成一个可执行程序。
// 第二个例外,包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件(前
// 面必须有其它的字符,因为以_或.开头的源文件会被构建工具忽略),并且这些源文件声
// 明的包名也是以_test为后缀名的。这种目录可以包含两种包:一种是普通包,另一种则是
// 测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译,
// 普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖
// 第三个例外,一些依赖版本号的管理工具会在导入路径后追加版本号信息,例
// 如"gopkg.in/yaml.v2"。这种情况下包的名字并不包含版本号后缀,而是yaml。

// 当创建一个包,一般要用短小的包名,但也不能太短导致难以理解。标准库中最常用的包有
// bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。

// 包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式,这是为了避免
// 和预定义的类型冲突,同样还有go/types是为了避免和type关键字冲突。

// Go语言工具箱的具体功能,包括如何下载、格式化、构建、测试和安装Go语言编写的程序。
// Go语言的工具箱集合了一系列的功能的命令集。它可以看作是一个包管理器(类似于Linux中
// 的apt和rpm工具),用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任
// 务。它也是一个构建系统,计算文件的依赖关系,然后调用编译器、汇编器和链接器构建程
// 序,虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的
// 驱动程序。
// Go语言工具箱的命令有着类似“瑞士军刀”的风格,带着一打子的子命令,有一些我们经常用
// 到,例如get、run、build和fmt等。你可以运行go或go	help命令查看内置的帮助文档:
//         go <command> [arguments]
// The commands are:
//         bug         start a bug report
//         build       compile packages and dependencies
//         clean       remove object files and cached files
//         doc         show documentation for package or symbol
//         env         print Go environment information
//         fix         update packages to use new APIs
//         fmt         gofmt (reformat) package sources
//         generate    generate Go files by processing source
//         get         add dependencies to current module and install them
//         install     compile and install packages and dependencies
//         list        list packages or modules
//         mod         module maintenance
//         run         compile and run Go program
//         test        test packages
//         tool        run specified go tool
//         version     print Go version
//         vet         report likely mistakes in packages

// 为了达到零配置的设计目标,Go语言的工具箱很多地方都依赖各种约定。例如,根据给定的
// 源文件的名称,Go语言的工具可以找到源文件对应的包,因为每个目录只包含了单一的包,
// 并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径,Go语言的工具可
// 以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码仓库的远程
// 服务器的URL。

// 对于大多数的Go语言用户,只需要配置一个名叫GOPATH的环境变量,用来指定当前工作目
// 录即可。当需要切换到不同工作区的时候,只要更新GOPATH就可以了。

// GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在
// 与$GOPATH/src的相对路径为包导入路径的子目录中,例如gopl.io/ch1/helloworld相对应的路
// 径目录。一个GOPATH工作区的src目录中可能有多个独立的版本控制系统,例如
// gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文
// 件,bin子目录用于保存编译后的可执行程序,例如helloworld可执行程序。
// 第二个环境变量GOROOT用来指定Go的安装目录,还有它自带的标准库包的位置。
// GOROOT的目录结构和GOPATH类似,因此存放fmt包的源代码对应目录应该为
// $GOROOT/src/fmt。用户一般不需要设置GOROOT,默认情况下Go语言安装工具会将其设
// 置为安装的目录路径。

// go env命令用于查看Go语言工具涉及的所有环境变量的值,包括未设置环境变量的默认
// 值。GOOS环境变量用于指定目标操作系统(例如android、linux、darwin或windows),
// GOARCH环境变量用于指定处理器的类型,例如amd64、386或arm等。

// 下载包:
// 使用命令go get 可以下载一个单一的包或者用...下载整个子目录里面的每个包。Go语言
// 工具箱的go命令同时计算并下载所依赖的每个包。
// go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad,可以直接向它们的版
// 本控制系统请求代码。对于其它的网站,你可能需要指定版本控制系统的具体路径和协议,
// 例如Git或Mercurial。运行go help importpath获取相关的信息。
// go get命令获取的代码是真实的本地存储仓库,而不仅仅只是复制源文件,因此你依然可以
// 使用版本管理工具比较本地代码的变更或者切换到其它的版本。
// 如果指定-u命令行标志参数,go	get命令将确保所有的包和依赖的包的版本都是最新的,
// 然后重新编译和安装它们。如果不包含该标志参数的话,而且如果包已经在本地存在,那么
// 代码将不会被自动更新。

// 构建包:
// go build命令编译命令行参数指定的每个包。如果包是一个库,则忽略输出结果;这可以用
// 于检测包是可以正确编译的。如果包的名字是main, go build将调用链接器在当前目录创建
// 一个可执行程序;以导入路径的最后一段作为可执行程序的名字。
// 由于每个目录只包含一个包,因此每个对应可执行程序或者叫Unix术语中的命令的包,会要
// 求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面。
// 每个包可以由它们的导入路径指定,或者用一个相对目录的路径名指定,相对路径必须以.或..开头。
// 如果没有指定参数,那么默认指定为当前目录对应的包。下面的命令用于构建同一个包:
// $ cd $GOPATH/src/gopl.io/ch1/helloworld
// $ go build
// 或者:
// $ cd anywhere
// $ go build gopl.io/ch1/helloworld
// 或者:
// $ cd $GOPATH
// $ go build ./src/gopl.io/ch1/helloworld
// 也可以指定包的源文件列表,这一般只用于构建一些小程序或做一些临时性的实验。如果是
// main包,将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。
// go run命令实际上是结合了构建和运行的两个步骤。
// 默认情况下, go build命令构建指定的包和它依赖的包,然后丢弃除了最后的可执行文件之
// 外所有的中间编译结果。依赖分析和编译过程虽然都是很快的,但是随着项目增加到几十个
// 包和成千上万行代码,依赖关系分析和编译时间的消耗将变的可观,有时候可能需要几秒
// 种,即使这些依赖项没有改变。
// go install命令和go build命令很相似,但是它会保存每个包的编译成果,而不是将它们都
// 丢弃。被编译的包会被保存到$GOPATH/pkg目录下,目录路径和src目录路径对应,可执行
// 程序被保存到$GOPATH/bin目录。(很多用户会将$GOPATH/bin添加到可执行程序的搜索列
// 表中。)还有, go install命令和go build命令都不会重新编译没有发生变化的包,这可以
// 使后续构建更快捷。为了方便编译依赖的包, go build -i命令将安装每个目标所依赖的包。
// 因为编译对应不同的操作系统平台和CPU架构, go install命令会将编译结果安装到GOOS和GOARCH对应的目录。
// 针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH,然后运行构建命令即可。
// 有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件,以便于处理底层的可
// 移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型
// 名字,例如net_linux.go或asm_amd64.s,Go语言的构建工具将只在对应的平台编译这些文
// 件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如,文件中可能包含下
// 面的注释:
//	+build linux darwin
// 在包声明和包注释的前面,该构建注释参数告诉go build只在编译程序对应的目标操作系统
// 是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件:
//	+build ignore
// 更多细节,可以参考go/build包的构建约束部分的文档:
// $go doc go/build

// 包文档:
// Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包
// 含目的和用法说明的注释。
// Go语言中的文档注释一般是完整的句子,第一行通常是摘要说明,以被注释者的名字开头。
// 注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。
// 如果注释后仅跟着包声明语句,那注释对应整个包的文档。包文档对应的注释只能有一个(其实可以
// 有多个,它们会组合成一个包文档注释),包注释可以出现在任何一个源文件中。如果包的注释内容
// 比较长,一般会放到一个独立的源文件中;fmt包注释就有300行之多。这个专门用于保存包文档的
// 源文件通常叫doc.go。
// go doc命令,该命令打印其后所指定的实体的声明与文档注释,该实体可能是一个包:
// go doc time
// 或者是某个具体的包成员:
// go doc time.Since
// 或者是一个方法:
// go doc time.Duration.Seconds
// 该命令并不需要输入完整的包导入路径或正确的大小写。
// godoc提供可以相互交叉引用的HTML页面,但是包含和go doc命令相同以及更多的信息。
// -analysis=type和-analysis=pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。
// Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包,
// 一个internal包只能被和internal目录有同一个父目录的包所导入。

// 查询包:
// go list命令可以查询可用包的信息。其最简单的形式,可以测试包是否在工作区并打印它的导入路径。
// go list命令的参数还可以用"..."表示匹配任意的包的导入路径。可以用它来列出工作区中的所有包:
// go list ...
// 或者是特定子目录下的所有包:
// go list github.com/astaxie/beego/...
// go list命令还可以获取每个包完整的元信息,而不仅仅只是导入路径,这些元信息可以以
// 不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。
// go list -json fmt
// 命令行参数-f则允许用户使用text/template包的模板语言定义输出文本的格式。下
// 面的命令将打印strconv包的依赖的包,然后用join模板函数将结果链接为一行,连接时每个结
// 果之间用一个空格分隔:
// go list -f "{{join .Deps \" \"}}" strconv
// errors internal/bytealg internal/cpu internal/reflectlite math math/bits runtime
// runtime/internal/atomic runtime/internal/math runtime/internal/sys unicode/utf8 unsafe
// go list -f '{{.ImportPath}} -> {{join .Imports "	"}}' compress/...
// compress/bzip2 -> bufioiosort
// compress/flate -> bufiofmtiomathmath/bitssortstrconvsync
// compress/gzip -> bufiocompress/flateencoding/binaryerrorsfmthash/crc32iotime
// compress/lzw -> bufioerrorsfmtio
// compress/zlib -> bufiocompress/flateencoding/binaryerrorsfmthashhash/adler32io
// go list命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。

func main() {
	fmt.Println(runtime.GOOS, runtime.GOARCH) // linux amd64
}
