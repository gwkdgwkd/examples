#include <iostream>

// 19.10 在标准库中的情况

// 在C++11中，类型萃取变成了C++标准库中固有的一部分。
// 它们或多或少的构成了在本章中讨论的所有的类型函数和类型萃取。
// 但是，对于它们中的一部分，比如个别的操作探测，以及有过讨论的std::is_union，
// 目前都还没有已知的语言解决方案，而是由编译器为这些萃取提供了支持。
// 编译器也开始支持一些已经由语言本身提供了解决方案的萃取，主要是为了减少编译时间。

// 因此，如果需要类型萃取，建议在可能的情况下都尽量使用由C++标准库提供的萃取。

// 需要注意的是，某些萃取的行为可能会让人很意外，至少对于新手程序员。

// C++标准库也定义了一些策略和属性萃取：
// 1.类模板std::char_traits被std::string和I/O stream当作策略萃取使用；
// 2.为了将算法简单的适配于标准迭代器的种类，
//   标准库提供了一个很简单的std::iterator_traits属性萃取模板；
// 3.模板std::numeric_limits作为属性萃取模板也会很有帮助；
// 4.为标准库容器类型进行的内存分配是由策略萃取类处理的，见std::shared_ptr实现，
//   从C++98开始，标准库专门为了这一目的提供了std::allocator模板，
//   从C++11开始，标准库引入了std::allocator_traits模板，
//   这样就能够修改内存分配器的策略或者行为了。

int main() { return 0; }