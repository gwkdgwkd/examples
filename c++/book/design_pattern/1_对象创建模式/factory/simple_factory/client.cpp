#include <iostream>

#include "product_factory.h"

// 定义一个工厂类，根据不同的参数创建并返回不同的类对象，
// 被创建的对象所属的类一般都具有相同的父类，调用者无需关心产品的具体细节，
// 实现了创建产品的代码（工厂类），与具体的产品类解耦合的效果。

// 简单工厂并不属于GOF的23设计模式之一，
// 不过在实际应用中因为其简单方便理解所以也经常使用。

// 简单工厂模式的结构组成：
// 1.工厂类，工厂模式的核心类，是一个具体的类，非接口抽象类，
//   有一个重要的create()方法，利用if或者switch创建产品并返回，
//   create()方法通常是静态的，所以也称之为静态工厂；
// 2.抽象产品类，是具体产品类的继承的父类或实现的接口；
// 3.具体产品类，工厂类所创建的对象就是此具体产品实例。

// 优点：
// 1.将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的使用分离；
// 2.提供专门的工厂类用于创建对象，客户端无需知道所创建的产品类的类名，
//   只需要知道对应产品类的参数即可创建对象实例。

// 缺点：
// 1.工厂类职责过重，扩展性非常差，如果增加新产品，需要修改工厂类的判断逻辑，
//   类型多时，不易维护，违背了六大设计原则之中的开闭原则；
// 2.不支持不同的产品需要不同额外参数的情况。

// 简单工厂模式的适用场景：
// 1.工厂类负责创建的对象比较少；
// 2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 1]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';

  // 新增的产品C：调用者不用修改
  Product* p;
  ProductFactory* pf = new ProductFactory();
  p = pf->createProduct(type);
  delete pf;

  if (p) {
    p->show();
    delete p;
  }

  return 0;
}