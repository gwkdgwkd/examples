#include <stdio.h>

// 强符号和弱符号
// 在编写代码的过程中经常会遇到一种叫做符号重复定义的错误，
// 这是因为在多个源文件中定义了名字相同的全局变量，并且都将它们初始化了。
// 在C中，编译器默认函数和初始化了的全局变量为强符号（Strong Symbol），
// 未初始化的全局变量为弱符号（Weak Symbol）。
// 强符号之所以强，是因为它们拥有确切的数据，变量有值，函数有函数体；
// 弱符号之所以弱，是因为它们还未被初始化，没有确切的数据。
// 链接器会按照如下的规则处理被多次定义的强符号和弱符号：
// 1.不允许强符号被多次定义，也即不同的目标文件中不能有同名的强符号；
//   如果有多个强符号，那么链接器会报符号重复定义错误。
// 2.如果一个符号在某个目标文件中是强符号，
//   在其他文件中是弱符号，那么选择强符号。
// 3.如果一个符号在所有的目标文件中都是弱符号，
//   那么选择其中占用空间最大的一个。
//   比如目标文件a.o定义全局变量global为int类型，占用4个字节，
//   目标文件b.o定义global为double类型，占用8个字节，
//   那么被链接后，符号global占用8个字节。
// 请尽量不要使用多个不同类型的弱符号，否则有时候很难发现程序错误。
// 在GCC中，可以通过__attribute__((weak))，
// 来强制定义任何一个符号为弱符号。
// __attribute__((weak))只对链接器有效，对编译器不起作用，
// 编译器不区分强符号和弱符号，只要在一个源文件中定义两个相同的符号，
// 不管它们是强是弱，都会报重复定义错误。
// 弱符号对于库来说十分有用，在开发库时，可以将某些符号定义为弱符号，
// 这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，
// 增加了很大的灵活性：
__attribute__((weak)) int a = 20;
// int a = 30;  // redefinition of ‘a’
__attribute__((weak)) void func() { printf("C Language\n"); }

// 强引用和弱引用
// 所谓引用（Reference），是指对符号的使用。
// int a = 100, b = 200, c;  // 符号定义
// c = a + b;  // 符号引用
// 如果没有符号定义，链接器就会报符号未定义错误，
// 这种被称为强引用（Strong Reference）。
// 与之相对应的还有一种弱引用（Weak Reference），
// 如果符号有定义，就使用它对应的地址，如果没有定义，也不报错。
// 链接器处理强引用和弱引用的过程几乎是一样的，
// 只是对于未定义的弱引用，链接器不认为它是一个错误，
// 一般默认其为0（地址为0），或者是一个特殊的值，以便程序代码能够识别。
// 在变量声明或函数声明的前面加上__attribute__((weak))，
// 就会使符号变为弱引用：
__attribute__((weak)) extern int b;
__attribute__((weak)) extern void func1();  // 也可以不写extern
// 弱引用和强引用非常利于程序的模块化开发，可以将程序的扩展模块定义为弱引用，
// 当我们将扩展模块和程序链接在一起时，程序就可以正常使用；
// 如果去掉了某些模块，那么程序也可以正常链接，
// 只是缺少了某些功能，这使得程序的功能更加容易裁剪和组合。

int main() {
  printf("a = %d\n", a);
  func();
  // a = 9999
  // c.biancheng.net

  // 在main.c中，a和func都是弱符号，
  // 在module.c中，a和func都是强符号，
  // 强符号会覆盖弱符号，所以链接器最终会使用module.c中的符号。

  // 可以将它编译成一个可执行文件，GCC并不会报链接错误。
  // 但是当程序运行时，会发生段错误（Segment Fault），
  // 这是因为符号a和func的地址都为0，这个地址是禁止访问的。
  // printf("&a: %d, func: %d\n", &b, func1);  // &a: 0, func: 0
  // printf("a = %d\n", b);
  // func1();
  // 改进的方案：
  if (&b) {
    printf("a = %d\n", b);
  } else {
    printf("a is undefined!\n");
  }
  if (func1) {
    func1();
  } else {
    printf("func() is undefined!\n");
  }
  // 代码中需要判断的是地址，不是值，所以变量a前面需要加&；
  // 而函数名本身就表示地址，所以func前边不需要&。

  return 0;
}