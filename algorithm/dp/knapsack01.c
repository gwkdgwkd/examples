#include <stdio.h>

// 根据限定的条件不同，背包问题还可以细分：
//   部分背包问题：所有物品是可再分的，即允许将某件物品的一部分（例如1/3）放入背包；
//   0-1背包问题：所有物品不可再分，要么整个装入背包，要么放弃，不允许出现“仅选择物品的1/3装入背包”的情况；
//   完全背包问题：不对每一件物品的数量做限制，同一件物品可以选择多个装入背包；
//   多重背包问题：每件物品的数量是有严格规定的，比如物品A有2件，物品B有3件。

// 动态规划算法解决此问题的核心思想是：
// 背包承重1斤时所能获得的最大收益是很容易计算的，在此基础上，可以推算出背包承重2斤、3斤、...、14斤、15斤时所能获得的最大收益。

#define N 5   // 商品的种类
#define W 11  // 背包的最大承重

// 动态规划算法解决01背包问题
// result[N + 1][W + 1]：存储最终的结果
// w[N + 1]：存储各商品的重量
// v[N + 1]：存储各商品的价值
void knapsack01(int result[N + 1][W + 1], int w[N + 1], int v[N + 1]) {
  int i, j;
  // 逐个遍历每个商品
  for (i = 1; i <= N; i++) {
    // 求出从1到W各个载重对应的最大收益
    for (j = 1; j <= W; j++) {
      // 如果背包载重小于商品总重量，则该商品无法放入背包，收益不变
      if (j < w[i])
        result[i][j] = result[i - 1][j];
      else
        // 比较装入该商品和不装该商品，哪种情况获得的收益更大，记录最大收益值
        result[i][j] = result[i - 1][j] > (v[i] + result[i - 1][j - w[i]])
                           ? result[i - 1][j]
                           : (v[i] + result[i - 1][j - w[i]]);
    }
  }
}
// 追溯选中的商品
void select(int result[N + 1][W + 1], int w[N + 1], int v[N + 1]) {
  int n = N;
  int bagw = W;
  // 逐个商品进行判断
  while (n > 0) {
    // 如果在指定载重量下，该商品对应的收益和上一个商品对应的收益相同，则表明未选中
    if (result[n][bagw] == result[n - 1][bagw]) {
      n--;
    } else {
      // 输出被选用商品的重量和价值
      printf("(%d,%d) ", w[n], v[n]);
      // 删除被选用商品的承重，以便继续遍历
      bagw = bagw - w[n];
      n--;
    }
  }
}
int main() {
  int w[N + 1] = {0, 1, 2, 5, 6, 7};     // 商品的承重
  int v[N + 1] = {0, 1, 6, 18, 22, 28};  // 商品的价值
  int result[N + 1][W + 1] = {0};        // 记录统计数据
  knapsack01(result, w, v);
  printf("背包承重为%d,最大收益为%d\n", W, result[N][W]);
  printf("选择了：");
  select(result, w, v);
  printf("\n");

  // 背包承重为11,最大收益为40
  // 选择了：(6,22) (5,18)

  return 0;
}
