#include <iostream>

// C++读作C加加，是C Plus Plus的简称。
// C语言是C++的一部分，C语言代码几乎不用修改就能够以C++的方式编译。
// 可以明确地说，学了C语言就相当于学了C++的一半，从C语言转向C++时，
// 不需要再从头开始，接着C语言往下学就可以，所以强烈建议先学C语言再学C++。

// C++和C语言虽然是两门独立的语言，但是它们却有着扯也扯不清的关系。
// 早期并没有C++这个名字，而是叫做带类的C，作为C语言的扩展和补充出现的，
// 它增加了很多新的语法，目的是提高开发效率。
// 随着C++的流行，它的语法也越来越强大，已经能够很完善的支持面向过程编程、
// 面向对象编程（OOP）和泛型编程，几乎成了一门独立的语言，拥有了自己的编译方式。

// 很难说C++拥有独立的编译器，例如Windows下的微软编译器（cl.exe）、
// Linux下的GCC、Mac下的Clang（Xcode默认编译器，雄心勃勃，立志超越GCC），
// 它们都同时支持C语言和C++，统称为C/C++编译器。
// 对于C语言代码，它们按照C语言的方式来编译，对于C++代码，就按照C++的方式编译。
// C、C++代码使用同一个编译器来编译，所以说后期的C++拥有了自己的编译方式，
// 而没有说C++拥有了独立的编译器。
// 从学院派的角度来说，C++支持面向过程编程、面向对象编程和泛型编程，
// 而C语言仅支持面向过程编程，就面向过程编程而言，C++和C几乎是一样的。

// C++是一门面向对象的编程语言，理解C++，首先要理解类和对象这两个概念。
// C++中的类（Class）可以看做C语言中结构体（Struct）的升级版。
// 结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；
// 可以通过结构体来定义结构体变量，每个变量拥有相同的性质。
// C++的类也是构造类型，但进行了扩展，类的成员不但可以是变量，还可以是函数；
// 通过类定义出来的变量也有特定的称呼，叫做对象。
// C的struct只能包含变量，而C++中的class除了可以包含变量，还可以包含函数。
// 结构体和类都可以看做一种由用户自己定义的复杂数据类型，
// 在C语言中可以通过结构体名来定义变量，在C++中可以通过类名来定义变量。
// 不同的是，通过结构体定义出来的变量还是叫变量，
// 而通过类定义出来的变量有了新的名称，叫做对象（Object）。
// 在C++中，通过类名创建对象这个过程叫做类的实例化，因此也称对象是类的一个实例。
// 类的成员变量称为属性（Property），将类的成员函数称为方法（Method）。

// 类是一个通用的概念，C++、Java、C#、PHP等都支持类，都可以通过类创建对象。
// 可以将类看做是结构体的升级版，C的晚辈们看到了C语言的不足，尝试加以改善，
// 继承了结构体的思想，并进行了升级，开发或扩展大中型项目时更加容易。
// 因为C++、Java、C#、PHP等语言都支持类和对象，
// 所以使用这些语言编程也被称为面向对象编程，这些语言也被称为面向对语言。
// C语言因为不支持类和对象的概念，被称为面向过程的编程语言。
// 在C语言中，会把重复使用或具有某项功能的代码封装成一个函数，
// 将拥有相关功能的多个函数放在一个源文件，再提供一个头文件，这就是一个模块。
// 使用模块时，引入对应的头文件就可以，而在C++中，多了一层封装，就是类。
// 类由相关联的函数、变量组成，可以将一个或多个类放在一个源文件，使用时引入类就可以。
// 不要小看类（Class）这一层封装，它有很多特性，
// 极大地方便了中大型程序的开发，它让C++成为面向对象的语言。
// 面向对象编程在代码执行效率上绝对没有任何优势，
// 它的主要目的是方便组织和管理代码，快速梳理编程思路，带来编程思想上的革新。
// 面向对象编程是针对开发中大规模的程序而提出来的，目的是提高软件开发的效率。
// 不要把面向对象和面向过程对立起来，它们不是矛盾的，而是各有用途、互为补充的。
// 如果希望开发一个贪吃蛇游戏，类和对象或许是多余的，几个函数就可以搞定；
// 但如果开发一款大型游戏，那绝对离不开面向对象。

// C++和C语言类似，也要经过编译和链接后才能运行。
// VS、Dev C++、VC 6.0、Code::Blocks、C-Free、GCC、Xcode等IDE或编译器，
// 它们可以运行C程序和C++程序。
// C/C++代码生成可执行文件的过程：
// 源代码->编译器->目标代码->链接器（启动代码、库代码）->可执行程序
// C语言源文件的后缀非常统一，在不同的编译器下都是.c。
// C++源文件的后缀则有些混乱，不同的编译器支持不同的后缀：
//  Microsoft Visual C++：cpp、cxx、cc
//  GCC（GNU C++）：cpp、cxx、cc、c++、C
//  Borland C++：cpp
//  UNIX：C、cc、cxx
// 推荐使用.cpp作为C++源文件的后缀，这样更加通用和规范。
// 在C语言中，使用gcc命令来编译和链接C程序：
//  gcc main.c
//  gcc main.c module.c
// 编译C++程序时，gcc命令也可以使用，不过要增加-lstdc++，否则会链接错误。
//  gcc main.cpp -lstdc++
//  gcc main.cpp module.cpp -lstdc++
// gcc命令在链接时默认使用C的库，只有添加了-lstdc++选项才会使用C++的库。
// GCC中还有一个g++命令，它专门用来编译C++程序，和gcc命令的用法如出一辙：
//  g++ main.cpp
//  g++ main.cpp module.cpp
//  g++ main.cpp -o demo  // 使用-o选项可以指定可执行文件的名称
// GCC是由GUN组织开发的，最初只支持C语言，是一个单纯的C语言编译器，
// 后来GNU组织倾注了更多的精力，使得GCC越发强大，
// 增加了对C++、Objective-C、Fortran、Java等其他语言的支持，
// 此时的GCC就成了一个编译器套件（套装），是所有编译器的总称。
// 在这个过程中，gcc命令也做了相应地调整，它不再仅仅支持C语言，
// 而是默认支持C语言，增加参数后也可以支持其他的语言。
// gcc是一个通用命令，它会根据不同的参数调用不同的编译器或链接器。
// 但是让用户指定参数是一种不明智的行为，不但增加了学习成本，
// 还使得操作更加复杂，所以后来GCC又针对不同的语言推出了不同的命令，
// g++编译C++，gcj编译Java，gccgo编译Go语言。
// 在以后使用Linux GCC时，推荐使用g++命令来编译C++程序，这样更加简洁和规范。

// C++不但在C语言的基础上进行了很多扩展，
// 而且也对C语言部分做了细节上的改进，变量的定义位置就是其中之一。
// C89规定所有局部变量都必须定义在函数开头，之前不能有其他的执行语句。
// C99标准取消这这条限制，但VC/VS对C99的支持很不积极，仍然这样要求。
// 取消限制带来的另外一个好处是，可以在for循环的控制语句中定义变量。
// 在for内部定义循环控制变量i，会让代码看起来更加紧凑，
// 使i的作用域被限制在整个for循环语句内部，减小了命名冲突的概率。

// 在C语言中，关系运算和逻辑运算的结果有两种，真和假：0表示假，非0表示真。
// C语言并没有彻底从语法上支持真和假，只是用0和非0来代表。
// 这点在C++中得到了改善，C++新增了bool类型，它一般占用1个字节长度。
// bool类型只有两个取值，true和false：true表示真，false表示假。
// bool是类型名字，也是C++中的关键字，它的用法和int、char、long是一样的。
// 遗憾的是，在C++中使用cout输出bool值时还是用1和0表示，而不是true或false。
// Java、PHP、JavaScript等也都支持布尔类型，但输出结果为true或false。
// 可以使用true或false显式地对bool变量赋值。
// true和false是C++中的关键字，true表示真，false表示假。

int main() {
  // 将代码保存到源文件main.c，可以用GCC、Xcode编译，但VC/VS会报错。
  // GCC、Xcode对C99的支持非常好，可以在函数的任意位置定义变量；
  // 但VC/VS对C99的支持寥寥无几，必须在函数开头定义好所有变量。
  int a;
  scanf("%d", &a);
  int b;
  scanf("%d", &b);
  int c = a + b;
  printf("%d\n", c);

  return 0;
}