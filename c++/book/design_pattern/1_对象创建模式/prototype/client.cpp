#include "product_a.h"
#include "product_b.h"
#include "product_c.h"

// Prototype 原型模式

// Prototype提供了自我复制的功能，就是说新对象的创建可以通过已有对象进行创建。
// 在C++中拷贝构造函数曾经是很对程序员的噩梦，
// 浅层拷贝和深层拷贝的魔魇也是很多程序员在面试时候的快餐和系统崩溃时候的根源之一。

// 原型模式的使用场景：
// 1.资源优化场景，类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
// 2.性能和安全要求的场景，通过new产生一个对象需要非常烦琐的数据准备或访问权限；
// 3.有的时候，创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，
//   就可以使用原型模式来创建一个新的对象，不必去理会创建的过程；
// 4.当的对象类型不是开始就能确定的，而这个类型是在运行期确定的话，
//   那么通过这个类型的对象克隆出一个新的对象比较容易一些；
// 5.当一个类的实例只能有几个不同状态组合中的一种时，
//   建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些；
// 6.和拷贝构造相比，隐藏了拷贝的细节，把拷贝构造进行了封装。

// 通过实现Cloneable接口的原型模式，在调用clone函数实例时比一定比new操作要块,
// 只有new构造对象非常耗时或者成本较高时，通过clone方法才能得到效率上的提升。

// 优点：
// 原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，
// 特别是要在一个循环体内产生大量的对象时，原型模式可以更好的体现其优点。

// 缺点：
// 它的优点也是缺点，直接在内存汇总拷贝，构造函数是不会执行的，在实际开发中，
// 应该注意这个潜在的问题，需要在实际应用时进行权衡考虑。

// 动机：
// 1.在软件系统中，经常面临着某些结构复杂的对象的创建工作，由于需求的变化，
//   这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口；
// 2.如何应对这种变化？如何向客户程序（使用这些对象的程序）隔离出这些易变对象，
//   从而使得依赖这些易变对象的客户程序不随需求改变而变化？

// 定义：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

// 要点总结：
// 1.Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，
//   它同样要求这些易变类拥有稳定的接口；
// 2.Prototype模式对于如何创建易变类的实体对象采用原型克隆的方法来做，
//   它使得可以非常灵活地动态创建拥有某些稳定接口的新对象，
//   所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone；
// 3.Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。

// Prototype通过复制原型（Prototype）而获得新对象创建的功能，
// 这里Prototype本身就是对象工厂，因为能够生产对象，
// Prototype、Builder和AbstractFactory都通过专门负责创建对象的类工作，区别是：
// 1.Builder模式重在复杂对象的一步步创建，并不直接返回对象；
// 2.AbstractFactory模式重在产生多个相互依赖类的对象；
// 3.Prototype模式重在从自身复制自己创建新类。

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 2]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';

  auto func = [](Product* p) {
    Product* product = p->clone();
    product->show();
    delete product;
  };

  Product* p;
  switch (type) {
    case 0:
      p = new ProductA();
      func(p);  // Product A
      break;
    case 1:
      p = new ProductB();
      func(p);  // Product B
      break;
    case 2:
      p = new ProductC();
      func(p);  // Product C
      break;
    default:
      std::cout << "invalid type" << std::endl;
      return -1;
  }

  delete p;

  return 0;
}