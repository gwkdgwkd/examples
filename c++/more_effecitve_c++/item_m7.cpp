#include <cstring>
#include <iostream>

using namespace std;

// 不要重载“&&”,“||”, 或“,”

// 与C一样，C++使用布尔表达式短路求值法(short-circuit evaluation)。
// if ((p != 0) && (strlen(p) > 10)) 这里不用担心当p为空时strlen无法正确运行，因为如果p不等于0的测试失败，strlen不会被调用。

// C++允许根据用户定义的类型，来定制&&和||操作符。方法是重载函数operator&&和operator||，可以在全局重载或每个类里重载。
// 使用这种方法，你必须知道你正在极大地改变游戏规则。因为你以函数调用法替代了短路求值法。
//  if (expression1 && expression2) 对于编译器来说，等同于下面代码之一：
//  if (expression1.operator&&(expression2))
//  if (operator&&(expression1, expression2))
// 首先当函数被调用时，需要运算其所有参数，所以调用函数functions operator&&和operator||时，两个参数都需要计算，换言之，没有采用短路计算法。
// 第二是C++语言规范没有定义函数参数的计算顺序，所以没有办法知道表达式1与表达式2哪一个先计算。完全可能与具有从左参数到右参数计算顺序的短路计算法相反。
// 因此如果你重载&&或||，就没有办法提供给程序员他们所期望和使用的行为特性，所以不要重载&&和||。

// 逗号操作符用于组成表达式，经常在for循环的更新部分（update part）里遇见它。
void reverse(char s[]) {
  // 在for循环的最后一个部分里，i被增加同时j被减少。在这里使用逗号很方便，因为在最后一个部分里只能使用一个表达式，分开表达式来改变i和j的值是不合法的。
  for (int i = 0, j = strlen(s) - 1; i < j; ++i, --j) {
    int c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}

// 一个包含逗号的表达式首先计算逗号左边的表达式，然后计算逗号右边的表达式；整个表达式的结果是逗号右边表达式的值。
// 重载的逗号表达式无法模仿上面的特性：
//  写一个非成员函数operator，你不能保证左边的表达式先于右边的表达式计算，因为函数（operator）调用时两个表达式做为参数被传递出去。
//  但是你不能控制函数参数的计算顺序。所以非成员函数的方法绝对不行。
//  剩下的只有写成员函数operator的可能性了。
//  即使这里你也不能依靠于逗号左边表达式先被计算的行为特性，因为编译器不一定必须按此方法去计算。
// 因此你不能重载逗号操作符，保证它的行为特性与其被料想的一样。重载它是完全轻率的行为。

// 不能重载下面的操作符：
// . .* :: ?: new delete sizeof typeid static_cast dynamic_cast const_cast reinterpret_cast
// 能重载：
// operator new operator delete operator new[] operator delete[]
// + - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |= << >> >>= <<= == != <= >= && || ++ -- , ->* -> () []

// 当然能重载这些操作符不是去重载的理由。操作符重载的目的是使程序更容易阅读，书写和理解，而不是用你的知识去迷惑其他人。
// 如果你没有一个好理由重载操作符，就不要重载。在遇到&& ||和,时，找到一个好理由是困难的，因为无论你怎么努力，也不能让它们的行为特性与所期望的一样。

int main() { return 0; }