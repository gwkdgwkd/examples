#include <iostream>

// 任何一个C++项目，其内部往往包含的不是单个源文件，而是多个源文件，
// 甚至在很多C++项目中还会利用子文件夹对诸多源文件进行分门别类。
// 简单地理解C++多文件编程，其就是把多个头文件和源文件组合在一起构成程序，
// 这是C++的重点，也是C++的难点，在C++多文件编程中，
// 头文件的编写是重点内容，有很多细节需要注意，有的甚至会让你感觉奇怪。
// 所有的代码都位于main.cpp文件中，对于代码量几十行或者几百行的小程序，
// 这或许无可厚非，但当程序膨胀代码到几千行甚至上万行后，
// 就应该考虑将代码分散到多个文件中，这里所谓的分散，并不是胡乱地划分。
// 为了方便后期的维护，分散代码应遵循一个基本原则：
// 实现相同功能的代码应存储在一个文件中。

// 事实上，一个完整的C++项目常常是由多个代码文件组成的，
// 根据后缀名的不同，大致可以将它们分为如下2类：
// 1.头文件，用于存放常量、函数的声明部分、类的声明部分；
// 2.源文件，用于存放变量、函数的定义部分，类的实现部分。
// 实际上，.cpp文件和.h文件都是源文件，除了后缀不一样便于区分和管理外，
// 其他的几乎相同，在.cpp中编写的代码同样也可以写在.h中。
// 之所以将.cpp文件和.h文件在项目中承担的角色进行区别，
// 不是C++语法的规定，而是约定成俗的规范，遵守即可。
// 虽然类内部的成员函数可以在声明的同时进行定义（自动成为内联函数），
// 但原则上不推荐这样使用。
// 也就是说，即便定义成员函数的代码很少，其定义也应该放在适当的.cpp文件中。
// 另外对于一些系统提供的库，出于版权和保密的考虑，
// 大多是已经编译好的二进制文件，其中可能仅包含.h文件，而没有.cpp文件。

// 总之项目越大，多文件编程的优势越明显：
//    ─┐
//     ├ student.h
//     ├ student.cpp
//     └ main.cpp
//    ─┐
//     ├─ include ┐
//     │          ├ student.h
//     │          └ ...
//     ├─ source ┐
//     ...       ├ student.cpp
//               ├ main.cpp
//               └ ...

// C或者C++程序的执行过程分为4步，依次是预处理、编译、汇编和链接。
// 在执行C++项目时，头文件是不需要经历以上这4个阶段的，
// 只有项目中的所有源文件才必须经历这4个阶段。
// 当前项目中有一个student.h头文件，student.cpp和main.cpp两个源文件。
// 接下来就用g++命令执行此项目，其过程依次是：
// 1.经历预处理阶段，执行如下命令：
//   g++ -E main.cpp -o main.i
//   g++ -E student.cpp -o student.i
//   其中，-E选项用于限定g++编译器只进行预处理而不进行后续的3个阶段；
//   -o选项用于指定生成文件的名称。
//   Linux系统中，通常用.i作为C++程序预处理后所得文件的后缀名。
// 2.经历编译阶段，即对预处理阶段得到的-i文件做进一步的语法分析，
//   生成相应的汇编代码文件。
//   继续执行如下命令：
//   g++ -S main.i -o main.s
//   g++ -S student.i -o student.s
//   其中，-S选项用于限定g++编译器对指定文件进行编译，
//   得到的汇编代码文件通常以.s作为后缀名。
// 3.经历汇编阶段，即将汇编代码文件转换成可以执行的机器指令。
//   继续执行如下命令：
//   g++ -c main.s -o main.o
//   g++ -c student.s -o student.o
//   -c指令用于限定g++编译器只进行汇编操作，
//   最终生成的目标文件（本质就是二进制文件，但还无法执行）通常以.o作为后缀名。
// 4.经历链接阶段，即将所有的目标文件组织成一个可以执行的二进制文件。
//   执行如下命令：
//   g++ main.o student.o -o student.exe
//   注意，如果不用-o指定可执行文件的名称，默认情况下会生成a.out可执行文件。
//   Linux系统并不以文件的扩展名开分区文件类型，
//   所以a.out和student.exe都是可执行文件。
// 以上4个阶段中，文件的生成不分先后，只要保证所有源文件都得到处理即可。
// 整个执行过程非常繁琐，直接执行如下命令即可生成最终的可执行文件：
// g++ main.cpp student.cpp -o main

// 所谓定义，指的是就是将某个符号完整的描述清楚，它是变量还是函数，
// 变量类型以及变量值是多少，函数的参数有哪些以及返回值是什么等等；
// 而声明的作用仅是告诉编译器该符号的存在，
// 至于该符号的具体的含义，只有等链接的时候才能知道。
// 定义的时候需要遵循C++语法规则完整地描绘一个符号，
// 而声明的时候只需要给出该符号的原型即可。
// 值得一提的是在C++项目中，一个符号允许被声明多次，但只能被定义一次。
// 理由很简单，如果一个符号出现多种定义，编译器该采用哪一个呢？
// 所谓的头文件，其实它的内容跟.cpp文件中的内容是一样的，
// 都是C++的源代码，唯一的区别在于头文件不用被编译。
// 把所有的函数声明全部放进一个头文件中，当某一个.cpp源文件需要时，
// 可以通过#include宏命令直接将头文件中的所有内容引入到.cpp文件中。
// 这样，当.cpp文件被编译之前（也就是预处理阶段），
// 使用#include引入的.h文件就会替换成该文件中的所有声明。
// #include是一个来自C语言的宏命令，作用于程序执行的预处理阶段，
// 其功能是将它后面所写文件中的内容，完完整整、一字不差地拷贝到当前文件中。

// C++头文件内应该写什么?
// .h头文件的作用就是被其它的.cpp包含进去，其本身并不参与编译，
// 但实际上它们的内容会在多个.cpp文件中得到编译。
// 通过符号的定义只能有一次的规则，可以很容易地得出，
// 头文件中应该只放变量和函数的声明，而不能放它们的定义。
// 因为一个头文件的内容实际上是会被引入到多个不同的.cpp文件中的，
// 并且它们都会被编译，换句话说，如果在头文件中放了定义，
// 就等同于在多个.cpp文件中出现对同一个符号（变量或函数）的定义，
// 纵然这些定义的内容相同，编译器也不认可这种做法（报重定义错误）。
// .h头文件中只能存放变量或者函数的声明，而不要放定义。
// 凡事都有例外，以下3种情况也属于定义的范畴，但它们应该放在.h文件中：
// 1.头文件中可以定义const对象
//   全局的const对象默认是没有extern声明的，所以它只在当前文件中有效。
//   把这样的对象写进头文件中，即使它被包含到其他多个.cpp文件中，
//   这个对象也都只在包含它的那个文件中有效，
//   对其他文件来说是不可见的，所以便不会导致多重定义。
//   与此同时，由于这些.cpp文件中的const对象都是从一个头文件中包含进去的，
//   也就保证了这些.cpp文件中的const对象的值是相同的，可谓一举两得。
//   同理，static对象的定义也可以放进头文件。
// 2.头文件中可以定义内联函数
//   内联函数是需要编译器在编译阶段根据其定义将它内联展开的，
//   而并非像普通函数那样先声明再链接。
//   这就意味着，编译器必须在编译时就找到内联函数的完整定义。
//   显然，把内联函数的定义放进一个头文件中是非常明智的做法。
// 3.头文件中可以定义类
//   因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，
//   才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，
//   跟内联函数是基本一样的，即把类的定义放进头文件，
//   在使用到这个类的.cpp文件中去包含这个头文件。
//   值得一提的是，类的内部通常包含成员变量和成员函数，
//   成员变量是要等到具体的对象被创建时才会被定义（分配空间），
//   但成员函数却是需要在一开始就被定义的，这也就是类的实现。
//   通常的做法是将类的定义放在头文件中，
//   而把成员函数的实现代码放在一个.cpp文件中。
//   还有另一种办法，就是直接成员函数的实现代码写到类定义的内部。
//   在C++的类中，如果成员函数直接定义在类的内部，则编译器会将其视为内联函数。
//   所以把函数成员的定义写进类体内，一起放进头文件中，也是合法的。
//   注意，如果把成员函数的定义写在定义类的头文件中，
//   而没有写进类内部，这是不合法的。
//   这种情况下，此成员函数不是内联函数，
//   一旦头文件被两个或两个以上的.cpp文件包含，就可能会出现重定义的错误。

int main() { return 0; }