#include <iostream>

// 19.11 后记

// Nathan Myers是第一个提出萃取参数这一概念的人。
// 他最初将该想法作为在标准库组件中定义处理类型的方式提交给C++标准委员会。
// 在当时，他称其为baggage templates，并注意到它们包含了萃取。
// 但是，C++委员会的一部分成员不喜欢baggage这个名字，
// 并最终促成了traits这一名字的使用，后者在那之后被广泛使用。

// 客户代码通常不会和萃取有任何交集：默认萃取类的行为满足了大部分的常规需求，
// 而且由于它们是默认模板参数，它们根本就不需要出现在客户代码中。
// 这有利于为默认萃取模板使用很长的名字。
// 当客户代码通过提供客制化的萃取参数适应了模板的行为后，
// 最好能够为最终的特化提供一个类型别名。

// 萃取可以被作为一种反射使用，在其中程序看到了其自身的更为高阶的属性。
// 诸如IsClassT和PlusResult的萃取，以及其它一些窥测了程序中类型的类型萃取，
// 都实现了一种编译期的反射，这被证明是元编程的一个很好的手段。

// 将类型属性作为模板特化成员存储的相反至少可以追溯到1990年代中期。
// 一种比较严肃的早期的类型分类模板的应用是由SGI发布的STL实现。
// SGI模板被用来代表其模板参数的一些属性。
// 这些信息又被用来为特定的类型进行STL算法优化。

// Boost提供了更为完整的一组类型分类模板，
// 它们构成了2011 C++标准库中<type_triats>的基础。
// 虽然其中一些萃取可以根据本章介绍的技术实现，其它一些却需要编译器的支持，
// 这一点和由SGI编译期提供的__type_traits特化实现很类似。

// 使用诸如isValid的泛型模板提取SFINAE条件的本质信息这一技术，
// 是由Louis Dionne在2015年提出的，并在Boost.Hana中得到应用。

// 策略类显然是由很多程序员一起开发的，但是其中只有一部分得到了署名。
// Andrei Alexandrescu使policy classes这一名词变得流行，
// 他在其Modern C++ Design中对其有更为详细的介绍。

int main() { return 0; }