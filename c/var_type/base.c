#include <stdio.h>

// 数据是放在内存中的，在内存中存取数据要明确三件事情：数据存储在哪里、数据的长度以及数据的处理方式。
// 变量名不仅仅是为数据起了一个好记的名字，还告诉我们数据存储在哪里，使用数据时，只要提供变量名即可；而数据类型则指明了数据的长度和处理方式。
// 所以诸如int n;、char c;、float money;这样的形式就确定了数据在内存中的所有要素。
// C语言提供的多种数据类型让程序更加灵活和高效，同时也增加了学习成本。而有些编程语言，例如PHP、JavaScript等，在定义变量时不需要指明数据类型，编译器会根据赋值情况
// 自动推演出数据类型，更加智能。
// 除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，
// 这样的编程语言称为弱类型语言。
// 强类型语言一旦确定了数据类型，就不能再赋给其他类型的数据，除非对数据类型进行转换。弱类型语言没有这种限制，一个变量，可以先赋给一个整数，然后再赋给一个字符串。
// 最后需要说明的是：数据类型只在定义变量时指明，而且必须指明；使用变量时无需再指明，因为此时的数据类型已经确定了。

// 标识符就是程序员自己起的名字，除了变量名，后面还会讲到函数名、宏名、结构体名等，它们都是标识符。
// 不过，名字也不能随便起，要遵守规范；C语言规定，标识符只能由字母（A~Z, a~z）、数字（0~9）和下划线（_）组成，并且第一个字符必须是字母或下划线，不能是数字。
// 关键字（Keywords）是由C语言规定的具有特定意义的字符串，通常也称为保留字。标准C语言中一共规定了32个关键字。
// 注释（Comments）可以出现在代码中的任何位置，用来向用户提示或解释代码的含义。程序编译时，会忽略注释，不做任何处理，就好像它不存在一样。
// C语言支持单行注释和多行注释：
//  单行注释以//开头，直到本行末尾（不能换行）；
//  多行注释以/*开头，以*/结尾，注释内容可以有一行或多行。
// 表达式（Expression）和语句（Statement）的概念在C语言中并没有明确的定义：
//  表达式可以看做一个计算的公式，往往由数据、变量、运算符等组成，例如3*4+5、a=c=d等，表达式的结果必定是一个值；
//  语句的范围更加广泛，不一定是计算，不一定有值，可以是某个操作、某个函数、选择结构、循环等。以分号;结束的往往称为语句，而不是表达式。例如3*4+5;、a=c=d;等。

// 不同类型的除数和被除数会导致不同类型的运算结果：
//  当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。
//  一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是double类型的小数。
// 取余，也就是求余数，使用的运算符是%。C语言中的取余运算只能针对整数，也就是说，%的两边都必须是整数，不能出现小数，否则编译器会报错。
// 另外，余数可以是正数也可以是负数，由%左边的整数决定：
//  如果%左边是正数，那么余数也是正数；
//  如果%左边是负数，那么余数也是负数。
// ++在变量前面和后面是有区别的：
//  ++在前面叫做前自增。前自增先进行自增运算，再进行其他操作。
//  ++在后面叫做后自增。后自增先进行其他操作，再进行自增运算。
// 自减（--）也一样，有前自减和后自减之分。
// 自增自减完成后，会用新值替换旧值，将新值保存在当前变量中。
// 自增自减的结果必须得有变量来接收，所以自增自减只能针对变量，不能针对数字，例如10++就是错误的。

// 在函数外部定义的变量叫做全局变量（Global Variable），在函数内部定义的变量叫做局部变量（Local Variable）。
// 为了让编译器方便给变量分配内存，C89标准规定，所有的局部变量（函数内部的变量）都必须定义在函数的开头位置，在定义完所有变量之前不能有其它的表达式。
// 后来的C99标准就取消了这个限制。
// 一个变量，即使不给它赋值，它也会有一个默认的值，这个值就是默认初始值。
// 对于全局变量，它的默认初始值始终是0，因为全局变量存储在内存分区中的全局数据区，这个区域中的数据在程序载入内存后会被初始化为0。
// 而对于局部变量，C语言并没有规定它的默认初始值是什么，所以不同的编译器进行了不同的扩展，有的编译器会初始化为0，有的编译器放任不管，爱是什么就是什么。

// 所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。
// 括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。
// 所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。

// 自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。
// 在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，自动类型转换并不一
// 定是安全的。对于不安全的类型转换，编译器一般会给出警告。
// 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：
//  转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int和long参与运算时，先把int类型的数据转成long类型后再进行运算。
//  所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也要先转换为double类型，才能进行运算。
//  char和short参与运算时，必须先转换成int类型。
// 自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。如果需要，程序员也可以自己在代码中明确地提出要进
// 行类型转换，这称为强制类型转换。
// 无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。
// 在C语言中，有些类型既可以自动转换，也可以强制转换，例如int到double，float到int等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的void*
// 到int*，int到char*等。
// 可以自动转换的类型一定能够强制转换，但是，需要强制转换的类型不一定能够自动转换。
// 可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int到double没有什么缺点，float到int顶多是数值失真。只能强制进行的类型转换一般
// 风险较高，或者行为匪夷所思，例如，char*到int*就是很奇怪的一种转换，取得的值也很奇怪，再如，int到char*就是风险极高的一种转换，一般会导致程序崩溃。
// 使用强制类型转换时，程序员自己要意识到潜在的风险。

int main() {
  int a = 100;
  int b = 12;
  float c = 12.0;
  double p = a / b;
  double q = a / c;
  printf("p=%lf, q=%lf\n", p, q);  // p=8.000000, q=8.333333

  printf("100%%12=%d\n", 100 % 12);      // 100%12=4
  printf("100%%-12=%d\n", 100 % -12);    // 100%-12=4
  printf("-100%%12=%d\n", -100 % 12);    // -100%12=-4
  printf("-100%%-12=%d\n", -100 % -12);  // -100%-12=-4

  return 0;
}