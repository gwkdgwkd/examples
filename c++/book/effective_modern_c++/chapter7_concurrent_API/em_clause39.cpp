#include <atomic>
#include <condition_variable>
#include <future>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>

// 条款39：考虑针对一次性事件通信使用以void为模板实参的期望

// 有时候，提供让一个任务通知另一个以异步方式运行的任务发生了特定的事件的能力，
// 会是有用的，原因可能是第二个任务在事件发生之前无法推进。
// 这事件也许是某个数据结构完成初始化，也许是某个计算阶段结束了，
// 又也许是某个重要传感器取值被检测到了等，在此情况下，何为线程间通信的最佳方式？

namespace n1 {
// 一种通用的方法是使用条件变量。
// 把检测条件的任务称为检测任务，把对条件做出反应的任务称为反应任务，
// 则策略表示起来很简单：反应任务等待这条件变量，而检测任务则在事件发生时通知条件变量。
std::condition_variable cv;
std::mutex m;
void f1() {  // 检测任务
  // 检查条件

  cv.notify_one();
  // 如果有多个反应任务需要通知到，那么使用notify_all替换notify_one才合适。
}

void f2() {  // 反应任务
  // 在条件变量之上调用wait之前，必须通过std::unique_lock类型对象锁定互斥量，
  // 在等待条件变量之前锁定互斥量，对于线程库来说是典型操作。
  std::unique_lock<std::mutex> lk(m);
  cv.wait(lk);

  // 临界区域结束，通过lk的析构函数为m解锁
}

// 第一个问题有时被称为代码以为：即使代码能够一时运作，某些东西似乎也不太对劲。
// 互斥体是用于控制共享数据访问的，但检测和反应任务之间大有可能根本不需要这种介质。
// 例如，检测任务可能负责初始化一个全局数据结构，然后把它转交给反应任务使用，
// 如果检测任务在初始化之后从不访问该数据结构，并且在检测任务指示它已就绪之前，
// 反应任务从不访问它，那么这两个任务将会互相阻止对方访问，根本不需要什么互斥量。
// 采用条件变量这一途径却要求必须有个互斥量，这就为设计留下了令人生疑和不安的气息。

// 即使对此视而不见，还有两个问题是无论如何都需要关切的：
// 1.如果检测任务在反应任务调用wait之前就通知了条件变量，则反应任务将失去响应，
//   为了实现通知条件变量唤醒另一个任务，该任务必须已在等待该条件变量，
//   如果检测任务在响应任务执行wait之前就执行了通知动作，
//   则反应任务就将错过该通知，并且将等待到地老天荒；
// 2.反应任务的wait语句无法应对虚假唤醒，线程API的存在一个事实情况，很多语言中都如此，
//   不仅仅是C++，即使没有通知条件变量，针对该条件变量等待的代码也可能被唤醒，
//   这样的唤醒称为虚假唤醒，正确的代码通过确认等待的条件确实已经发生，
//   并将其作为唤醒后的首个动作来处理这种情况，C++的条件变量API使得做到一点异常简单，
//   因为它允许测试等待条件的lambda式或其他函数对象被传递给wait，换言之，
//   反应任务中调用wait时可以这样撰写：cv.wait(lk,[return 事件是否确已发生;]);
//   想要利用这项能力，就要求反应任务能够确认它所等待的条件是否成立，
//   但是考虑的上述场景中，是由检测线程负责识别它所等待的条件是否因为对应的事件发生导致的，
//   反应线程可能无法确认它正在等待的事件是否已经发生，这也是为什么它等待的是个条件变量！

// 在许多情况下，使用条件变量进行任务间通信是对于所面对问题的适当解法，
// 但现在看的这个问题似乎并非其中之一。
}  // namespace n1

namespace n2 {
// 许多软件工程师的下一个锦囊妙计是使用共享的布尔标志位。
// 该标志位的初始值是false，当检测线程识别出它正在查找的事件时，会设置该标志位：
std::atomic<bool> flag(false);

void f1() { flag = true; }
void f2() {
  while (!flag) {
  }
}

// 这种任务没有任何基于条件变量的设计的缺点：
// 1.不需要互斥体，如果检测任务在反应任务开始轮询之前就设置了标志位，也没有任何问题；
// 2.并且虚假唤醒的毛病也不见了。

// 可是不那么好的地方在于，反应任务的轮询可能成本高昂。
// 在任务等待标记未被设置的时候，它实质上应该被阻塞，但却仍然在运行。
// 因此，它就占用了另一个任务本应该能够利用的硬件线程，
// 而且在每次开始运行以及其时间片结束时，都会产生语境切换的成本。
// 它还可能会让一颗硬件核心持续运行而那颗核心本来可以关掉以节省电能。
// 真正处于阻塞状态的任务不会耗用所有以上这些。
// 这倒是基于条件变量的途径的一个优点，因为等待调用的任务会真正地被阻塞。
}  // namespace n2

namespace n3 {
// 常用的手法是结合条件变量和基于标志位的设计。
// 标志位表示是否发生了有意义的事件，但是访问该标志要通过互斥量加以同步。
// 因为互斥锁会阻止并发访问该标志位，所以，如条款40所说，
// 不需要该标志位采用std::atomic类型对象来实现，一个平凡的布尔量足矣。
// 这么一来，检测任务会长成这样：
std::condition_variable cv;
std::mutex m;
bool flag(false);
void f1() {
  {
    std::lock_guard<std::mutex> g(m);
    flag = true;
  }
  cv.notify_one();
}
void f2() {
  std::unique_lock<std::mutex> lk(m);
  cv.wait(lk, [] { return flag; });
}

// 采用这一途径，可以避免我们先前讨论过的问题。
// 它能够运作、在检测任务通知之前响应任务就开始等待也没关系，
// 在存在虚假唤醒的前提下也不影响，而且不需要轮询。
// 然而，还是有一丝异味存在，因为检测任务和反应任务的沟通方式非常奇特。
// 通知条件变量在这里的目的是告诉反应任务，它正在等待的事件可能已经发生了，
// 然而反应任务必须检查标志位才能确定。
// 设置标志位在这里的目的是告诉反应任务事件确确实实已经发生了，
// 但是检测任务仍然需要通知条件变量才能让反应任务被唤醒并去检查标志位。
// 这一途径是能够运作的，但是不够干净利落。
}  // namespace n3

namespace n4 {
// 另一种方法是摆脱条件变量，互斥量和标志位，方法是让反应任务去等待检测任务设置的期望。
// 这看似是一种怪异的想法，毕竟，条款38层曾经解释过，
// 期望代表了从被调者到（通常以异步方式运行的）调用者的信道接收端，
// 在检测和反应任务之间并不存在这种调用者和被调者的关系。
// 不过，条款38又指出，发送端是std::promise类型对象，
// 并且其接受端是期望的通信信道用途不止于调用者和被调者一种。
// 这种信道可以用于任何需要将信息从一处传输到另一处的场合。
// 在本例中，将使用它来将信息从检测任务传输到响应任务，传达信息则是有意义的事件已经发生。

// 这种设计简单易行，检测任务有一个std::promise类型对象，
// 即，信道的写入端，反应任务有对应的期望。
// 当检测任务发现他正在查找的事件已经发生时，它会设置std::promise类型对象。
// 与此同时，反应任务调用wait以等待它的期望。
// 该wait调用会阻塞反应任务直至std::promise类型对象被设置为止。

// 在这里的std::promise、std::future和std::shared_future都是需要类型形参的模板。
// 该形参表示的是要通过信道发送数据的类型。
// 在本例中，却并没有数据要传送，对于反应任务有意义的唯一事情，就是它的期望有否已被设置。
// 所需要的std::promise和期望模板是一种表示没有数据要通过信道传送的那么一种类型。
// 那种类型就是void，因此，检测任务将使用std::promise<void>，
// 并且反应任务将使用std::future<void>或std::shared_future<void>。
// 当有意义的事件发生时，检测任务将设置其std::promise<void>，
// 反应任务将等待其期望，即使反应任务不会接收任何来自检测任务的数据，
// 信道也会允许反应任务通过在其std::promise类型对象上调用set_value，
// 来了解检测任务何时写入了其void类型的数据。

std::promise<void> p;
void f1() {
  // 检测事件

  p.set_value();  // 通知反应任务
}
void f2() { p.get_future().wait(); }

// 就像使用标志位的途径一样，这个设计也不需要互斥量，
// 检测任务是否在响应任务等待之前设置它的std::promise都可以，
// 且对虚假唤醒免疫，只有条件变量会不能应对虚假唤醒。
// 也像基于条件变量的途径一样，在调用wait之后，反应任务真正被阻塞，
// 所以在等待时不会消耗系统资源，完美，对不对?

// 不对，当然，基于期望的途径可以绕开前面的那些险滩，但仍不免于其他的一些陷阱。
// 例如，条款38就解释过，std::promise和期望之间是共享状态，而共享状态通常是动态分配的。
// 因此，就得假设这种设计会招致在堆上进行分配和回收的成本。

// 可能这一点是最重要的：std::promise类型对象只能设置一次。
// std::promise类型对象和期望之间的通信通道是个一次性机制：它不能重复使用。
// 这就是它基于条件变量和基于标志位的设计之间的显著差异，前两者都可以用来进行多次通信，
// 条件变量可以被重复通知，标志位可以被清除并重新设置。

// 一次性这一约束并不像你可能想象的限制那么大，假设想创建一个暂停状态的系统线程。
// 也就是说，希望一开始就把与创建线程相关的所有开销都提前付清，
// 尔后一旦要在线程上执行某些操作时即可避免常规的线程创建延迟了。
// 又或者可能想创建一个暂停的线程，以便在它运行之前先对其实施一些配置动作。
// 这样的配置可能包括诸如设置其优先级或内核亲和性之类。
// C++并发API并未提供做这些方法，但std::thread提供了native_handle成员函数，
// 意在让你得以访问平台的底层线程API，通常是POSIX线程或Windows线程。
// 低级API通常能够配置像优先级和亲和性这样的线程特征。

// 假定只想暂停线程一次，在它创建之后，但在它运行其线程函数之前，
// 使用void期望的设计就是合理的选择，下面是该技术的重要部分：
void react() {}

namespace test1 {
void detect() {  // 检测任务的函数
  std::thread t([]() {
    p.get_future().wait();  // 暂停t
    react();                // 直至其期望被设置
  });

  // 在这里t处于暂停状态，在调用react之前

  p.set_value();  // 取消暂停t，调用react

  // 做其他工作

  t.join();  // 置t于不可联结状态
}
}  // namespace test1

namespace test2 {
// 因为使t在所有detect的出向路径上都置为不可联结这件事情很重要，
// 所以使用条款37中像ThreadRAII那样的RAII类应该是可取的：

class ThreadRAII {
 public:
  enum class DtorAction { detach, join };
  ThreadRAII(std::thread&& thread, DtorAction action)
      : m_action(action), m_thread(std::move(thread)) {}
  ~ThreadRAII() {
    if (m_thread.joinable()) {
      if (m_action == DtorAction::join) {
        m_thread.join();
      } else {
        m_thread.detach();
      }
    }
  }
  std::thread& getThread() { return m_thread; }
  ThreadRAII(ThreadRAII&&) = default;
  ThreadRAII& operator=(ThreadRAII&&) = default;

 private:
  DtorAction m_action;
  std::thread m_thread;
};
void detect() {
  ThreadRAII tr(std::thread([] {
                  p.get_future().wait();
                  react();
                }),
                ThreadRAII::DtorAction::join  // 这里有风险
  );

  // tr内的线程在此处被暂停

  p.set_value();  // tr内的线程在此处被取消暂停
}

// 这段代码不像看上去那么安全，问题在于tr内的线程在此处被暂停那里，如果抛出异常的话，
// set_value便永远不会在p上调用，这意味着，在lambda式内部调用的wait将永远不会返回。
// 而这，反过来又意味着，运行lambda式的线程将永远不会完成，这是个问题，
// 因为RAII对象tr已被配置为在tr的析构函数中针对该线程执行join。
// 换言之，如果抛出异常，这个函数将会失去响应，因为tr的析构函数将永远不会完成。

// 有多种方法可以解决该问题，但将它留给读者作为一个宝贵的练习机会。
}  // namespace test2

namespace test3 {
// 扩充不使用ThreadRAII的原始代码，使之可以针对不止一个，
// 可以是很多个反应任务实施先暂停再取消暂停的功能。
// 这个拓展训练不难，因为关键之处在于在react的代码中使用shared_future而非future。
// 唯一的微妙之处就是，每个反应线程都需要自己的那份shared_future副本去指涉到共享状态，
// 所以，从share中获取的std::shared_future被运行在反应线程上的lambda式按值捕获：
void detect() {
  auto sf = p.get_future().share();  // sf的类型是std::shared_future<void>
  std::vector<std::thread> vt;       // 反应任务的容器

  for (int i = 0; i < vt.size(); ++i) {
    vt.emplace_back([sf] {
      sf.wait();  // sf局部副本之上的wait
      react();
    });
  }

  p.set_value();  // 让所有线程取消暂停

  for (auto& t : vt) {  // 把所有线程置为不可联结状态
    t.join();
  }
}
// 使用期望的设计能够实现这样的效果，这也是为何应该将一次性事件通信纳入考量。
}  // namespace test3
}  // namespace n4

// 要记住的东西：
// 1.如果仅仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，
//   这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生；
// 2.使用标志位的设计可以避免上述问题，但这一设计基于轮询而非阻塞；
// 3.条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然；
// 4.使用std::promise类型对象和期望就可以回避这些问题，
//   但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。

int main() { return 0; }