#include <stdio.h>
#include <string.h>

// 程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。
// 栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。
// 在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。
// 这称为先进后出（First In Last Out）原则。放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）。
// 栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。
// 从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用ebp寄存器指向栈底，而使用esp寄存器指向栈顶。随着数据的进栈出栈，
// esp的值会不断变化，进栈时esp的值减小，出栈时esp的值增大。
// ebp和esp都是CPU中的寄存器：ebp是Extend Base Pointer的缩写，通常用来指向栈底；esp是Extend Stack Pointer的缩写，通常用来指向栈顶。

// 栈的大小以及栈溢出
// 对每个程序来说，栈能使用的内存是有限的，一般是1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。
// 一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。
// 栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在VC/VS下，默认是1M，在C-Free下，默认是2M，在Linux GCC下，默认是8M。也可以通过参数来修改栈内存的大小。
// 栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，要注意区分。

// 栈帧/活动记录
// 函数的调用和栈是分不开的，没有栈就没有函数调用。
// 当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。
// 活动记录一般包括以下几个方面的内容：
//  1) 函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。
//     int a, b, c;
//     func(1, 2);
//     c = a + b;
//     站在C语言的角度看，func()函数执行完成后，会继续执行c=a+b;语句，那么返回地址就是该语句在内存中的位置。
//     C语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址。
//  2) 参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，暂时不考虑这种情况。
//  3) 编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。
//     当返回值的长度较小（char、int、long 等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。
//  4) 一些需要保存的寄存器，例如ebp、ebx、esi、edi等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。
/*     Windows下使用VS2010 Debug模式编译时一个函数所使用的栈内存，可以发现，理论上ebp寄存器应该指向栈底，但在实际应用中，它却指向了old ebp。
       +--------------------------+ ------
       |           参数           |
       +--------------------------+
       |          返回地址         |   活
       +--------------------------+
       |          old ebp         |   动
   ebp +--------------------------+
       |      局部变量、返回值等     |   记
       +--------------------------+       
       |          old ebx         |   录
       +--------------------------+
       |          old esi         |
       +--------------------------+
       |          old edi         |
   esp +--------------------------+ ------  
*/
// 在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。
// 当发生函数调用时：
//  实参、返回地址、ebp 寄存器首先入栈；
//  然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；
//  最后将其他寄存器的值压入栈中。
// 需要注意的是，不同编译器在不同编译模式下所产生的函数栈并不完全相同。

// 关于数据的定位
// 由于esp的值会随着数据的入栈而不断变化，要想根据esp找到参数、局部变量等数据是比较困难的，所以在实现上是根据ebp来定位栈内数据的。
// ebp的值是固定的，数据相对ebp的偏移也是固定的，ebp的值加上偏移量就是数据的地址。
void func(int a, int b) {
  float f = 28.5;
  int n = 100;
}
/*     func(15, 92);
       +--------------------------+ ------
       |            92            |
       +--------------------------+ 
       |            15            |
       +--------------------------+
       |          返回地址         |   活
       +--------------------------+
       |          old ebp         |   动
   ebp +--------------------------+
       |           28.5           |   记
       +--------------------------+       
       |           100            |   录
       +--------------------------+
       |         冗余的内存         |
       +--------------------------+
       |          old ebx         |
       +--------------------------+
       |          old esi         |
       +--------------------------+
       |          old edi         |
   esp +--------------------------+ ------  
*/
// 这里我们假设两个局部变量挨着，并且第一个变量和old ebp也挨着（实际上它们之间有4个字节的空白），如此，第一个参数的地址是ebp+12，第二个参数的地址是ebp+8，
// 第一个局部变量的地址是ebp-4，第二个局部变量的地址是ebp-8。

// 一个C程序由若干个函数组成，C程序的执行实际上就是函数之间的相互调用。
// 函数调用方和被调用方必须遵守同样的约定，理解要一致，这称为调用惯例（Calling Convention）。
// 一个调用惯例一般规定以下两方面的内容：
//  1) 函数参数的传递方式，是通过栈传递还是通过寄存器传递。
//  2) 函数参数的传递顺序，是从左到右入栈还是从右到左入栈。
//  3) 参数弹出方式。函数调用结束后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由调用方来完成，也可以由被调用方来完成。
//  4) 函数名修饰方式。函数名在编译时会被修改，调用惯例可以决定如何修改函数名。
// 在C语言中，存在多种调用惯例，可以在函数声明或函数定义时指定:
int __attribute__((cdecl)) max(int m, int n);
int __attribute__((cdecl)) max(int m, int n) {
  int max = m > n ? m : n;
  return max;
}
// 函数调用惯例在函数声明和函数定义时都可以指定，语法格式为：返回值类型  调用惯例  函数名(函数参数)
// 在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。
// __cdecl是C语言默认的调用惯例，在平时编程中，其实很少去指定调用惯例，这个时候就使用默认的__cdecl。
// 注意：__cdecl并不是标准关键字，在VC/VS下直接写__cdecl，但是在GCC下，要使用 __attribute__((cdecl))。
// 除了cdecl，还有其他调用惯例
// 调用惯例  参数传递方式 	                参数出栈方式 	       名字修饰
// cdecl 	按照从右到左的顺序入栈 	        调用方 	              下划线+函数名，如函数max()的修饰名为_max
// stdcall 	按照从右到左的顺序入栈 	        函数本身（被调用方）     下划线+函数名+@+参数的字节数，如函数int max(int m, int n)的修饰名为_max_@8
// fastcall 部分放入寄存器，剩下的从右到左 	 函数本身（被调用方） 	   @+函数名+@+参数的字节数
// pascal 	按照从左到右的顺序入栈 	        函数本身（被调用方） 	  较为复杂

int *p;
void func1(int m, int n) {
  int a = 18, b = 100;
  p = &a;  // 在func()中，将局部变量a的地址赋给p
}
int main() {
  int n;
  func1(10, 20);
  // 栈上的数据只有在后续函数继续入栈时才能被覆盖掉，这就意味着，只要时机合适，在函数外部依然能够取得局部变量的值。
  n = *p;
  // 在main()函数中调用func()，函数刚刚调用结束，还没有其他函数入栈，局部变量a所在的内存没有被覆盖掉，所以通过语句n=*p;能够取得它的值。
  printf("n = %d\n", n);  // n = 18

  // C语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，将这样的错误称为“栈溢出错误”。
  // 栈溢出一般不会产生严重的后果，但是如果有用户精心构造栈溢出，让返回地址指向恶意代码，那就比较危险了，这就是常说的栈溢出攻击。
  char str[10] = {0};
  gets(str);
  printf("str: %s\n", str);
  // 123456789012345678901234567890
  // str: 123456789012345678901234567890
  // *** stack smashing detected ***: ./a.out terminated
  // 已放弃 (核心已转储)
  // 局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的gets()函数，strcpy()、scanf()等能够向数组写入数据的函数都有导致栈溢出的风险。

  // 使用strcpy()函数导致栈溢出的例子：
  char *str1 = "这里是C语言中文网";
  char str2[6] = {0};
  strcpy(str2, str1);
  printf("str: %s\n", str2);

  return 0;
}

/* 
VS2010 Debug模式，函数使用默认的调用惯例cdecl，即参数从右到左入栈，由调用方负责将参数出栈。
void func(int a, int b){
    int p =12, q = 345;
}
int main(){
    func(90, 26);
    return 0;
}

1 main函数的栈
    |                    main                      |
                   ebp                            esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|
2 执行func(90,26)语句
    |                    main                      |
                   ebp                                          esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|
3 开始执行函数体代码，并将原来ebp的值压入栈中，再将esp的值赋给ebp
    |                    main                      |
                                                                      ebp、esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|
4 预留内存
    |                    main                      |
                                                                        ebp                     esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|        预留内存        |
5 将剩余的寄存器压入栈中
    |                    main                      |                              func                                   |
                                                                        ebp                                             esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|        预留内存        |old ebx|old esi|old edi|
6 将p、q的值放入内存
    |                    main                      |                              func                                   |
                                                                        ebp                                             esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|4字节空白|12|空白|345|空白|old ebx|old esi|old edi|
7 将寄存器的值出栈
    |                    main                      |                              func                                   |
                                                                        ebp                     esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|4字节空白|12|空白|345|空白|old ebx|old esi|old edi|
8 将ebp赋值给esp
    |                    main                      |                              func                                   |
                                                                      ebp、esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|4字节空白|12|空白|345|空白|old ebx|old esi|old edi|
9 将old ebp、返回地址、参数依次出栈
    |                    main                      |                              func                                   |
                   ebp                            esp
    |返回地址|old ebp|预留内存|old ebx|old esi|old edi|26|90|返回地址|old ebp|4字节空白|12|空白|345|空白|old ebx|old esi|old edi|

步骤1到6是函数进栈过程：
1) main()是主函数，也需要进栈，如步骤1所示。
2) 在步骤2中，执行语句func(90, 26);，先将实参90、26 压入栈中，再将返回地址压入栈中，这些工作都由main()函数（调用方）完成。这个时候ebp的值并没有变，仅仅是改变esp的指向。
3) 到了步骤3，就开始执行func() 的函数体了。首先将原来ebp寄存器的值压入栈中（old ebp），并将esp的值赋给ebp，这样ebp就从 main()函数的栈底指向了func()函数的栈底，完成了
   函数栈的切换。由于此时esp和ebp的值相等，所以它们也就指向了同一个位置。
4) 为局部变量、返回值等预留足够的内存，如步骤4。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将esp的值减去一个整数，例如esp-0XC0，预留0XC0的内存。
5) 将ebp、esi、edi寄存器的值依次压入栈中。
6) 将局部变量的值放入预留好的内存中。注意，第一个变量和old ebp之间有4个字节的空白，变量之间也有若干字节的空白。
为什么要留出这么多的空白，岂不是浪费内存吗？这是因为使用Debug模式生成程序，留出多余的内存，方便加入调试信息；以Release模式生成程序时，内存将会变得更加紧凑，空白也被消除。
至此，func()函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。
未初始化的局部变量的值为什么是垃圾值
为局部变量分配内存时，仅仅是将esp的值减去一个整数，预留出足够的空白内存，不同的编译器在不同的模式下会对这片空白内存进行不同的处理，可能会初始化为一个固定的值，也可能不进行初始化。
步骤7到9是函数func()出栈过程：
7) 函数func()执行完成后开始出栈，首先将edi、esi、ebx寄存器的值出栈。
8) 将局部变量、返回值等数据出栈时，直接将ebp的值赋给esp，这样ebp和esp就指向了同一个位置。
9) 接下来将old ebp出栈，并赋值给现在的ebp，此时ebp就指向了func()调用之前的位置，即main()活动记录的old ebp位置，如步骤9所示。
这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将old ebp压入栈中的原因。
最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时esp就指向了main()活动记录的栈顶， 这意味着func()完全出栈了，栈被还原到了func()被调用之前的情况。 
*/