#include <iostream>
#include <vector>

// 确保容器中的对象拷贝正确而高效

// 容器中保存了对象，但并不是提供给容器的那些对象。
// 而当从容器中取出一个对象时，所取出的也不是容器中所保存的那份。
// 当通过insert或push_back添加对象时，存入容器的是所指定的对象的拷贝。
// 当通过front或back取出一个对象时，得到的是容器中所保存的对象的拷贝。
// 进去拷贝，出来也是拷贝，这就是STL的工作方式。
// 一旦对象被保存到容器中，它经常会进一步被拷贝，拷贝对象是STL的工作方式。
class Widget {
 public:
  Widget() {}
  Widget(const Widget&) {}
  Widget& operator=(const Widget&) { return *this; }
};
// 如果向容器中填充对象，而对象的拷贝操作又很费时，
// 那么向容器中填充对象这一简单的操作将会成为程序的性能瓶颈。
// 放入的对象越多，拷贝需要的内存和时间就越多。

// 在存在继承关系的情况下，拷贝动作会导致剥离。
// 如果创建了一个存放基类对象的容器，却向其中插入派生类的对象，
// 那么在派生类对象（通过基类的拷贝构造函数）被拷贝容器时，
// 特有部分（派生类中的信息）将会丢失：
class SpecialWidget : public Widget {};

// 使拷贝动作高效、正确，并防止剥离的一个简单办法是使容器包含指针而不是对象。
// 指针拷贝的速度非常快，并且总是会按期望的方式进行（拷贝构成指针的每一位），
// 而且当它被拷贝时不会发生剥离现象，指针的容器也有令人头疼的、与STL相关的问题。
// 如果想避开令人头疼的问题，同时又想避免效率、正确性和剥离这些问题，可以用智能指针。

// STL做了很多拷贝，但它总的设计思想是为了避免不必要的拷贝。
// STL总体的设计目标是为了避免创建不必要的对象，与数组相比，STL容器要聪明的多，
// 让它创建多少对象，它就（通过拷贝）创建多少对象，不会多，也不会少。
// 让它创建时它才创建，只有当你让它使用默认构造函数时它才会使用，STL容器是在创建拷贝。
// 跟数组相比，STL仍是迈出了一大步，这是一个不可忽略的事实。

int main() {
  std::vector<Widget> vw;
  SpecialWidget sw;
  vw.push_back(sw);

  // 这将创建10个对象，即使只会使用其中几个，
  // 或者会立即使用从其他地方得到的值来覆盖默认构造函数所提供的默认值：
  Widget w1[10];

  // 空的vector，包含足够的空间容纳10个对象，但并没有创建任何一个对象：
  std::vector<Widget> w2;

  return 0;
}