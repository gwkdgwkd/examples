#include <stdio.h>

// 模块化编程中的头文件
// .c和.h文件都是源文件，除了后缀不一样便于区分外和管理外，
// 其他的都是相同的，在.c中编写的代码同样也可以写在.h中，
// 包括函数定义、变量定义、预处理等。
// 但是，.h和.c在项目中承担的角色不一样：
// .c文件主要负责实现，也就是定义函数和变量；
// .h文件主要负责声明（包括变量声明和函数声明）、宏定义、类型定义等。
// 这些不是C语法规定的内容，而是约定成俗的规范，或者说是长期形成的事实标准。
// 根据这份规范，头文件可以包含如下的内容：
// 1.可以声明函数，但不可以定义函数。
// 2.可以声明变量，但不可以定义变量。
// 3.可以定义宏，包括带参的宏和不带参的宏。
// 4.结构体的定义、自定义数据类型一般也放在头文件中。
// 在项目开发中，可以将一组相关的变量和函数定义在一个.c文件中，
// 并用一个同名的.h文件（头文件）进行声明，
// 其他模块如果需要使用某个变量或函数，那么引入这个头文件就可以。
// 这样做的另外一个好处是可以保护版权，在发布相关模块之前，
// 可以将它们都编译成目标文件，或者打包成静态库，只要向用户提供头文件，
// 用户就可以将这些模块链接到自己的程序中。

// 标准库以及标准头文件
// C语言在发布的时候已经将标准库打包到了静态库，并提供了相应的头文件，
// 例如stdio.h、stdlib.h、string.h等。
// Linux一般将静态库和头文件放在/lib和/user/lib目录下，
// C语言标准库的名字是libc.a，可以通过locate命令来查找它的路径。
// ANSIC标准共定义了15个头文件，称为C标准库，所有的编译器都必须支持，
// 如何正确并熟练的使用这些标准库，可以反映出一个程序员的水平：
// 1.合格程序员：<stdio.h>、<ctype.h>、<stdlib.h>、<string.h>
// 2.熟练程序员：<assert.h>、<limits.h>、<stddef.h>、<time.h>
// 3.优秀程序员：<float.h>、<math.h>、<error.h>、<locale.h>、
//             <setjmp.h>、<signal.h>、<stdarg.h>
// C语言共有两套标准，也就是ANSI C和C99。
// ANSI C是较早的标准，各种编译器都能很好的支持，
// C99是后来的标准，编译器对它的支持不尽相同。
// 除了C标准库，编译器一般也会附带自己的库，
// 以增加功能，方便用户开发，争夺市场份额。
// 这些库中的每一个函数都在对应的头文件中声明，
// 可以通过#include预处理命令导入，编译时会被合并到当前文件。

// 头文件的路径
// 引入编译器自带的头文件（包括标准头文件）用尖括号，
// 引入程序自定义的头文件用双引号。
// 使用尖括号<>，编译器会到系统路径下查找头文件；
// 而使用双引号""，编译器首先在当前目录下查找头文件，
// 如果没有找到，再到系统路径下查找。
// 也就是说，使用双引号比使用尖括号多了一个查找路径，
// 它的功能更为强大，完全可以使用双引号来包含标准头文件。

// 头文件被重复包含
// 头文件包含命令#include的效果与直接复制粘贴头文件内容的效果是一样的，
// 预处理器实际上也是这样做的，它会读取头文件的内容，
// 然后输出到#include命令所在的位置。
// 头文件包含是一个递归（循环）的过程，
// 如果被包含的头文件中还包含了其他的头文件，
// 预处理器会继续将它们也包含进来；
// 这个过程会一直持续下去，直到不再包含任何头文件，这与递归的过程颇为相似。
// 头文件的交叉包含是非常普遍的现象，
// 不仅自己创建的头文件是这样，标准头文件也是如此。
// 在实际开发中，我们往往使用宏保护来解决
// #ifndef _XYZ_H
// #define _XYZ_H
// /* 头文件内容 */
// #endif
// 这种宏保护方案使得程序员可以任性地引入当前模块需要的所有头文件，
// 不用操心这些头文件中是否包含了其他的头文件。

int main() { return 0; }