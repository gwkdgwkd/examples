#include "multiple_files.h"

// 在将函数应用于多文件编程时，通常是将函数定义放在源文件（.cpp文件）中，将函数声明放在头文件（.h文件）中，使用函数时引入（#include命令）对应的头文件即可。
// 编译是针对单个源文件的，只要有函数声明，编译器就能知道函数调用是否正确；而将函数调用和函数定义对应起来的过程，可以延迟到链接时期。
// 正是有了链接器的存在，函数声明和函数定义的分离才得以实现。
// 将类应用于多文件编程也是类似的道理，可以将类的声明和类的实现分别放到头文件和源文件中。类的声明已经包含了所有成员变量的定义和所有成员函数的声明（也可以是inline
// 形式的定义），这样就知道如何创建对象了，也知道如何调用成员函数了，只是还不能将函数调用与函数实现对应起来，但是这又有什么关系呢，反正链接器可以帮助我们完成这项工作。
// 总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起
// 来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。
// 基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。
// 但事实证明这种做法是不对的，程序员惯用的做法是将模板的声明和定义都放到头文件中。
// 模板并不是真正的函数或类，它仅仅是用来生成函数或类的一张“图纸”，在这个生成过程中有三点需要明确：
//  模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码；
//  模板的实例化是由编译器完成的，而不是由链接器完成的；
//  在实例化过程中需要知道模板的所有细节，包含声明和定义。
// 「不能将模板的声明和定义分散到多个文件中」的根本原因是：模板的实例化是由编译器完成的，而不是由链接器完成的，这可能会导致在链接期间找不到对应的实例。

int main() {
  int n1 = 10, n2 = 20;
  Swap(n1, n2);
  double f1 = 23.8, f2 = 92.6;
  Swap(f1, f2);

  Point<int, int> p1(10, 20);
  p1.setX(40);
  p1.setY(50);
  cout << "x=" << p1.getX() << ", y=" << p1.getY() << endl;
  Point<char*, char*> p2("东京180度", "北纬210度");
  p2.display();

  return 0;
}

// g++ -std=c++11 multiple_files.cpp multiple_files_main.cpp

// multiple_files_main.cpp:(.text+0x61)：对‘void Swap<double>(double&, double&)’未定义的引用
// 主函数main()中共调用了两个版本的Swap()函数，它们的原型分别是：
//  void Swap<double>(int &, int &);
//  void Swap<double>(double &, double &);
// 为什么针对int的版本能够找到定义，而针对double的版本就找不到呢？（只有int，能编译通过）
// 对double的版本为什么找不到定义:
//  当编译器编译main.cpp时，发现使用到了double版本的Swap()函数，于是尝试生成一个double版本的实例，但是由于只有声明没有定义，所以生成失败。
//  不过这个时候编译器不会报错，而是对该函数的调用做一个记录，希望等到链接程序时在其他目标文件（.obj文件或.o文件）中找到该函数的定义。很明显，
//  本例需要到func.obj中寻找。但是遗憾的是，func.cpp中没有调用double版本的Swap()函数，编译器不会生成double版本的实例，所以链接器最终也找
//  不到double版本的函数定义，只能抛出一个链接错误，让程序员修改代码。
// 针对int的版本为什么能够找到定义:
//  bubble_sort()函数用来对数组元素进行排序，在排序过程中需要频繁的交换两个元素的值，所以调用了Swap()函数，这样做的结果是：编译生成的func.obj
//  中会有一个int版本的Swap()函数定义。编译器在编译main.cpp时虽然找不到int版本的实例，但是等到链接程序时，链接器在func.obj中找到了，所以针
//  对int版本的调用就不会出错。

// multiple_files_main.cpp:(.text+0x119)：对‘Point<char*, char*>::display() const’未定义的引用
// 类模板声明位于point.h中，它包含了所有成员变量的定义以及构造函数、get函数、set函数的定义，这些信息足够创建出一个完整的对象了，并且可以通过对
// 象调用get函数和set函数，所以调用display()函数前不会报错，调用该函数会报错。该函数的定义位于point.cpp文件中，并且point.cpp中也没有生成对
// 应的实例，所以会在链接期间抛出错误。

// 修复上面两个项目的方法也很简单，就是将func.cpp、point.cpp的模板定义（实现）部分分别合并到func.h、point.h中。