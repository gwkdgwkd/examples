#include <stdio.h>

// 关系运算符在使用时，它的的两边都会有一个表达式，
// 比如变量、数值、加减乘除运算等，
// 关系运算符的作用就是判明这两个表达式的大小关系。
// 注意，是判明大小关系，不是其他关系。
// 关系运算符都是双目运算符，其结合性均为左结合。
// 优先级:算术运算符>关系运算符>赋值运算符。
// 在六个关系运算符中，<、<=、>、>=的优先级相同，
// 高于==和!=，==和!=的优先级相同。
// 关系运算符的两边可以是变量、数据或表达式。
// 关系运算符的运算结果只有0或1。
// 当条件成立时结果为1，条件不成立结果为0。
// 对于含多个关系运算符的表达式，如k==j==i+5，
// 根据运算符的左结合性，先计算k==j，该式不成立，
// 其值为0，再计算0==i+5，也不成立，故表达式值为0。

// 逻辑运算:
// 1.与运算(&&)，参与运算的两个表达式都为真时，结果才为真，否则为假。
// 2.或运算(||)，参与运算的两个表达式只要有一个为真，结果就为真；
//   两个表达式都为假时结果才为假。
// 3.非运算(!)，参与运算的表达式为真时，结果为假；
//   参与运算的表达式为假时，结果为真。
// 逻辑运算符和其它运算符优先级从低到高依次为：
// 赋值运算符(=) < &&和|| < 关系运算符 < 算术运算符 < 非(!)
// &&和||低于关系运算符，!高于算术运算符。
// 按照运算符的优先顺序可以得出：
// a>b && c>d    等价于  (a>b)&&(c>d)
// !b==c||d<a    等价于  ((!b)==c)||(d<a)
// a+b>c&&x+y<b  等价于  ((a+b)>c)&&((x+y)<b)

// 条件运算符是C语言中唯一的一个三目运算符：
// 表达式1?表达式2:表达式3
// 其求值规则为：
// 如果表达式1的值为真，则以表达式2的值作为整个条件表达式的值，
// 否则以表达式3的值作为整个条件表达式的值。
// 条件表达式通常用于赋值语句之中。
// 使用条件表达式时，还应注意以下几点：
// 1.条件运算符的优先级低于关系运算符和算术运算符，但高于赋值符。
//   因此max=(a>b) ? a : b;
//   可以去掉括号而写为max=a>b ? a : b;
// 2.条件运算符?和：是一对运算符，不能分开单独使用。
// 3.条件运算符的结合方向是自右至左。
//   例如：a>b ? a : c>d ? c : d;
//   应理解为：a>b ? a : (c>d ? c : d);
//   这也就是条件表达式嵌套的情形，即其中的表达式又是一个条件表达式。

// 位运算
// 所谓位运算，就是对一个比特（Bit）位进行操作。
// C语言提供了六种位运算符：
// 按位与(&),按位或(|),按位异或(^),取反(~),左移(<<),右移(>>)
// 1.按位与运算（&）：
//   只有参与&运算的两个位都为1时，结果才为1，否则为0。
//   &是根据内存中的二进制位进行运算的，而不是数据的二进制形式；
//   其他位运算符也一样。
//   按位与运算通常用来对某些位清0，或者保留某些位。
//   例如要把n的高16位清0，保留低16位，可以进行n&0XFFFF运算。
// 2.按位或运算（|）：
//   参与|运算的两个二进制位有一个为1时，结果就为1，两个都为0时结果才为0。
//   按位或运算可以用来将某些位置1，或者保留某些位。
//   例如要把n的高16位置1，保留低16位，可以进行n|0XFFFF0000运算。
// 3.按位异或运算（^）：
//   参与^运算两个二进制位不同时，结果为1，相同时结果为0。
//   按位异或运算可以用来将某些二进制位反转。
//   例如要把n的高16位反转，保留低16位，可以进行n^0XFFFF0000运算。
// 4.取反运算（~）：
//   取反运算符~为单目运算符，右结合性，作用是对参与运算的二进制位取反。
// 5.左移运算（<<）:
//   <<把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。
//   如果数据较小，被丢弃的高位不包含1，那么左移n位相当于乘以2的n次方。
// 6.右移运算（>>）:
//   >>把操作数的各个二进制位全部右移若干位，低位丢弃，高位补0或1。
//   如果数据的最高位是0，那么就补0；
//   如果最高位是1，那么就补1。
//   如果被丢弃的低位不包含1，那么右移n位相当于除以2的n次方，
//   但被移除的位中经常会包含1。

// 加密的关键技术：
// 通过一次异或运算，生成密文，密文没有可读性，
// 与原文风马牛不相及，这就是加密；
// 密文再经过一次异或运算，就会还原成原文，这就是解密的过程；
// 加密和解密需要相同的密钥，如果密钥不对，是无法成功解密的。
// 上面的加密算法称为对称加密算法，加密和解密使用同一个密钥。
// 如果加密和解密的密钥不同，则称为非对称加密算法。
// 在非对称算法中，加密的密钥称为公钥，解密的密钥称为私钥，
// 只知道公钥是无法解密的，还必须知道私钥。

int main() {
  printf("%d\n", 4 == 5 == 1 + 5);  // 0

  int n1 = 0X8FA6002D;
  printf("%d, %d, %X\n", 9 & 5, -9 & 5, n1 & 0XFFFF);
  // 1, 5, 2D

  int n2 = 0X2D;
  printf("%d, %d, %X\n", 9 | 5, -9 | 5, n2 | 0XFFFF0000);
  // 13, -9, FFFF002D

  unsigned n3 = 0X0A07002D;
  printf("%d, %d, %X\n", 9 ^ 5, -9 ^ 5, n3 ^ 0XFFFF0000);
  // 12, -14, F5F8002D
  printf("%d, %d\n", ~9, ~-9);            // -10, 8
  printf("%d, %d\n", 9 << 3, (-9) << 3);  // 72, -72
  printf("%d, %d\n", 9 >> 3, (-9) >> 3);  // 1, -2

  return 0;
}