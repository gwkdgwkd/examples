#include <stdio.h>

// 在C语言中，用一个指针变量指向一个文件，这个指针称为文件指针。
// 通过文件指针就可对它所指的文件进行各种操作。
// 定义文件指针的一般形式为：FILE *fp;
// 这里的FILE，实际上是在stdio.h中定义的一个结构体，
// 该结构体中含有文件名、文件状态和文件当前位置等信息，
// fopen返回的就是FILE类型的指针。
// 注意：FILE是文件缓冲区的结构，fp也是指向文件缓冲区的指针。
// 不同编译器stdio.h头文件中对FILE的定义略有差异，以标准C举例说明：
// typedef struct _iobuf {
//   int cnt;     // 剩余的字符，如果是输入缓冲区，
//                // 那么就表示缓冲区中还有多少个字符未被读取
//   char *ptr;   // 下一个要被读取的字符的地址
//   char *base;  // 缓冲区基地址
//   int flag;    // 读写状态标志位
//   int fd;      // 文件描述符
//   ...          // 其他成员
// } FILE;

// 当从键盘输入数据的时候，数据并不是直接被我们得到，
// 而是放在了缓冲区中，然后从缓冲区中得到我们想要的数据。
// 如果通过setbuf()或setvbuf()函数将缓冲区设置10个字节的大小，
// 而从键盘输入了20个字节大小的数据，这样输入的前10个数据会放在缓冲区中，
// 因为设置的缓冲区的大小只能够装下10个字节大小的数据，
// 装不下20个字节大小的数据。
// 那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。
// 向缓冲区中放入了10个字节大小的数据，FILE结构体中的cnt变为了10，
// 说明此时缓冲区中有10个字节大小的数据可以读。

// 当从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，
// 那么敲入的这个回车键(\r)会被转换为一个换行符\n，
// 这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！
// 比如在键盘上敲下了123456这个字符串，
// 然后敲一下回车键（\r）将这个字符串送入了缓冲区中，
// 那么此时缓冲区中的字节个数是7，而不是6。

// 缓冲区的刷新就是将指针ptr变为缓冲区的基地址，
// 同时cnt的值变为0，因为缓冲区刷新后里面是没有数据的！

int main() { return 0; }