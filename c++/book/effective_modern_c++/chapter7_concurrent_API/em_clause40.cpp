#include <atomic>
#include <iostream>

// 条款40：对并发使用std::atomic，对特种内存使用volatile

// 可怜的volatile，被误解到如此地步。
// 它甚至不应该出现在本章中，因为它与并发程序设计毫无关系。
// 但是在其他程序设计语言中，比如Java和C#，它还是会对并发程序设计有些用处。
// 甚至在C++中，一些编译器也已经把volatile投入到染缸，
// 使得它的语义显得可以用于并发软件中，但是仅可用于使用这些编译器进行编译之时。

// 因此，除了消除环绕在它周围的混淆视听外，没有什么其他的理由在并发中讨论volatile。

// 程序员有时会把volatile与绝对属于本章讨论范围的另一C++特性混淆，那就是atomic模板。
// 该模板的实例，例如，atomic<int>，atomic<bool>和atomic<Widget*>等，
// 提供的操作可以保证被其他线程视为原子的。
// 一旦构造了atomic类型对象，针对它的操作就好像这些操作处于受互斥量保护的临界区域一样，
// 但是实际上这些操作通常会使用特殊的机器指令来实现，这些指令比使用互斥量来的更加高效。

namespace n1 {
void func1() {
  std::atomic<int> ai(0);  // 将ai初始化为0
  ai = 10;                 // 将ai原子值设置为10

  std::cout << ai;  // 原子地读取ai的值
  // 上面语句中，ai是std::atomic这一事实只能保证ai的读取是原子操作。
  // 至于整个语句都以原子方式执行，则没有提供如此保证。
  // 在读取ai和调用operator<<之间，另一个线程可能已经修改了ai的值。
  // 这对语句的行为没有影响，因为整型的operator<<按值传递的int类型的形参来输出，
  // 因此输出的值会是从ai读取的值，重点在于仅ai的读取具备原子行，其他部分没有保证。

  ++ai;  // 原子地将ai自增为11
  --ai;  // 原子地将ai自减为10
  // ai的自增和自减，这两个都是读取-修改-写入操作，read-modify-write，RMW，
  // 但皆以原子方式执行，这是std::atomic类型最棒的特性之一：
  // 一旦构造出std::atomic类型对象，其上所有的成员函数，
  // 包括那些包含RMW操作的成员函数，都保证被其他线程视为原子的。

  // 在这些语句的执行期间，其他读取ai的线程可能只会看到它取值为0、10或11，
  // 而不可能有其他的取值，当然，前提假设这是修改ai值的唯一线程。
}

void func2() {
  volatile int vi(0);  // 将vi初始化为0
  vi = 10;             // 将vi设置为10
  std::cout << vi;     // 读取vi的值
  ++vi;                // 将vi自增为11
  --vi;                // 将vi自减为10

  // 在这段代码的执行期间，如果其他线程正在读取vi的值，它们可能会看到任何值，
  // 例如-12,68,4090727，任何值，这样的代码会出现未定义的行为，
  // 因为这些语句修改了vi，所以如果其他线程同时正在读取vi，
  // 就会出现在既非atomic，也非由互斥量保护的同时读写操作，这就是数据竞争的定义。
}

void func3() {
  // 考虑两者由多个线程执行自增的简单计数器，二者都初始化为0：
  std::atomic<int> ac(0);
  volatile int vc(0);

  // 两个同时运行的线程中将两者各自增一次：
  //  线程1    线程2
  //  ++ac;   ++ac;
  //  ++vc;   ++vc;

  // 当两个线程都完成后，ac的值必定是2，因为每次自增都是作为不可分割的操作出现的。
  // 另一方面，vc的值则不一定是2，因为它的自增可能不会以原子方式发生。
  // 每次自增包括读取vc的值、自增读取的值，并将结果写回vc。
  // 但是这三个操作皆不能保证以原子方式处理volatile对象，
  // 所以可能两次vc自增的组成部分会交错进行，如下所示：
  // 1.线程1读取vc的值，即0；
  // 2.线程2读取vc的值，仍为0；
  // 3.线程1把读取的值0自增为1，并将该值写入vc；
  // 4.线程2把读取的值0自增为1，并将该值写入vc。
  // 这么一来，vc最终的值为1，即使它被实施了两次自增操作。

  // 这不是唯一可能得结果，vc的值一般来说是无法预测的，因为vc涉及数据竞险，
  // 而标准中数据竞险会导致未定义行为，意味着编译器可能会生成代码来做任何事情，
  // 当然，编译器一般不会利用这种保留余地来作什么恶。
  // 可是，它们会执行一些在对于没有数据竞险的程序而言有效的优化，
  // 但这些优化在存在竞险的程序则会产生意想不到的、无法预测的行为。
}
}  // namespace n1

namespace n2 {
// RMW操作的使用并不是唯一让atomic在并发条件下成功，而让volatile失败的情况。

int computeImportantValue() { return 0; }

namespace test1 {
std::atomic<bool> valAvailable(false);

// 假设一个任务负责计算第二个任务所需的重要值。
// 当第一个任务已经计算出该值是，它必须把这个值通信到第二个任务。
// 条款39解释过，要使第一个任务将所需值的可用性传递给第二个任务，
// 有一种方法就是使用std::atomic<bool>。
// 在负责计算的任务中，代码会长成差不多这样：
void func() {
  auto imptValue = computeImportantValue();  // 计算值
  valAvailable = true;                       // 通知其他任务值已可用

  // 程序员都会知道在为valAvailable赋值之前为imptValue赋值这一点至关重要，
  // 但是编译器所能看到的一切，不过是一对针对独立变量实施的赋值操作。
  // 一般地，编译器可以将这些不相关的赋值重新排序。
  // 换言之，给定下面的赋值序列，其中a，b，x和y对应于独立变量，
  // a = b;
  // x = y;
  // 编译器可以径自将其重新排序成下面这样：
  // x = y;
  // a = b;
  // 即使编译器未对它们进行重新排序，底层硬件也可能会这样做，
  // 或者可能会让其他内核将其视为重新排序后的样子，因为这样做有时会使代码运行的更快。

  // 然而，std::atomic类型对象的运用会对代码可以如何重新排序施加限制，
  // 并且这样的限制之一就是，在源代码中，
  // 不得将任何代码提前至后续出现std::atomic类型变量的写入操作的位置，
  // 或使其他内核视作这样的操作会发生，这意味着在我们的代码中，
  // 不仅编译器必须保留为ImptValue和valAvailable的赋值顺序，
  // 它们还必须生成代码以确保底层硬件也保证这个顺序。
  // 因此，将valAvailable声明为atomic类型可以确保关键顺序需求得以保证，
  // imptValue必须被所有线程看到，它是以不晚于valAvailable的时序被更改。
}
}  // namespace test1

namespace test2 {}
// 将valAvailable加上volatile声明，不会给代码实施加同样的重新排序方面的约束：
volatile bool valAvailable(false);

void func() {
  auto imptValue = computeImportantValue();  // 计算值
  valAvailable = true;                       // 通知其他任务值已可用

  // 在这里，编译器可能会将赋值顺序反转为先imptValue后valAvailable，
  // 即使它不这样做，也可能不会生成机器代码阻止：
  // 底层硬件使其他内核上的代码看到valAvailable在imptValue之前发生改变。
}

// 这两个问题解释了为何volatile对于并发编程没用：
// 1.无法保证操作的原子性；
// 2.无法对代码重新排序施加限制。
}  // namespace n2

namespace n3 {
namespace test1 {
// volatile的用处就是告诉编译器，正在处理的内存不具备常规行为。
// 常规内存的特征是：
// 如果向某个内存位置写入了值，该值会一直保留在那里，直到它被覆盖为止。
void func() {
  int x;

  auto y = x;  // 读取x，初始化
  y = x;       // 再次读取x，赋值
  // 编译器可以通过消除对y的赋值操作来优化生成的代码，因为它和y的初始化形成了冗余。

  // 常规内存还具有如下特性：
  // 如果向某内存位置写入某值，其间未读取该内存位置，然后再次写入该内存位置，
  // 则第一次写入可以消除，因为其写入结果从未使用过。
  // 所以，给定下面的两个相邻语句：
  x = 10;  // 写入x
  x = 20;  // 再次写入x
  // 编译器就可以消除第一个操作。

  // 编译器可以径自把这段代码视作像长成下面这样一般：
  // auto y = x;
  // x = 20;
}
// 恐怕你会想，谁会撰写执行如此的冗余读取和多余写入的代码呢？
// 答案是，人类不会直接撰写出如此代码，至少希望没人会这样做吧。

// 但是，即使编译器接受的是看上去合情合理的源代码，
// 对其执行模板实例化、内联以及各种常见的重新排序等优化后，
// 结果中包含编译器能够消除的冗余加载和废弃存储的情况并不罕见。
}  // namespace test1

namespace test2 {
// 特种内存就是另一回事，可能最常见的特种内存是用于内存映射I/O的内存，
// 这种内存的位置实际上是用于与外部设置通信，例如，
// 外部传感器、显示器、打印机和网络端口等，而非用于读取或写入常规内存（RAM）。
void func() {
  int x;

  auto y = x;  // 读取x
  y = x;       // 再次读取x

  // 如果x对应于，比如说，由温度传感器报告的值，则x的第二次读取操作并非多余，
  // 因为第一次和第二次读取之间，温度可能已经改变。

  // 看似多余的写入操作也有类似的情形，比如，这段代码中：
  x = 10;  // 写入x
  x = 20;  // 再次写入x
  // 如果x对应于无线电发射器的控制端口，则有可能是代码在向无线电发出命令，
  // 并且值10对应于值20不同的命令，如果把第一个优化掉，就将改变命令序列了。
}
}  // namespace test2

namespace test3 {
// volatile的用处就是告诉编译器，正在处理的特种内存。
// 它的意思是通知编译器，不要对在此内存上的操作做任何优化。
// 所以，如果x对应于特种内存，则它应该加上volatile声明饰词：
void func() {
  volatile int x;

  auto y = x;  // 读取x
  y = x;       // 再次读取x，不会被优化掉了！

  x = 10;  // 写入x，不会被优化掉了！
  x = 20;  // 再次写入x

  // 如果x是内存映射的或已映射到跨进程共享的内存位置等，这正是想要的效果。
}
}  // namespace test3

namespace test4 {
// 在处理特种内存时必须保留看似冗余加载和废弃存储这一事实，
// 也顺便解释了为何std::atomic类型对象不适用于这种工作，
// 编译器可以消除std::atomic类型上的冗余操作。
// 代码的撰写方式与使用volatile时不尽相同，但是不妨暂时忽略这一点，
// 而先关注编译器允许做的事情，从概念上说，编译器可能接受的是这样的代码：
void func() {
  std::atomic<int> x;
  // auto y = x;  // 概念上会读取x，报错
  // y = x;       // 概念上会再次读取x，报错
  // x = 10;  // 写入x
  // x = 20;  // 再次写入x

  // 并优化成下面这样：
  // auto y = x;  // 概念上会读取x，报错
  // x = 20;      // 写入x

  // std::atomic的赋值操作被删除了，参见条款11，而且这个删除时有充分道理的。
  // 如果考虑从x出发来初始化y能够通过编译的话，会发生什么。
  // 由于x的类型是std::atomic，所以y的类型也会被推导为std::atomic。
  // 之前说过，std::atomic类型对象最好的一点，是他们的所有操作都是原子的。
  // 但是，为了使得从x出发来构造y的操作也成为原子的，
  // 编译器就必须生成代码来在单一的原子操作中读取x并写入y。
  // 硬件通常无法完成这样的操作，所以std::atomic类型不支持复制构造。
  // 出于相同的原因，复制赋值也被删除，这就是为什么从x到y的赋值通不过编译的原因，
  // 由于移动操作没有在atomic中显示声明，根据条款17描述的编译器生成特种函数的规则，
  // std::atomic既不提供移动构造函数，也不提供移动赋值运算符。

  // 从x中取值并置入y是可以实现的，但是要求使用std::atomic的成员函数load和store。
  // load成员函数以原子方式读取std::atomic类型对象的值，
  // 而store成员函数以原子方式读取std::atomic类型对象的值，
  // 而store成员函数以原子方式写入之。
  {  // 如果想先用x初始化y，尔后将x的值置入y，代码必须如下撰写：
    std::atomic<int> y(x.load());  // 读取x
    y.store(x.load());             // 再次读取x
  }
  // 这段代码可以通过编译，但是，读取x是个独立于初始化或存储到y的函数调用清楚地表明，
  // 没有理由去期望这两条语句中的任何一条可以整体作为单一的原子操作执行。

  {  // 编译器可以通过将x的值存储在寄存器中，而不是两次读取，以优化之：
    register int r = x.load();  // 将x读入寄存器
    std::atomic<int> y(r);      // 以寄存器值初始化y
    y.store(r);                 // 将寄存器值存储入y
  }
  // 如果正如你所见，x的读取操作只执行了一次，
  // 这是在处理特种内存时必须避免的那种优化，该优化在volatile变量上不被允许。
}
}  // namespace test4
}  // namespace n3

// 现在事情应该明确了：
// 1.std::atomic对于并发程序设计有用，但不能用于访问特种内存；
// 2.volatile对于访问特种内存有用，但不能用于并发程序设计。

// 由于volatile和std::atomic是用于不同目的，它们甚至可以一起使用：
volatile std::atomic<int> vai;  // 针对vai的操作时原子的，并且不可以被优化
// 如果vai对应于由多个线程同时访问的内存映射I/O位置，就可能会是有用的。

// 最后，有些开发人员更喜欢使用std::atomic的load和store成员函数，
// 即使并非必要，因为这样做可以在源代码中明确表示所涉及的变量并非常规。
// 强调这一事实，也并非没有理由。
// 访问std::atomic类型对象在使用过程中会阻止编译器对某些类型的代码重新排序，
// 而这样的重新排序在其他情况下是被允许的。
// 召唤std::atomic类型对象的加载和存储有助于识别出阻碍潜在的可伸缩性之处。
// 从正确性角度来看，如果本来想要通过某个变量将信息传达到其他线程，
// 却未见它调用store，例如，一个指示数据可用性的标志位，
// 就可能意味着该变量本来应该声明为std::atomic，却没有这样做。

// 这在很大程度上是一个代码风格的问题，因此，
// 这与在std::atomic和volatile之间进行的选择有着非常不同的性质。

// 要记住的东西：
// 1.std::atomic用于多线程访问的数据，且不用互斥量，它是撰写并发软件的工具；
// 2.volatile用于读写操作不可以被优化掉的内存，它是在面对特种内存时使用的工具。

int main() { return 0; }