package main

// Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景,或者是从一个C++语言实现的
// 嵌入式数据库查询记录的场景,或者是使用Fortran语言实现的一些线性代数库的场景。C语
// 言作为一个通用语言,很多库会选择提供一个C兼容的API,然后用其他不同的编程语言实现
// (Go语言需要也应该拥抱这些巨大的代码遗产)。

// 如果是比较小的C语言库,完全可以用纯Go语言重新实现一遍。如果我们对性能也没有
// 特殊要求的话,我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只
// 有当你需要使用复杂而且性能更高的底层C接口时,就是使用cgo的场景了(用os/exec
// 包调用子进程的方法会导致程序运行时依赖那个应用程序)。

// go源码文件中的c语言代码是需要用注释包裹的。
// import "C"这个语句是必须的，而且其与上面的c代码之间不能用空行分隔，必须紧密相连。
// 这里的”C“不是包名，而是一种类似名字空间的概念，或可以理解为伪包，c语言所有语法元素均在该伪包下面。
// 访问c语法元素时都要在其前面加上伪包前缀，比如C.uint和上面代码中的C.print、C.free等。
// cgo提供了#cgo指示符可以指定go源码在编译后与哪些共享库进行链接。

// 与在go中调用c源码相比，在c中使用go函数的场合较少。因为一般来说，采用高级语言作为粘合剂调用低级语言
// 能充分发挥各自的特点，而用低级语言调用高级语言反而有可能降低低级语言的性能优势，在go中，
// 可以使用”export + 函数名“来导出go函数为c代码所用
// go语言可以通过内嵌c代码的形式调用c语言，也可以通过调用共享库函数的方式实现；至于c语言调用go函数，
// 则可以通过go build将go代码编译成共享库提供给c代码使用。

// 要传入C函数的Go指针指向的数据本身不能包含指针或其他引用类型;并且C函数在返回后不能继续持有Go指针;
// 并且在C函数返回之前,Go指针是被锁定的,不能导致对应指针数据被移动或栈的调整

// #cgo CFLAGS: -I./
// #cgo LDFLAGS:-L./ -lhello
// #include <stdio.h>
// #include <stdlib.h>
// #include "hello.h"
/*
void print(char *str) {
    printf("%s\n", str);
}
*/
import "C"
import "unsafe"

func main() {
	s := "Hello Cgo"
	cs := C.CString(s)
	C.print(cs)
	C.free(unsafe.Pointer(cs))

	// export LD_LIBRARY_PATH=/disk/me/examples/golang/unsafe
	C.hello()
}
