#include <stdio.h>

// 事实上，从源代码生成可执行文件可以分为四个步骤，分别是：
// 1.预处理，Preprocessing；
// 2.编译，Compilation；
// 3.汇编，Assembly；
// 4.链接，Linking。
// GCC生成a.out的过程：
//  源代码(.c) ↘
//              预处理(.i) → 编译(汇编代码.s) → 汇编(目标文件.o)   静态库(.a)等
//  头文件(.h) ↗                                     ↘              ↙
//                                                 链接(可执行文件a.out)

// 预处理（Preprocessing）
// 预处理过程主要是处理那些源文件和头文件中以#开头的命令，
// 比如#include、#define、#ifdef等。
// 预处理的规则一般如下：
// 1.将所有的#define删除，并展开所有的宏定义。
// 2.处理所有条件编译命令，比如#if、#ifdef、#elif、#else、#endif等。
// 3.处理#include命令，将被包含文件的内容插入到该命令所在的位置，
//   这与复制粘贴的效果一样。
//   注意，这个过程是递归进行的，也就是说被包含的文件可能还会包含其他的文件。
// 4.删除所有的注释//和/* ... */。
// 5.添加行号和文件名标识，便于在调试和出错时给出具体的代码位置。
// 6.保留所有的#pragma命令，因为编译器需要使用它。
// 预处理的结果是生成.i文件。
// .i文件也是包含C语言代码的源文件，只不过所有的宏已经被展开，
// 所有包含的文件已经被插入到当前文件中。
// 当无法判断宏定义是否正确，或者文件包含是否有效时，可以查看.i文件来确定问题。
// 在GCC中，可以通过下面的命令生成.i文件：
// $gcc -E demo.c -o demo.i
// -E表示只进行预编译。

// 编译（Compilation）
// 编译就是把预处理完的文件进行一些列的词法分析、
// 语法分析、语义分析以及优化后生成相应的汇编代码文件。
// 编译是整个程序构建的核心部分，也是最复杂的部分之一，涉及到的算法较多。
// 在GCC中，可以使用下面的命令生成.s文件：
// $gcc -S demo.i -o demo.s
// 或者：
// $gcc -S demo.c -o demo.s

// 汇编（Assembly）
// 汇编的过程就是将汇编代码转换成可以执行的机器指令。
// 大部分汇编语句对应一条机器指令，有的汇编语句对应多条机器指令。
// 汇编过程相对于编译来说比较简单，没有复杂的语法，也没有语义，
// 也不需要做指令优化，只是根据汇编语句和机器指令的对照表一一翻译就可以了。
// 汇编的结果是产生目标文件，
// 在GCC下的后缀为.o，在Visual Studio下的后缀为.obj。

// 链接（Linking）
// 目标文件已经是二进制文件，与可执行文件的组织形式类似，
// 只是有些函数和全局变量的地址还未找到，程序不能执行。
// 链接的作用就是找到这些目标地址，
// 将所有的目标文件组织成一个可以执行的二进制文件。

// 预处理和汇编的过程都比较简单，编译的过程最为复杂，
// 可以细分为词法分析、语法分析、语义分析和指令优化，
// 这里涉及到诸多算法以及正则表达式。
// 而目标文件的结构、可执行文件的结构、
// 链接的过程能够明白多文件编程以及模块化开发的原理，
// 这是大型项目开发的基石。
// 最后需要说明的是：
// 汇编的过程非常简单，仅仅是查表翻译，
// 通常把它作为编译过程的一部分，不再单独提及。
// 这样，源文件经过预处理、编译和链接就生成了可执行文件。

// 从文件结构上来讲，目标文件已经是二进制文件，
// 它与可执行文件的组织形式非常类似，
// 只是有些变量和函数的地址还未确定，程序不能执行。
// 链接的一个重要作用就是找到这些变量和函数的地址。
// 另外需要明确的是：
// 编译是针对单个源文件的，有几个源文件就会生成几个目标文件，
// 并且在生成过程中不受其他源文件的影响。
// 也就是说，不管当前工程中有多少个源文件，
// 编译器每次只编译一个源文件、生成一个目标文件。

// Windows和Linux下的文件格式
// 现在PC平台上流行的可执行文件格式主要是：
// 1.Windows下的PE，Portable Executable；
// 2.Linux下的ELF，Executable Linkable Format。
// 它们都是COFF（Common File Format）格式的变种。
// COFF是Unix V3首先提出的规范，
// 微软在此基础上制定了PE格式标准，并将它用于Windows。
// 后来Unix V4又在COFF的基础上引入了ELF格式，被Linux广泛使用。
// 这也就是为什么Windows和Linux上的可执行文件如此相似的主要原因，
// 因为它们都是源于同一种可执行文件格式COFF。
// 从广义上讲，目标文件与可执行文件的存储格式几乎是一样的，
// 可以将它们看成是同一种类型的文件，
// 在Windows下，将它们统称为PE文件，在Linux下，将它们统称为ELF文件。
// 另外，动态链接库和静态链接库也是按照可执行文件的格式存储的。
// 静态链接库稍有不同，它是把多个目标文件捆绑在一起形成一个文件，
// 再加上一些索引，你可以简单地把它理解为一个包含了很多目标文件的包。
// 其他不太常见的可执行文件格式还有：
// Intel/Microsoft的OMF（Object Module Format）、
// Unix a.out、MS-DOS .COM等。

// 在Linux的ELF标准中，主要包含以下四类文件：
// 1.可重定位文件Relocatable File，
//   Linux下的.o和.a，Windows下的.obj和.lib。
//   包含了代码和数据，可以被用来链接成为可执行文件或动态链接库。
//   静态链接库其实也是可重定位文件。
// 2.可执行文件Executable File，Windows下的.exe，
//   Linux下的可执行文件没有固定的后缀，一般不写。
//   包含了可以直接执行的程序。
// 3.共享目标文件Shared Object File，Linux下的.so，Windows下的.dll。
//   包含了代码和数据，可以在以下两种情况下使用：
//   一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，
//   产生新的目标文件；
//   第二种是动态连接器可以将几个共享目标文件与可执行文件结合，
//   作为进程的一部分来运行。
// 4.核心转储文件Core Dump File，Linux下的core dump。
//   当进程意外终止时，
//   系统可以将该进程的地址空间的内容以及其他信息保存到核心转储文件。

// Linux GCC生成的目标文件的格式：
//  ELF Header(文件头)
//  .text(代码段)
//  .rel.text(重定位段)
//  .data(数据段)
//  .rel.data(重定位段)
//  .rodata(只读数据段)
//  .comment(注释信息)
//  .debug(调试信息)
//  .line(行号)
//  Section Table(段表)
//  .strtab(String Table，字符串表)
//  .symtab(Symbol Table，符号表)
//  Other Data(其他数据)
// 段名大都以.作为前缀，表示这些名字是系统保留的。
// 下面是对各个部分的说明：
// 1.ELF Header，文件头，描述了整个目标文件的属性，
//   包括是否可执行、是动态链接还是静态链接、入口地址是什么、
//   目标硬件、目标操作系统、段表偏移等信息。
// 2.text，代码段，存放编译后的机器指令，也即各个函数的二进制代码。
//   一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。
// 3.data，数据段，存放全局变量和静态变量。
// 4.rodata，只读数据段，存放一般的常量、字符串常量等。
// 5.rel.data .rel.text.，重定位段，
//   包含了目标文件中需要重定位的全局符号以及重定位入口。
// 6.comment，注释信息段，存放的是编译器的版本信息，比如GCC:(GUN) 4.2.0。
// 7.debug，调试信息。
// 8.line，调试时的行号表，即源代码行号与编译后指令的对应表。
// 9.Section Table，段表，描述了ELF文件包含的所有段的信息，
//   比如段的名字、段的长度、在文件中的偏移、读写权限以及其他属性。
//   可以说，ELF文件的段结构是由段表来决定的，
//   编译器、链接器和装载器都是依靠段表来定位和访问各个段的。
// 10.strtab，字符串表，保存了ELF文件用到的字符串，比如变量名、函数名、段名等。
//    因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难，
//    常见的做法就是把字符串集中起来存放到一个表中，
//    然后使用字符串在表中的偏移来引用字符串。
// 11.symtab,符号表，保存了全局变量名、局部变量名、函数名等在字符串表中的偏移。
// 除了这些系统保留的段名，应用程序也可以使用其它名字定义自己的段，
// 比如可以在ELF文件中插入一个叫做music的段来保存MP3音乐。
// 应用程序自定义的的段不建议使用.作为前缀，否则容易和系统保留段发生冲突。

// 可执行文件的组织形式和目标文件非常类似，也被划分成多个部分:
//  ELF Header(文件头)                      ------
//  Program Header Table(程序头表)
//  .init                                  程序代码区
//  .text(代码段)
//  __libc_freeres_fn
//  .fini                                  ------
//  .rodata(只读数据段)                      常量区(一般常量、字符串常量)
//  __libc_subfreeers                      ------
//  __libc_atexit
//  .tdata                                  全局数据区(全局变量、静态变量)
//  .ctors
//  .dtors
//  .data(数据段)                            ------
//  .comment(注释信息)
//  .debug(调试信息)
//  .line(行号)
//  .strtab(String Table，字符串表)
//  .symtab(Symbol Table，符号表)
//  Other Data(其他数据)

// 总体来说，目标文件包含了10个左右的段，而可执行文件包含了将近30个左右的段。
// 操作系统并不是为每个段都分配一个区域，
// 而是将多个具有相同权限的段合并在一起，加载到同一个区域。
// 站在文件结构的角度，可执行文件包含了众多的段，每个段都有不同的作用；
// 站在加载和执行的角度，所有的段都是数据，操作系统只关心数据的权限，
// 只要把相同权限的数据加载到同一个内存区域，程序就能正确执行。
// 常见的数据权限无外乎三种：只读（例如.rodata只读数据段）、
// 读写（例如.data数据段）、读取和执行（例如.text代码段），
// 将一块连续的、具有相同权限的数据称为一个Segment，
// 一个Segment由多个权限相同的Section构成。
// 不巧的是，Segment也被翻译为段，但这里的段是针对加载和执行的过程。
// 在目标文件中，段表（Section Table）用来描述各个Section的信息，
// 包括它的名字、长度、在文件中的偏移、读写权限等，
// 通过段表可以详细地了解目标文件的结构。
// 而在可执行文件中，段表被删除了，取代它的是程序头表（Program Header Table）；
// 程序头表用来描述各个Segment的信息，包括它的类型、偏移、
// 在进程虚拟地址空间中的起始地址、物理装载地址、长度、权限等。
// 操作系统就是根据程序头表将可执行文件加载到内存，
// 并为各个Segment分配内存空间、确定起止地址。
// 也就是说，可执行文件不再关注具体的文件结构，而是关注程序的加载和执行过程。
// 由于可执行文件在加载时实际上是被映射的虚拟地址空间，
// 所以可执行文件很多时候又被叫做映像文件（Image）。

// 段（Section）的合并
// 编译器生成的是目标文件，而最终需要的是可执行文件，
// 链接（Linking）的作用就是将多个目标文件合并成一个可执行文件。
// 在链接过程中，链接器会将多个目标文件中的代码段、
// 数据段、调试信息等合并成可执行文件中的一个段。
// 段的合并仅仅是一个简单的叠加过程。
// 除了合并有用的段（例如代码段、数据段等），
// 链接器还会删除多余的段（例如重定位段、段表等），增加其他段（例如程序头表等）。

// 编译器和链接器的一项重要任务就是将助记符替换成地址。
// 符号（Symbol）这个概念随着汇编语言的普及被广泛接受，它用来表示一个地址，
// 这个地址可能是一段子程序（后来发展为函数）的起始地址，也可以是一个变量的地址。
// C语言是比汇编更加高级的编程语言，极大地提高了开发效率，
// 以加法为例，C语言只需要一条语句，汇编却需要四五条。
// 在C语言中，一个模块可以认为是一个源文件（.c文件）。
// 在程序被分隔成多个模块后，
// 需要解决的一个重要问题是如何将这些模块组合成一个单一的可执行程序。
// 在C语言中，模块之间的依赖关系主要有两种：
// 一种是模块间的函数调用，另外一种是模块间的变量访问。
// 函数调用需要知道函数的首地址，变量访问需要知道变量的地址，
// 所以这两种方式可以归结为一种，那就是模块间的符号引用。
// 这种通过符号将多个模块拼接为一个独立的程序的过程就叫做链接（Linking）。

// 符号
// 链接的主要内容就是把各个模块之间的相互引用部分处理好，
// 使得各个模块能够正确地衔接。
// 链接器所做的主要工作跟前面提到的人工调整地址本质上没有什么两样，
// 只不过现代的高级语言拥有诸多的特性，使得编译器和链接器更为复杂，
// 功能更为强大，但从原理上来讲，无非是找到符号的地址，
// 或者把指令中使用到的地址加以修正。
// 这个过程称为符号决议（Symbol Resolution）或者重定位（Relocation）。
// 假设一个程序有两个模块main.c和module.c，在module.c中定义了函数func()，
// 并在main.c中进行了多次调用，当所有模块被编译成一个可执行文件后，
// 对func()函数的调用都会被替换为一个绝对地址。
// 但由于每个模块都是单独编译的，编译器在处理main.c时并不知道func()的地址，
// 所以需要把这些调用func()的指令的目标地址搁置，
// 等到最后链接的时候再由链接器将这些地址修正。
// 有了链接器，可以直接调用其他模块中的函数而无需知道它们的地址，
// 因为在链接的时候，链接器会根据符号func自动去module.c模块查找func的地址，
// 然后将main.c模块中所有使用到func的指令重新修正，
// 让它们的目标地址成为真正的func()函数的地址。
// 这种在程序运行之前确定符号地址的过程叫做静态链接（Static Linking）；
// 如果需要等到程序运行期间再确定符号地址，就叫做动态链接（Dynamic Linking）。
// dll或so必须要嵌入到可执行程序、作为可执行程序的一部分运行，
// 它们所包含的符号的地址就是在程序运行期间确定的，
// 称为动态链接库（Dynamic Linking Library）。
// 变量和函数一样，都是符号，都需要确定它的地址。
// 这种地址修正的过程就是前面提到的重定位，
// 每个需要被修正的地方叫做一个重定位入口（Relocation Entry）。
// 重定位所做的工作就是给程序中每个这样的绝对地址引用的位置打补丁，
// 使它们指向正确的地址。
// 函数和变量在本质上是一样的，都是地址的助记符，
// 在链接过程中，它们被称为符号（Symbol）。
// 链接器的一个重要任务就是找到符号的地址，并对每个重定位入口进行修正。
// 可以将符号看做是链接中的粘合剂，整个链接过程正是基于符号才能正确完成。
// 符号表（Symbol Value），它的段名是.symtab。
// 符号表记录了当前目标文件用到的所有符号，包括：
// 1.全局符号，也就是函数和全局变量，它们可以被其他目标文件引用。
// 2.外部符号（External Symbol），也就是在当前文件中使用到、
//   却没有在当前文件中定义的全局符号。
// 3.局部符号，也就是局部变量。它们只在函数内部可见，
//   对链接过程没有作用，所以链接器往往也忽略它们。
// 4.段名，这种符号往往由编译器产生，它的值就是该段的起始地址，
//   比如.text、.data等。
// 对链接来说，最值得关注的是全局符号，
// 也就是上面的第一类和第二类，其它符号都是次要的。
// 所有的符号都保存在符号表.symtab(结构体数组)中，
// 每个元素都包含了一个符号的信息，包括符号名、符号在段中的偏移、
// 符号大小（符号所占用的字节数）、符号类型等。
// 确切地说，真正的符号名字是保存在字符串表.strtab中的，
// 符号表仅仅保存了当前符号在字符串表中的偏移。

// 符号决议（Symbol Resolution）
// 当要进行链接时，链接器首先扫描所有的目标文件，
// 获得各个段的长度、属性、位置等信息，
// 并将目标文件中的所有（符号表中的）符号收集起来，统一放到一个全局符号表。
// 在这一步中，链接器会将目标文件中的各个段合并到可执行文件，
// 并计算出合并后的各个段的长度、位置、虚拟地址等。
// 在目标文件的符号表中，保存了各个符号在段内的偏移，生成可执行文件后，
// 原来各个段（Section）起始位置的虚拟地址就确定了下来，
// 这样，使用起始地址加上偏移量就能够得到符号的地址（在进程中的虚拟地址）。
// 这种计算符号地址的过程被称为符号决议（Symbol Resolution）。
// 重定位表.rel.text和.rel.data中保存了需要重定位的全局符号以及重定位入口，
// 完成了符号决议，链接器会根据重定位表调整代码中的地址，使它指向正确的内存位置。
// 至此，可执行文件就生成了，链接器完成了它的使命。

// 全局变量和局部变量
// 当程序被加载到内存后，全局变量要在数据区（全局数据区）分配内存，
// 局部变量要在栈上分配内存。
// 数据区在程序运行期间一直存在，全局变量的位置不会改变，地址也是固定的，
// 所以在链接时就能够计算出全局变量的地址。
// 而栈区内存会随着函数的调用不断被分配和释放，局部变量的地址不能预先计算，
// 必须等到发生函数调用时才能确定，所以链接过程会忽略局部变量。
// 关于局部变量的定位，就是ebp加上偏移量，
// 这在编译阶段就能给出计算公式（一条简单的语句），
// 程序运行后，只要执行这条语句，就能够得到局部变量的地址。
// 总结起来，链接的一项重要任务就是确定函数和全局变量的地址，
// 并对每一个重定位入口进行修正。

int main() { return 0; }