#include <iostream>

using namespace std;

// 慎重选择容器类型

// 标准STL序列容器：vector、string、deque和list。
// 标准STL关联容器：set、multiset、map和multimap。
// 非标准序列容器slist和rope。slist是一个单向链表，rope本质上是一“重型”string。
// 非标准的关联容器hash_set、hash_multiset、hash_map和hash_multimap。
// vector<char>作为string的替代。
// vector作为标准关联容器的替代。
// 几种标准的非STL容器，包括数组、bitset、valarray、stack、queue和priority_queue。

// C++标准就“如何在vector、deque和list中选择”提供了如下建议：
// vector、deque和list提供了不同的复杂性，使用时要对此做出权衡。
// vector是默认应使用的序列类型；
// 当需要频繁地在序列中间做插入和删除操作时，应使用list；
// 当大多数插入和删除操作发生在序列的头部和尾部时，deque是应考虑的数据结构。

// 连续内存容器（或称为基于数组的容器）把它的元素存放在一块或多块（动态分配的）内存中，每块内存中存有多个元素。
//  新元素被插入或已有元素被删除时，需要移动元素，这种移动影响效率和异常安全性。
//  vector、string、deque和非标准的rope都是连续内存容器。
// 基于节点的容器在每一个（动态分配的）内存块中只存放一个元素。插入和删除只影响到指向节点的指针，不影响节点本身，不需要移动节点。
//  list、slist、所有标准的关联容器、非标准的哈希容器都使用基于节点的实现。

// 是否关心容器中的元素是如何排序的？如果不关心，则哈希容器是一个可行的选择方案；否则，要避免哈希容器。
// 必须是标准容器么？如果必须是，排除哈希容器、slist和rope。
// 需要哪种类型的迭代器？必须是随机的，则只能是vector、deque和string。如果要使用双向迭代器，必须避免slist和哈希容器的一个常见实现。
// 当发送插入时，避免移动是否重要？如果是，要避免连续内存的容器。
// 容器中数据布局是否需要和C兼容？如果需要，就智能选择vector。
// 元素查找速度是否是关键的考虑因素？如果是，就要考虑哈希容器、排序的vector和标准关联容器，或许这就是优先顺序。
// 如果容器内部使用了引用计数技术，是否介意？如果是，避免使用string和rope。可以考虑vector<char>。
// 对插入和删除操作，需要事物语义么？也就是说，在插入和删除失败时，需要回滚能力吗？
//  如果需要，使用基于节点的容器。
//  如果对多个元素的插入操作需要事物语义，需要选择list，只有list对多个元素的插入操作提供了事物语义。
//  对希望编写异常安全代码的人来说，事物语义显得尤为重要。
//  使用连续内存的容器也可以获得事物语义，但是性能代价很大，也不直截了当。
// 需要使用迭代器、指针和引用变为无效的次数最少么？
//  如果是，使用基于节点的容器，插入和删除从来不会使迭代器、指针和引用失效。
//  连续内存的插入和删除通常会导致代器、指针和引用失效。
// 如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，则指向数据的指针和引用就不会失效，这样的容器是否有帮助？
//  如果是，选择deque。当插入仅在容器末尾发生时，deque的迭代器有可能失效。deque是唯一的、迭代器可能失效而指针和引用不会失效的STL标准容器。

int main() { return 0; }