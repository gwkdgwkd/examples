#include <iostream>
#include <iterator>
#include <list>
#include <vector>

// 无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，
// 而实现此操作，多数情况会选用迭代器（iterator）来实现。
// 尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，
// 换句话说，都是一串能存储多个数据的存储单元。
// 因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。

// 既然类似，完全可以利用泛型技术，
// 将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。
// 但实现此目的需要有一个类似中介的装置，
// 它除了要具有对容器进行遍历读写数据的能力之外，
// 还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。
// 简单来讲，迭代器和C++的指针非常类似，它可以是需要的任意类型，
// 通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。

// STL标准库为每一种标准容器定义了五种迭代器类型，
// 这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。
// 容器的迭代器的功能强弱，决定了该容器是否支持STL中的某种算法。
// 常用的迭代器按功能强弱分为：
// 输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器5种。
// 1.输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，
//   而是把输入流/输出流作为操作对象。
// 2.前向迭代器（forward iterator）
//   假设p是一个前向迭代器，则p支持++p，p++，*p操作，
//   还可以被复制或赋值，可以用==和!=运算符进行比较。
//   此外，两个前向迭代器可以互相赋值。
// 3.双向迭代器（bidirectional iterator）
//   双向迭代器具有正向迭代器的全部功能，除此之外，
//   假设p是一个双向迭代器，则还可以进行--p或者p--操作。
// 4.随机访问迭代器（random access iterator）
//   随机访问迭代器具有双向迭代器的全部功能。
//   除此之外，假设p是一个随机访问迭代器，
//   i是一个整型变量或常量，则p还支持以下操作：
//   p+=i：使得p往后移动i个元素。
//   p-=i：使得p往前移动i个元素。
//   p+i：返回p后面第i个元素的迭代器。
//   p-i：返回p前面第i个元素的迭代器。
//   p[i]：返回后面第i个元素的引用。
//   此外，两个随机访问迭代器p1、p2还可以用<、>、<=、>=运算符进行比较。
//   另外，表达式p2-p1也是有定义的，
//   其返回值表示p2所指向元素和p1所指向元素的序号之差，
//   也可以说是p2和p1之间的元素个数减1。

// C++11标准中不同容器指定使用的迭代器类型：
//  array 	                          随机访问迭代器
//  vector 	                          随机访问迭代器
//  deque 	                          随机访问迭代器
//  list 	                            双向迭代器
//  set/multiset 	                    双向迭代器
//  map/multimap 	                    双向迭代器
//  forward_list 	                    前向迭代器
//  unordered_map/unordered_multimap 	前向迭代器
//  unordered_set/unordered_multiset 	前向迭代器
//  stack 	                          不支持迭代器
//  queue 	                          不支持迭代器
//  priority_queue                    不支持迭代器

// 尽管不同容器对应着不同类别的迭代器，
// 但这些迭代器有着较为统一的定义方式，具体分为4种:
// 1.正向迭代器 	               容器类名::iterator 迭代器名;
// 2.常量正向迭代器 	            容器类名::const_iterator 迭代器名;
// 3.反向迭代器（反向迭代器适配器）  容器类名::reverse_iterator 迭代器名;
// 4.常量反向迭代器 	            容器类名::const_reverse_iterator 迭代器名;
// 通过定义以上几种迭代器，就可以读取它指向的元素，
// *迭代器名就表示迭代器指向的元素。
// 其中，常量迭代器和非常量迭代器的分别在于，
// 通过非常量迭代器还能修改其指向的元素。
// 另外，反向迭代器和正向迭代器的区别在于：
// 1.对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素；
// 2.而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。
// 以上4种定义迭代器的方式，并不是每个容器都适用。
// 有一部分容器同时支持以上4种方式，比如array、deque、vector；
// 而有些容器只支持其中部分的定义方式，
// 例如forward_list容器只支持定义正向迭代器，不支持定义反向迭代器。

int main() {
  std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  // vector支持随机访问迭代器，因此遍历vector容器有以下几种做法：
  // 1.像普通数组一样使用vector容器,size返回元素个数
  for (int i = 0; i < v.size(); ++i) {
    std::cout << v[i] << " ";
  }
  std::cout << std::endl;  // 1 2 3 4 5 6 7 8 9 10

  // 2.创建一个正向迭代器，当然，vector也支持其他3种定义迭代器的方式
  std::vector<int>::iterator i;  // 用!=比较两个迭代器
  for (i = v.begin(); i != v.end(); ++i) {
    std::cout << *i << " ";
  }
  std::cout << std::endl;  // 1 2 3 4 5 6 7 8 9 10

  // 3.用<比较两个迭代器
  for (i = v.begin(); i < v.end(); ++i) {
    std::cout << *i << " ";
  }
  std::cout << std::endl;  // 1 2 3 4 5 6 7 8 9 10

  // 4.
  i = v.begin();
  while (i < v.end()) {  // 间隔一个输出
    std::cout << *i << " ";
    i += 2;  // 随机访问迭代器支持+=整数的操作
  }
  std::cout << std::endl;  // 1 3 5 7 9

  std::list<int> l{1, 2, 3, 4, 5};  // list容器的迭代器是双向迭代器
  std::list<int>::const_iterator ci;  // 创建一个常量正向迭代器
  for (ci = l.begin(); ci != l.end(); ++ci) {
    std::cout << *ci << " ";
  }
  std::cout << std::endl;  // 1 2 3 4 5

  // 以下代码则不合法，因为双向迭代器不支持用<进行比较：
  // for (ci = l.begin(); ci < l.end(); ++ci) {
  //   std::cout << *ci << " ";
  // }

  // 以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：
  // for (int i = 0; i < vv.size(); ++i) {
  //   std::cout << l[i] << " ";
  // }

  // 其实在C++中，数组也是容器。
  // 数组的迭代器就是指针，而且是随机访问迭代器。
  // 例如，对于数组int a[10]，int*类型的指针就是其迭代器。
  // 则a、a+1、a+2都是a的迭代器。

  return 0;
}