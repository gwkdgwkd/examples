#include <stdio.h>

// 插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。
// 而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要用到本章介绍的外部排序算法来解决。
// 外部排序算法由两个阶段构成：
//  1 按照内存大小，将大文件分成若干长度为l的子文件（l应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为
//    “归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；
//  2 对得到的顺段进行合并，直至得到整个有序的文件为止。

// 对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。
// 对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多。
// 对于k-路平衡归并中k值得选择，增加k可以减少归并的次数，从而减少外存读写的次数，最终达到提高算法效率的目的。
// 除此之外，一般情况下对于具有m个初始归并段进行k-路平衡归并时，归并的次数为：s=⌊logk⁡m⌋（其中s表示归并次数）。
// 从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
//  增加k-路平衡归并中的k值；
//  尽量减少初始归并段的数量m，即增加每个归并段的容量；
// 其增加k值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量m的想法引申出了另一种外部排序算法：置换-选择排序算法。

// 无论是通过等分还是置换-选择排序得到的归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低？
// 操作外存的次数恰好是树的带权路径长度的2倍。所以，对于如何减少访问外存的次数的问题，就等同于考虑如何使k-路归并所构成的k叉树的带权路径长度最短。
// 若想使树的带权路径长度最短，就是构造赫夫曼树。
// 通过以构建赫夫曼树的方式构建归并树，使其对读写外存的次数降至最低（k-路平衡归并，需要选取合适的k值，构建赫夫曼树作为归并树）。所以称此归并树为最佳归并树。
// 在一般情况下，对于k–路平衡归并来说，若(m-1)MOD(k-1)=0，则不需要增加虚段；否则需附加k-(m-1)MOD(k-1)-1个虚段。
// 实现外部排序的两个过程：
//  将整个初始文件分为多个初始归并段;
//  将初始归并段进行归并，直至得到一个有序的完整文件；
// 为了提高整个外部排序的效率，分别从以上两个方面对外部排序进行了优化：
//  在实现将初始文件分为m个初始归并段时，为了尽量减小m的值，采用置换-选择排序算法，可实现将整个初始文件分为数量较少的长度不等的初始归并段。
//  同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用构建最佳归并树的方式，对初始归并段进行归并，而归并的具体实现方法是采用败者树的方式。
