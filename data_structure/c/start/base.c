#include <stdio.h>

// 数据结构，直白地理解，就是研究数据的存储方式。
// 数据在计算机存储空间的存放，决不是胡乱的，这就要求选择一种好的方式来存储数据，而这也是数据结构的核心内容。
// 数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。

// 数据结构大致包含以下几种存储结构：
//  线性表，还可细分为顺序表、链表、栈和队列；
//  树结构，包括普通树，二叉树，线索二叉树等；
//  图存储结构；

// 具备“一对一”关系的数据就可以使用线性表来存储。线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。
//  顺序表，简单地理解，就是常用的数组，只是换了个名字而已。
//  使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的。
//  链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。
//  栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。
//  栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。
//  队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。
// 树存储结构适合存储具有“一对多”关系的数据。
// 图存储结构适合存储具有“多对多”关系的数据。

// 数据的存储方式可分为线性表、树和图三种存储结构，而每种存储结构又可细分为顺序存储结构和链式存储结构。
// 数据存储方式如此之多，针对不同类型的数据选择合适的存储方式是至关重要的。数据存储结构的选择取决于两方面，即数据的逻辑结构和存储结构（又称物理结构）。
// 数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。
// 数据之间的逻辑关系可细分为三类，“一对一”、“一对多”和“多对多”：
//  线性表用于存储具有“一对一”逻辑关系的数据；
//  树结构用于存储具有“一对多”关系的数据；
//  图结构用于存储具有“多对多”关系的数据；
// 由此，可以通过分析数据之间的逻辑关系来决定使用哪种存储结构，但具体使用顺序存储还是链式存储，还要通过数据的物理结构来决定。
// 数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。
// 集中存储（底层实现使用的是数组）需要使用一大块连续的物理空间，假设要存储大小为1G的数据，若存储设备上没有整块大小超过1G的空间，就无法使用顺序存储，
// 此时就要选择链式存储，因为链式存储是随机存储数据，占用的都是存储设备中比较小的存储空间，因此有一定几率可以存储成功。
// 数据的用途不同，选择的存储结构也不同。将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。因此，如果后期需要对数
// 据进行大量的检索（遍历），就选择集中存储；反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。

// 所谓算法，即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但耗费的时间和资源肯定有所差异。
// 解决一个问题的方法可能有很多，但能称得上算法的，首先它必须能彻底解决这个问题（称为准确性），且根据其编写出的程序在任何情况下都不能崩溃（称为健壮性）。
// 在满足准确性和健壮性的基础上，还有一个重要的筛选条件，即通过算法所编写出的程序的运行效率。程序的运行效率具体可以从2个方面衡量，分别为：
//  程序的运行时间。
//  程序运行所需内存空间的大小。
// 根据算法编写出的程序，运行时间更短，运行期间占用的内存更少，该算法的运行效率就更高，算法也就更好。
// 数据结构中，用时间复杂度来衡量程序运行时间的多少；用空间复杂度来衡量程序运行所需内存空间的大小。

// 时间复杂度
// 表示一个算法所编程序运行时间的多少，用的并不是准确值（事实上也无法得出），而是根据合理方法得到的预估值。
// 先分别计算程序中每条语句的执行次数，然后用总的执行次数间接表示程序的运行时间。
// 数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。
// 不同程序的运行时间，更多场景中比较的是在最坏条件下程序的运行时间。
// 在数据结构中，频度表达式可以这样简化：
//  去掉频度表达式中，所有的加法常数式子。例如2n2+2n+1简化为2n2+2n；
//  如果表达式有多项含有无限大变量的式子，只保留一个拥有指数最高的变量的式子。例如2n2+2n简化为2n2；
//  如果最高项存在系数，且不为1，直接去掉系数。例如2n2系数为2，直接简化为n2；
// 事实上，对于一个算法（或者一段程序）来说，其最简频度往往就是最深层次的循环结构中某一条语句的执行次数。
// 数据结构推出了大O记法（注意，是大写的字母O，不是数字0）来表示算法（程序）的运行时间。发展至今，此方法已为大多数人所采纳:
//  O(频度)  这里的频度为最简之后所得的频度。
// 常用的几种时间复杂度，以及它们之间的大小关系：
//  O(1)常数阶<O(logn)对数阶<O(n)线性阶<O(n^2)平方阶<O(n^3)(立方阶)<O(2^n)(指数阶)
// 而在某些实际场景中，还可以用最好情况下的频度和最坏情况下的频度的平均值来作为算法的平均时间复杂度。

// 空间复杂度
// 和时间复杂度类似，一个算法的空间复杂度，也常用大O记法表示。
// 要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，例如：
//  程序代码本身所占用的存储空间；
//  程序中如果需要输入输出数据，也会占用一定的存储空间；
//  程序在运行过程中，可能还需要临时申请更多的存储空间。
// 首先，程序自身所占用的存储空间取决于其包含的代码量，如果要压缩这部分存储空间，就要求我们在实现功能的同时，尽可能编写足够短的代码。
// 程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。
// 事实上，对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间。不同的算法所编写出的程序，其运行时申请的临时存储空间通常会有较大不同。
// 如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为O(1)；反之，如果有关，则需要进一步判断它们之间的关系：
//  如果随着输入值n的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用O(n)表示;
//  如果随着输入值n的增大，程序申请的临时空间成n^2关系增长，则程序的空间复杂度用O(n^2)表示；
//  如果随着输入值n的增大，程序申请的临时空间成n^3关系增长，则程序的空间复杂度用O(n^3)表示；
// 在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。

// 数据结构和算法之间完全是两个相互独立的学科，如果非说它们有关系，那也只是互利共赢、“1+1>2”的关系。
// 从分析问题的角度去理清数据结构和算法之间的关系。通常，每个问题的解决都经过以下两个步骤：
//  分析问题，从问题中提取出有价值的数据，将其存储；
//  对存储的数据进行处理，最终得出问题的答案；
// 数据结构负责解决第一个问题，即数据的存储问题。针对数据不同的逻辑结构和物理结构，可以选出最优的数据存储结构来存储数据。
// 而剩下的第二个问题，属于算法的职责范围。算法，从表面意思来理解，即解决问题的方法。评价一个算法的好坏，取决于在解决相同问题的前提下，哪种算法的效率最高，
// 而这里的效率指的就是处理数据、分析数据的能力。
// 因此得出这样的结论，数据结构用于解决数据存储问题，而算法是思考如何利用存储的数据快速无误地解决问题，它们是完全不同的两类学科。

// 学习数据结构和算法有一个很重要的前提，就是至少熟练掌握一门编程语言。学习数据结构和算法，实践是非常重要的，如果仅仅是空有理论而不实践，反复学多少遍都没用。
// 总的来说，数学基础不是学习数据结构的必备条件，但好的数据基础对学习数据结构大有助益。

int main() { return 0; }