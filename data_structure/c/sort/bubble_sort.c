#include <stdio.h>

// 冒泡排序是所有排序算法中最简单、最易实现的算法，有时也称为起泡排序算法。
// 该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。

// 使用冒泡排序算法对n个数据进行排序，实现思路是：
// 从待排序序列中找出一个最大值或最小值，这样的操作执行n-1次，最终就可以得到一个有序序列。
// 举个例子，对{14, 33, 27, 35, 10}序列进行升序排序（由小到大排序），冒泡排序算法的实现过程是：
//  从{14, 33, 27, 35, 10}中找到最大值35；
//  从{14,33,27,10}中找到最大值33；
//  从{14, 27, 10}中找到最大值27；
//  从{14, 10}中找到最大值14；
// 通过一趟趟的比较，一个个的“最大值”被找到并移动到相应位置，
// 直到检测到表中数据已经有序，或者比较次数等同于表中含有记录的个数，排序结束，这就是起泡排序。
// 整个查找最大值的过程中，最大的元素就像水里的气泡一样，一点一点地“冒”了出来，这也是将该算法命名为冒泡排序算法的原因。

// 使用起泡排序算法，其时间复杂度同实际表中数据的无序程度有关:
//  若表中记录本身为正序存放，则整个排序过程只需进行n-1（n为表中记录的个数）次比较，且不需要移动记录；
//  若表中记录为逆序存放（最坏的情况），则需要n-1趟排序，进行n(n-1)/2次比较和数据的移动。
// 所以该算法的时间复杂度为O(N^2)。

void print(int *list, int size) {
  for (int i = 0; i < size; i++) {
    printf("%d ", list[i]);
  }
  printf("\n");
}

void BubbleSort(int *list, int size) {
  int i, j;
  int temp = 0;

  for (i = 0; i < size - 1; i++) {  // size个元素，遍历size-1次
    for (j = 0; j < size - 1 - i; j++) {  // 从第1个元素开始遍历，遍历至size-1-i
      if (list[j] > list[j + 1]) {  //比较list[j]和list[j+1]的大小
        // 交换2个元素的位置
        temp = list[j];
        list[j] = list[j + 1];
        list[j + 1] = temp;
      }
    }
  }
}

int main() {
  int array[] = {49, 38, 65, 97, 76, 13, 27, 49};
  print(array, sizeof(array) / sizeof(int));  // 49 38 65 97 76 13 27 49

  BubbleSort(array, sizeof(array) / sizeof(int));
  print(array, sizeof(array) / sizeof(int));  // 13 27 38 49 49 65 76 97

  return 0;
}
