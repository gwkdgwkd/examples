#include <stdio.h>

// 希尔排序算法又叫缩小增量排序算法，是一种更高效的插入排序算法。
// 和普通的插入排序算法相比，希尔排序算法减少了移动元素和比较元素大小的次数，
// 从而提高了排序效率，时间效率上有很大的改进。

// 在使用直接插入排序算法时，如果表中的记录只有个别的是无序的，多数保持有序，这种情况下算法的效率也会比较高；
// 除此之外，如果需要排序的记录总量很少，该算法的效率同样会很高。
// 希尔排序就是从这两点出发对算法进行改进得到的排序算法。
// 一般在记录的数量多的情况下，希尔排序的排序效率较直接插入排序高。

// 希尔排序的具体实现思路是：
// 1.将待排序序列划分成多个子序列，使用普通的插入排序算法对每个子序列进行排序；
// 2.按照不同的划分标准，重复执行第一步；
// 3.使用普通的插入排序算法对整个序列进行排序。

// 经过大量的研究表明，所选取的增量值最好是没有除1之外的公因子，同时整个增量数组中最后一个增量值必须等于1，
// 因为最后必须对整张表做一次直接插入排序算法。

void print(int *list, int size, int i) {
  if (i > 0) {
    printf("%d: ", i);
  }
  for (int i = 0; i < size; i++) {
    printf("%d ", list[i]);
  }
  printf("\n");
}

void ShellSort(int *nums, int size) {
  // 待排序序列如何进行划分，划分多少次，都会影响到希尔排序算法的执行效率。
  // 希尔排序算法没有固定的划分标准，推荐一种常用的方法：
  int interval = 1;              // 初始化间隔数为1
  while (interval < size / 3) {  // 计算最大间隔
    interval = interval * 3 + 1;
  }

  // 根据间隔数，不断划分序列，并对各子序列排序
  while (interval) {
    for (int i = interval; i < size; ++i) {  // 对各个子序列做直接插入排序
      if (nums[i] < nums[i - interval]) {
        int temp = nums[i];
        int j = i - interval;
        while (j >= interval - 1 && temp < nums[j]) {  // j>=0也行
          nums[j + interval] = nums[j];
          j = j - interval;
        }
        nums[j + interval] = temp;
      }
      print(nums, size, interval);
    }
    interval = (interval - 1) / 3;  // 计算新的间隔数，继续划分序列
  }
}

int main(int argc, const char *argv[]) {
  int a[] = {35, 33, 42, 10, 14, 19, 27, 44};
  ShellSort(a, sizeof(a) / sizeof(int));
  // 4: 14 33 42 10 35 19 27 44
  // 4: 14 19 42 10 35 33 27 44
  // 4: 14 19 27 10 35 33 42 44
  // 4: 14 19 27 10 35 33 42 44
  // 1: 14 19 27 10 35 33 42 44
  // 1: 14 19 27 10 35 33 42 44
  // 1: 10 14 19 27 35 33 42 44
  // 1: 10 14 19 27 35 33 42 44
  // 1: 10 14 19 27 33 35 42 44
  // 1: 10 14 19 27 33 35 42 44
  // 1: 10 14 19 27 33 35 42 44

  return 0;
}
