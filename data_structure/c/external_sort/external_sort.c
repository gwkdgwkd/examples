#include <stdio.h>

// 插入排序、选择排序、归并排序等都属于内部排序算法，即排序的整个过程只是在内存中完成。
// 而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，
// 需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要用到外部排序算法来解决。
// 外部排序算法由两个阶段构成：
// 1.按照内存大小，将大文件分成若干长度小于内存的可使用容量的子文件，然后依次读入内存，
//   使用适当的内部排序算法对其进行排序，排好序的子文件统称为归并段或者顺段，
//   将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；
// 2.对得到的顺段进行合并，直至得到整个有序的文件为止。

// 假设有个72KB的文件，存储了18K个整数，磁盘中物理块的大小为4KB，
// 将文件分成18组，每组刚好4KB，使用外部排序的基本思路：
// 1.首先通过18次内部排序，把18组数据排序，得到初始的18个归并段R1~R18，每个归并段有1024个整数；
// 2.然后对这18个初始的归并段使用4路平衡归并排序，
//   a.第1次归并产生5个归并段：
//     R11，由{R1,R2,R3,R4}中的数据合并而来，写入文件R11.dat；
//     R12，由{R5,R6,R7,R8}中的数据合并而来，写入文件R12.dat；
//     R13，由{R9,R10,R11,R12}中的数据合并而来，写入文件R13.dat；
//     R14，由{R13,R14,R15,R16}中的数据合并而来，写入文件R14.dat；
//     R15，R15是由{R17,R18}中的数据合并而来，写入文件R15.dat。
//   b.第2次归并，从第1次归并产生的5个文件中读取数据，合并，产生2个归并段：
//     R21，由{R11,R12,R13,R14}中的数据合并而来，写入文件R21.dat；
//     R22，由{R15}中的数据合并而来，写入文件R22.dat。
//   c.第3次归并，从第2次归并产生的2个文件中读取数据，合并，产生1个归并段：
//     R31，由{R21,R22}中的数据合并而来，写入文件R31.dat，这个文件为最终排序好的文件。

// 对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，
// 即访问外存的次数越多，算法花费的时间就越多，效率就越低，对于同一个文件来说，
// 对其进行外部排序时访问外存的次数同归并的次数成正比，即归并次数越多，访问外存的次数就越多。
// 对于k-路平衡归并中k值得选择，增加k可以减少归并的次数，从而减少外存读写的次数，最终提高效率。
// 除此之外，一般情况下对于具有m个初始归并段进行k-路平衡归并时，归并的次数为：
// s=⌊logk⁡m⌋（其中s表示归并次数）。
// 从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
// 1.增加k-路平衡归并中的k值，引申出了多路平衡归并算法；
// 2.尽量减少初始归并段的数量m，即增加每个归并段的容量，引申出了置换-选择排序算法。

// 无论是通过等分还是置换-选择排序得到的归并段，如何设置它们的归并顺序，
// 可以使得对外存的访问次数降到最低，操作外存的次数恰好是树的带权路径长度的2倍。
// 所以，对于如何减少访问外存的次数的问题，就等同于如何使k-路归并所构成的k叉树的带权路径长度最短。
// 若想使树的带权路径长度最短，就是构造赫夫曼树。
// 通过以构建赫夫曼树的方式构建归并树，使其对读写外存的次数降至最低，
// k-路平衡归并，需要选取合适的k值，构建赫夫曼树作为归并树，所以称此归并树为最佳归并树。
// 在一般情况下，对于k–路平衡归并来说，若(m-1)MOD(k-1)=0，则不需要增加虚段；
// 否则需附加k-(m-1)MOD(k-1)-1个虚段。
// 实现外部排序的两个过程：
// 1.将整个初始文件分为多个初始归并段；
// 2.将初始归并段进行归并，直至得到一个有序的完整文件。
// 为了提高整个外部排序的效率，分别从以上两个方面对外部排序进行了优化：
// 1.在实现将初始文件分为m个初始归并段时，为了尽量减小m的值，采用置换-选择排序算法，
//   可实现将整个初始文件分为数量较少的长度不等的初始归并段；
// 2.同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，
//   采用构建最佳归并树的方式，对初始归并段进行归并，而归并的具体实现方法是采用败者树的方式。

// 快速排序以及堆排序两个算法，主要是用来处理海量数据，对海量数据进行排序时，
// 不可避免会出现内存无法容纳下的情况，此时就需要使用外排序算法。
// 外排序一般是基于归并排序，归并排序分为两个阶段：
// 1.分割阶段，将原始待排序数据分成若干个顺串；
// 2.合并阶段，将所有小顺串合并成一个包含所有数据的大顺串。

// 归并的过程就是分割加合并，分割合并两个阶段很简单，
// 但如何更快的实现一个归并排序，就会涉及到一系列问题，主要包括三个问题：
// 1.有没有办法在分割阶段就生成大于内存大小的顺串呢？
//   分割阶段只需要顺序扫描一次外存，最简单的策略是读取外存数据，
//   加载到内存，当内存用满时，执行快速排序等内排序算法，生成一个顺串。
//   之后清空内存，继续读取外存数据，如此反复，直到所有外存数据处理完毕。
//   该算法生成的每一个顺串的大小都不会超过内存的大小，而顺 串越小，合并阶段的代价就越高，
//   需要读取外存的次数也越多，有没有办法在分割阶段就生成大于内存大小的顺串呢？
//   可以使用替换选择算法，该算法借鉴的是扫雪机模型，它是这么工作的：
//   a.初始化阶段，读取输入元素至内存，并建立最小堆；
//   b.弹出堆顶元素，输出到顺串文件的缓冲区，并记录该元素的排序键为lastkey；
//   c.读取新元素，如果元素排序键大于等于lastkey，插入堆顶，并调整堆，使其有序；
//   d.如果新元素排序键小于lastkey，将该元素放入堆尾，并将堆的大小减1；
//   e.重复第2步，直至堆大小变为0；
//   f.顺串生成完毕，将堆大小重置为N，并重新建堆，重复第2步，开始生成下一个顺串。
// 2.合并阶段假设存在N个输入缓冲区，如何高效的比较N个输入缓冲区的最小值，并输出到输出缓冲区？
//   假设顺串（长度为L）分布在K个文件中，顺串合并时需要K个输入缓冲区和1个输出缓冲区，
//   每次选取K个缓冲区的最小值，输出到输出缓冲区，最后，输出缓冲区输出的顺串长度为L*K。
//   因此算法复杂度O(K*(L*K))，如何才能降低这么高的复杂度呢，可以使用败者树算法：
//   a.输入每个顺串的第一个记录作为败者树的叶子节点，建立初始化败者树；
//   b.两两相比较，父亲节点存储了两个节点比较的败者（节点较大的值），
//     胜利者（较小者）可以参与更高层的比赛，这样树的顶端就是当次比较的冠军（最小者）。
//   c.调整败者树，当把最小者输入到输出文件以后，需要从相应的顺串取出一个记录补上去，
//     补回来的时候，就需要调整败者树，只需要沿着当前节点的父亲节点一直比较到顶端。
//     比较的规则是与父亲节点比较，胜者参与更高层的比较，一直向上直到根节点，失败者留在当前节点。
//   败者树对每一个新读读入的元素进行比较的时候，它的复杂度是树的高度，也就是log(k)。
// 3.合并阶段，如何减少合并顺串过程中磁盘的读取的顺串数量？
//   败者树解决的是在合并阶段，如何快速从n个元素中选取最小值，合并阶段还有另外一个问题，
//   如何减少合并顺串过程中磁盘读取的顺串的数量，即如何减少总的IO，一般的做法是使用多路归并排序。

// 胜者树&败者树&堆排序
// 发展历史：
// 1.堆，其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，
//   把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，
//   然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次；
// 2.胜者树，这时人们想能否简化比较过程，这时就有了胜者树，
//   这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数，
//   而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。
// 3.败者树，这时人们又想能否再次减少比较次数，于是就有了败者树，在使用败者树的时候，
//   每个新元素上升时，只需要获得父节点并比较即可，所以总的来说，减少了访存的时间，
//   现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。
// 相同点：
// 空间和时间复杂度都是一样的O(N*logN)，调整一次的时间复杂度都是O(logN)的，
// 所以这道题用堆来做，跟用败者树来做并没有本质上的算法复杂度量级上的差别。
// 不同点：
// 1.堆，所有的节点都是关键字，每次调整一层需要比较两次，父亲与左孩子，父亲与右孩子；
// 2.胜者树，叶子节点是关键字，非叶子节点保存胜者索引，
//   每次调整一层需要比较1次，自己和兄弟，读取两次，父亲和兄弟；
// 3.败者树，叶子节点是关键字，非叶子节点保存败者索引，每次调整一层需要比较1次，自己和父亲，
//   读取父亲一次，只需要和路径上的节点比较，不需要和兄弟节点比较，简化了重构的过程。
