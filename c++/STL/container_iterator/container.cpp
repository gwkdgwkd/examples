#include <iostream>

using namespace std;

// 在实际的开发过程中，合理组织数据的存取与选择处理数据的算法同等重要，存取数据的方式往往会直接影响到对它们进行增删改查操作的复杂程度和时间消耗。
// 事实上，当程序中存在对时耗要求很高的部分时，数据结构的选择就显得尤为重要，有时甚至直接影响程序执行的成败。
// STL中提供了专家级的几乎我们所需要的各种容器，功能更好，复用性更高。

// 简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。
// STL提供有3类标准容器，分别是序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。
//  序列容器:主要包括vector向量容器、list列表容器以及deque双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。
//          将元素插入容器时，指定在什么位置，元素就会位于什么位置。
//  排序容器:包括set集合容器、multiset多重集合容器、map映射容器以及multimap多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素
//          也会插入到适当位置。所以关联容器在查找时具有非常好的性能。
//  哈希容器:C++11新加入4种关联式容器，分别是unordered_set哈希集合、unordered_multiset哈希多重集合、unordered_map哈希映射以及unordered_multimap
//          哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。
// 另外，以上3类容器的存储方式完全不同，因此使用不同容器完成相同操作的效率也大不相同。所以在实际使用时，要善于根据想实现的功能，选择合适的容器。

// 虽然STL标准库还有迭代器、算法、函数对象等，但容器仍是大多数C++程序员关注的焦点。
//  首先，和普通数组相比，容器支持动态扩容和收缩，还可以自行管理存储的元素（例如排序），同时还提供有诸多成员方法，大大提高了开发效率等等。
//  其次，每个容器的底层实现，都采用的是精心挑选的数据结构，这意味着在使用这些容器时，不用担心它们的执行效率。

// 总的来说，C++ STL标准库（以C++11为准）提供了以下几种容器(容器适配器本质上也属于容器)供我们选择：
//  1 序列式容器：array、vector、deque、list和forward_list；
//  2 关联式容器：map、multimap、set 和 multiset；
//  3 无序关联式容器：unordered_map、unordered_multimap、unordered_set和unordered_multiset；
//  4 容器适配器：stack、queue和priority_queue。
// 上面是依据容器类型进行分类的。实际上，每个容器所具有的特性都和其底层选用的存储结构息息相关。根据容器底层采用的是连续的存储空间，还是分散的存储空间（以链表
// 或者树作为存储结构），还可以将上面容器分为如下两类：
//  1 采用连续的存储空间：array、vector、deque；
//  2 采用分散的存储空间：list、forward_list以及所有的关联式容器和哈希容器。
// 这里将deque容器归为使用连续存储空间的这一类，是存在争议的。因为deque容器底层采用一段一段的连续空间存储元素，但是各段存储空间之间并不一定是紧挨着的。

// 既然C++ STL标准库提供了这么多种容器，在实际场景中我们应该如何选择呢？要想选择出适用于该特定场景的最佳容器，需要综合考虑多种实际因素，例如：
//  1 是否需要在容器的指定位置插入新元素？如果需要，则只能选择序列式容器，而关联式容器和哈希容器是不行的；
//  2 是否对容器中各元素的存储位置有要求？如果没有，则可以考虑使用哈希容器，反之就要避免使用哈希容器；
//  3 是否需要使用指定类型的迭代器？举个例子，如果必须是随机访问迭代器，则只能选择array、vector、deque；如果必须是双向迭代器，则可以考虑list序列式容器以及所
//    有的关联式容器；如果必须是前向迭代器，则可以考虑 forward_list 序列式容器以及所有的哈希容器；
//  4 当发生新元素的插入或删除操作时，是否要避免移动容器中的其它元素？如果是，则要避开array、vector、deque，选择其它容器；
//  5 容器中查找元素的效率是否为关键的考虑因素？如果是，则应优先考虑哈希容器。

int main() { return 0; }