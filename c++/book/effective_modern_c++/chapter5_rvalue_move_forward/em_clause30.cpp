#include <iostream>
#include <vector>

// 条款30：熟悉完美转发的失败情形

// 在C++11的宝箱上最引人注目的语言特性纹章之一，就是完美转发。
// 不过，揭开宝箱的表面，才会发现会有这样的理想版完美和那样的现实版完美。
// C++11的完美转发相当不错，但如果一定要说达到了真正的完美之境，那就不能拘泥于若干小节。

// 转发的含义不过是一个函数把自己的形参传递（转发）给另一个函数而已。
// 其目的是为了让第二个函数（转发目的函数）接受第一个函数（转发发起函数）所接受的同一对象。
// 这就排除了按值传递形参，因为它们只是原始调用者所传递之物的副本。
// 想要转发目的函数能够处理原始传入对象，指针形参也只能出局，因为不能强迫调用者传递指针。
// 论及一般意义上的转发时，就是在处理形参为引用类型的情形。

// 完美转发的含义是不仅转发对象，还转发其显著特征：
// 类型、是左值还是右值，以及是否带有const或volation饰词等。
// 结合前面的观察分析，即一般是会和引用形参打交道，这就是说，会运用万能引用，
// 因为只有万能引用形参才会将传入的实参是左值还是右值这一信息加以编码。

// 假设有某函数f，尔后打算撰写一个函数（其实是函数模板）将f作为转发目标：
// template <typename T>
// void fwd(T&& param) {         // 接受任意实参
//   f(std::forward<T>(param));  // 转发该实参到f
// }
// 转发函数不只是模板，而且是可变长形参模板，从而能够接受任意数量的实参：
// template <typename... Ts>
// void fwd(Ts&&... params) {         // 接受任意实参
//   f(std::forward<Ts>(params)...);  // 转发所有实参到f
// }
// 这种形式可以在很多地方见到，包括：
// 1.标准容器的置入函数，见条款42；
// 2.智能指针的工厂函数std::make_shared和std::make_unique，见条款21。

// 给定目标函数f和转发函数fwd，当以某特定实参调用f会执行某操作，
// 而用同一实参调用fwd会执行不同的操作，则称完美转发失败：
// f(expression);
// fwd(expression);
// 如果f执行了某操作，而fwd执行了不同的操作，则称fwd完美转发expression到f失败。

// 有若干种实参会导致该失败，重要之处在于知道这几种实参是什么，以及如何绕过它们。

namespace n1 {
// 大括号初始化物

void f(const std::vector<int>& v) {}
template <typename... Ts>
void fwd(Ts&&... params) {         // 接受任意实参
  f(std::forward<Ts>(params)...);  // 转发所有实参到f
}

void func() {
  f({1, 2, 3});  // {1,2,3}会隐式转换为std::vector<int>
  // fwd({1, 2, 3});  // 错误，无法编译通过

  // 原因在于，大括号初始化物的运用，就是一种完美转发失败的情形。

  // 凡是归类于此的失败，原因都一模一样。
  // 在对f的直接调用中,编译器先领受了调用端的实参类型，又领受了f所声明的形参类型。
  // 编译器会比较这两个类型来确定它们是否兼容，尔后，如有必有，
  // 会实施型隐式类型转换来使得调用得以成功。
  // 在上面的例子中，编译器从{1,2,3}出发生成一个临时的std::vector<int>类型对象，
  // 从而f的形参就有了一个std::vector<int>对象得以绑定。

  // 而经由转发函数模板fwd来对f实施间接调用时，
  // 编译器就不再会比较fwd的调用处传入的实参和f中所声明的形参了。
  // 取而代之的是，编译器会采用推导的手法来取得传递给fwd实参的类型结果，
  // 尔后它会比较推导类型结果和f声明的形参类型。
  // 完美转发会在下面两个条件中的任何一个成立时失败：
  // 1.编译器无法为一个或多个fwd的形参推导出类型结果，在此情况下，代码无法编译通过；
  // 2.编译器为一个或多个fwd的形参推导出了错误的类型结果，这里所谓的错误的，
  //   既可以指fwd根据类型推导结果的实例化无法通过编译，
  //   也可以指以fwd推导而得的类型调用f与直接以传递给fwd的实参调用f行为不一致，
  //   这种分裂行为的源泉之一，可能在于f乃是个重载函数的名字，然后，
  //   依据不正确的推导类型，fwd里调用到的f重载版本，就与直接调用f的版本有异。

  // 在fwd({1,2,3})这句中，问题在于：
  // 向未声明为std::initializer_list类型的函数模板形参传递了大括号初始化物，
  // 因为这样的语境按规定，用标准委员的行话说，叫做非推导语境。
  // 通俗地说，这个词的意思是，由于fwd的形参未声明为std::initializer_list，
  // 编译器就会被禁止在fwd的调用过程中从表达式{1,2,3}出发来推导类型。
  // 而既然从fwd的形参出发进行推导时被阻止的行为，所以编译器拒绝这个调用也是合情合理的。

  // 有意思的事情来了，条款2曾经说明过，auto变量在以大括号初始化物完成初始化时，
  // 类型推导可以成功，这样的变量会被视为std::initializer_list类型对象，
  // 这么一来，如果转发函数的形参的推导类型结果应为std::initializer_list的话，
  // 就有了简单易行的绕行手法，先用auto声明局部变量，然后将该局部变量传递给转发函数：
  auto il = {1, 2, 3};  // il的类型推导结果为std::initializer_list<int>
  fwd(il);              // 没问题，将il完美转发给f
}
}  // namespace n1

namespace n2 {
// 0和NULL用作空指针

// 条款8曾说过，若尝试把0和NULL以空指针之名传递给模板，类型推导就会发生行为扭曲，
// 推导结果会是整型（一般情况下会是int）而非所传递实参的指针类型。
// 结论就是，0和NULL都不能用作空指针以进行完美转发。
// 不过，修正方案也颇为简单，传递nullptr,而非0或NULL。
}  // namespace n2

namespace n3 {
// 仅有声明的整型static const成员变量

// 有这么个普适的规定：
// 不需要给出类中的整型static const成员变量的定义，仅需声明之。
// 因为编译器会根据这些成员的值实施常数传播，从而就不必再为它们保留内存。
class Widget {
 public:
  static const std::size_t MinVals = 28;
};

void func1() {
  std::vector<int> widgetData;
  widgetData.reserve(Widget::MinVals);  // 此处用到了MinVals
  // 在这里，尽管Minvals并无定义，还是利用了MinVals来指定widgetData的初始容量。
  // 编译器绕过了MinVals缺少定义的事实，手法是把值28塞到所有提及Minvals之处。
  // 未为MinVals的值保留存储这一事实并不会带来问题。
  // 如果产生了对Minvals实施取值的需求，例如，有人创建了一个指涉到MinVals的指针，
  // MinVals就得要求存储内存，然后上面这段代码虽然仍能够编译通过，
  // 但是如果不为MinVals提供定义，它在链接器就会遭遇失败。
}

void f(std::size_t val) {}
template <typename... Ts>
void fwd(Ts&&... params) {         // 接受任意实参
  f(std::forward<Ts>(params)...);  // 转发所有实参到f
}

void func2() {
  f(Widget::MinVals);  // 没问题，当f(28)处理
  // fwd(Widget::MinVals);  // 错误，无法链接

  // 尽管源代码看上去并没有对MinVals实施取址，但注意到fwd的形参是个万能引用，
  // 而引用这东西，在编译器生成的机器代码中，通常是当指针处理的。
  // 程序的二进制代码中（从硬件视角来看），指针和引用在本质上是同一事物。
  // 在此层次，有一句老话说得对：引用不过是会提领的指针罢了。
  // 既然如此，MinVals按引用传递和按指针传递结果也就没有什么区别了。
  // 基于同样的理由，也得准备某块内存以供指针去指涉。
  // 按引用传递整型static const成员变量通常要求其加以定义，
  // 而这个需求就会导致代码完美转发失败而等价的、未使用完美转发的代码却能成功。
}

// 有时能够完美转发未加定义的static const成员变量的，这取决于编译器和链接器。
// 如果真是这样，恭喜，不过没有理由期望这样的代码能够移植。
// 若想添加可移植性，只需static const成员变量提供定义即可：
const std::size_t Widget::MinVals;
// 定义语句没有重复指定初始化，就是28。
// 如果在两处都提供了初始化物，编译器肯定会发出控诉，从而提醒只在一处指定即可。
void func3() {
  f(Widget::MinVals);
  fwd(Widget::MinVals);
}
}  // namespace n3

namespace n4 {
// 重载的函数名字和模板名字

void f(int (*pf)(int)) {}
// void f(int pf(int)) {}  // 平凡的非指针语法来声明，声明与上面含义相同的f
template <typename... Ts>
void fwd(Ts&&... params) {         // 接受任意实参
  f(std::forward<Ts>(params)...);  // 转发所有实参到f
}
int processVal(int value) {}
int processVal(int value, int priority) {}

template <typename T>
T workOnVal(T param) {}

void func() {
  f(processVal);
  // fwd(processVal);  // 错误，编译器不知道选择哪个processVal重载版本

  // f要求的实参是个指涉到函数的指针，可是processVal既非函数指针，
  // 甚至连函数都不是，它是两个不同函数的名字。
  // 无论如何，编译器还是知道它们需要的是哪个processVal：匹配f形参类型的那个。
  // 总之，编译器会选择接受一个int那个版本的processVal,尔后把那个函数地址传给f。
  // 之所以能够没问题就在于f的声明使得编译器弄清楚了哪个版本的processVal是所要求的。
  // fwd就不行了，因为作为一个函数模板，它没有任何关于类型需求的信息，
  // 这也使得编译器不可能决议应该传递哪个函数重载版本。
  // 光秃秃的processVal并无类型，没有类型，类型推导无从谈起。

  // 同一个问题，会出现在使用函数模板来代替（或附加于）重载函数名字的场合。
  // 函数模板不是只代表一个函数，而是代表着许许多多函数：
  f(workOnVal);
  // fwd(workOnVal);

  // 想让fwd接受重载函数名字或者模板名字，只有手动指定需要转发的那个重载版本或者实例。
  // 可以创建与f的形参同一类型的函数指针，然后用processVal和workOnVal初始化那个指针，
  // 这可以使得适当的processVal重载版本得以选择或适当的workOnValue实例得以生成，
  // 再后将指针传递给fwd：
  using ProcessFuncType = int (*)(int);  // 相当于创建一个typede，见条款9
  ProcessFuncType processValPtr = processVal;  // 指定了需要的processVal签名
  fwd(processValPtr);                          // 没问题
  fwd(static_cast<ProcessFuncType>(workOnVal));  // 也没问题

  // 当然，这要求你知道fwd转发的函数指针类型到底应该是什么。
  // 完美转发函数一般来说不会在文档中写明这个信息。
  // 毕竟，完美转发函数是被设计用来接受任何类型的，但这么一来，
  // 没有文档告知你要传递的类型，那你又如何知道呢？
}
}  // namespace n4

namespace n5 {
// 位域

// 最后一种完美转发失败情形，是位域被用作函数实参：
struct IPv4Header {
  std::uint32_t version : 4, IHL : 4, DSCP : 6, ECN : 2, totalLength : 16;
};

void f(std::size_t sz) {}
template <typename... Ts>
void fwd(Ts&&... params) {         // 接受任意实参
  f(std::forward<Ts>(params)...);  // 转发所有实参到f
}

void func() {
  IPv4Header h;
  f(h.totalLength);  // 没问题
  // fwd(h.totalLength);  // 错误

  // 问题在于fwd的形参是个引用，而h.totalLength是个非const的位域。
  // 乍听之下，这也没什么，但是C++标准却对于这么个组合以异乎寻常的口吻严加禁止：
  // 非const引用不得绑定到位域，该条禁令倒是有机器充分的理由。
  // 位域是机器字的若干任意部分组成的，例如，32位int的第3到第5个比特，
  // 但是这样的实体是不可能有办法对其直接取址的，在硬件层次，
  // 引用和指针本是同一事物这么一来，既然没有办法创建指涉到任意比特的指针，
  // C++硬性规定，可能指涉的最小实体是单个char，那自然也就没办法把引用绑定到任意比特了。

  // 要将完美转发位域的不可能化为可能，也简单不过。
  // 一旦意识到接受位域实参的任何函数都实际上只会收到位域值的副本。
  // 毕竟，没有函数可以把位域绑定到引用，也不可能有函数接受指涉到位域的指针，
  // 因为根本不存在指涉到位域的指针。
  // 可以传递位域的仅有的形参种类就只有按值传递，以及，有点匪夷所思的常量引用。
  // 在按值传递的形参这种情况下，被调用的函数显然收到的是位域内的值的副本。
  // 常量引用不可能绑定到位域，它们绑定到的是常规对象，其中复制了位域的值。

  // 这么一来，把位域传递给完美转发函数的关键，
  // 就是利用转发目的函数接受的总是位域值副本的这一事实。
  // 可以自己制作一个副本，并以该副本调用转发函数：
  auto length = static_cast<std::uint16_t>(h.totalLength);
  fwd(length);  // 转发该副本
}
}  // namespace n5

// 在绝大数情形下，完美转发就如规定所言的方式运作如仪，很少需要特别留意什么。
// 但当你无法运作时，亦即，当一些看上去合理的代码编译失败，或者更讨厌的情况，
// 可以通过编译，行为却表现得和预料不同，重要的是了解完美转发的不完美之所在，
// 同样重要的是如何知道规避它们，在绝大多数情形下，这些规避手法都是直截了当的。

// 要记住的东西：
// 1.完美转发的失败情形，是源于模板类型推导失败，或推导结果是错误的类型；
// 2.会导致完美转发失败的实参种类有：
//   a.大括号初始化物；
//   b.以值0或NULL表达的空指针；
//   c.仅有声明的整型static const成员变量；
//   d.模板或重载的函数名字；
//   e.位域。

int main() { return 0; }