#include <iostream>
#include <string>

// 指针与引用的区别

// 指针与引用看上去完全不同，指针用操作符*和->，
// 引用使用操作符.，但是它们似乎有相同的功能。
// 指针与引用都是让你间接引用其他对象。
// 如何决定在什么时候使用指针，在什么时候使用引用呢？
// 首先，要认识到在任何情况下都不能使用指向空值的引用，
// 一个引用必须总是指向某些对象。
// 因此如果使用一个变量并让它指向一个对象，
// 但是该变量在某些时候也可能不指向任何对象，
// 这时应该把变量声明为指针，因为这样可以赋空值给该变量。
// 相反，如果变量肯定指向一个对象，
// 例如设计不允许变量为空，这时就可以把变量声明为引用。

// 在C++里：
// 引用肯定会指向一个对象，因此引用一定要被初始化；
// 指针则没有这样的限制。

// 不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。
// 因为在使用引用之前不需要测试它的合法性：
void printDouble(const double& rd) {
  // 不需要测试rd,它肯定指向一个double值：
  std::cout << rd;
}
void printDouble(const double* pd) {
  // 相反，指针则应该总是被测试，防止其为空：
  if (pd) {  // 检查是否为空
    std::cout << *pd;
  }
}

// 指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。
// 但是引用则总是指向在初始化时被指定的对象，以后不能改变。

// 总的来说，在以下情况下你应该使用指针：
// 1.你考虑到存在不指向任何对象的可能，
//   在这种情况下，你能够设置指针为空；
// 2.你需要能够在不同的时刻指向不同的对象，
//   在这种情况下，你能改变指针的指向。
// 在以下情况下你应该使用引用：
// 1.如果总是指向一个对象并且一旦指向一个对象后就不会改变指向；
// 2.还有一种情况，就是当你重载某个操作符时，你应该使用引用。

// 最普通的例子是操作符[]，这个操作符典型的用法是返回一个对象，其能被赋值。
// vector<int> v(10);
// 这个被赋值的目标对象就是操作符[]返回的值：
// v[5] = 10;
// 如果操作符[]返回一个指针，就要这样写：
// *v[5] = 10;

// 当知道必须指向一个对象并且不想改变其指向时，
// 或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。
// 而在除此之外的其他情况下，则应使用指针。

int main() {
  // 未定义行为：
  char* pc = 0;    // 设置指针为空值
  char& rc = *pc;  // 让引用指向空值

  // 错误，引用必须被初始化：
  // string& rs;

  std::string s("xyzzy");
  // 正确，rs指向s：
  std::string& rs = s;
  
  // 未初始化的指针，合法但危险：
  std::string* ps;

  std::string s1("Nancy");
  std::string s2("Clancy");
  std::string& rs1 = s1;                                // rs引用s1
  std::string* ps1 = &s1;                               // ps指向s1
  std::cout << "s1:" << s1 << ",s2:" << s2 << std::endl;     // s1:Nancy,s2:Clancy
  std::cout << "rs:" << rs1 << ",ps:" << *ps1 << std::endl;  // rs:Nancy,ps:Nancy
  rs1 = s2;   // rs仍旧引用s1,但是s1的值现在是Clancy
  ps1 = &s2;  // ps现在指向s2，s1没有改变
  std::cout << "s1:" << s1 << ",s2:" << s2 << std::endl;     // s1:Clancy,s2:Clancy
  std::cout << "rs:" << rs1 << ",ps:" << *ps1 << std::endl;  // rs:Clancy,ps:Clancy

  return 0;
}