#include <iostream>

// 容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。
// 之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。
// 1.stack<T>：是一个封装了deque<T>容器的适配器类模板，默认实现的是一个后入先出的压入栈。
//   stack<T>模板定义在头文件stack中。
// 2.queue<T>：是一个封装了deque<T>容器的适配器类模板，默认实现的是一个先入先出的队列。
//   可以为它指定一个符合确定条件的基础容器，queue<T>模板定义在头文件queue中。
// 3.priority_queue<T>：是一个封装了vector<T>容器的适配器类模板，默认实现的是一个会对元素排序，
//   从而保证最大元素总在队列最前面的队列。
//   priority_queue<T>模板定义在头文件queue中。
// 适配器类在基础序列容器的基础上实现了一些自己的操作，显然也可以添加一些自己的操作。
// 它们提供的优势是简化了公共接口，而且提高了代码的可读性。
// 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。
// 当然，如果必要的话，容器适配器中也可以自创新的成员函数。
// STL中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。

// STL提供了3种容器适配器，分别为stack栈适配器、queue队列适配器以及priority_queue优先权队列适配器。
// 其中，各适配器所使用的默认基础容器以及可供用户选择的基础容器。
// 1.stack基础容器需包含以下成员函数：
//   empty()
//   size()
//   back()
//   push_back()
//   pop_back()
//   满足条件的基础容器有vector、deque、list，默认使用的基础容器是deque。
// 2.queue基础容器需包含以下成员函数：
//   empty()
//   size()
//   front()
//   back()
//   push_back()
//   pop_front()
//   满足条件的基础容器有deque、list，默认使用的基础容器是deque。
// 3.priority_queue基础容器需包含以下成员函数：
//   empty()
//   size()
//   front()
//   push_back()
//   pop_back()
//   满足条件的基础容器有vector、deque，默认使用的基础容器是vector。
// 不同场景下，由于不同的序列式容器其底层采用的数据结构不同，因此容器适配器的执行效率也不尽相同。
// 但通常情况下，使用默认的基础容器即可，当然，也可以手动修改。

int main() { return 0; }