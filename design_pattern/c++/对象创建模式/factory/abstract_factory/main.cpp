#include "body/body.h"
#include "clothes/clothes.h"
#include "factory/america_factory.h"
#include "factory/china_factory.h"
#include "factory/japan_factory.h"
#include "shoes/shoes.h"

// 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。
// 创建目标对象时，只需要直到对象的抽象类型或接口类型即可，不需要知道具体的实现类型。
// 使用抽象工厂模式，可以在工厂变化时，不需要修改客户端使用工厂的代码。

// 抽象工厂模式可以将一组具有同一主题单独的工厂封装起来。
// 在使用时，客户端创建抽象工厂的实现，使用抽象工厂作为接口，来创建这一主题的对象。
// 使用的时候，不需要知道从内部工厂方法中获得的对象的具体类型。
// 客户端只使用这些对象的通用接口。
// 抽象工厂模式实现了一组对象的实现细节与使用分离。

// 抽象工厂模式的结构组成：
// 1.抽象工厂类，工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现；
// 2.具体工厂类，继承于抽象工厂，实现创建对应具体产品对象的方式；
// 3.抽象产品类，它是具体产品继承的基类；
// 4.具体产品类，具体工厂所创建的对象，就是此类。

// 优点：
// 1.隔离产品代码，在应用层隔离具体产品的代码，客户端无须关心产品创建的细节；
// 2.创建产品族，将一个系列的产品族，统一到一起创建。

// 缺点：
// 1.扩展困难，规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；
// 2.增加难度，增加了系统的抽象性和理解难度，还要引入反射技术。

// 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。
// 工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对的多个产品等级结构。
// 在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说：
// 1.工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类；
// 2.抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。
// 在抽象工厂模式中，有一个产品族的概念，是指位于不同产品等级结构中功能相关联的产品组成的家族。
// 抽象工厂模式所提供的一系列产品就组成一个产品族，而工厂方法提供的一系列产品称为一个等级结构。
// 如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式，
// 如果工厂的产品来自多个等级结构，则属于抽象工厂模式。

// 抽象工厂模式的适用场景：
// 1.忽略创建细节，客户端不关心产品实例如何被创建，实现等细节；
// 2.创建产品族，强调一系列相关的产品对象，一般是同一产品族，一起使用创建对象需要大量重复的代码；
// 3.产品类库，提供一个产品类的库，所有的产品以同样的接口出现，使客户端不依赖于具体实现。

// 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。
// 说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），
// 并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。
// 假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来创建产品，则更合适一点。
// 工厂方法模式适用于产品种类结构单一的场合，为一类产品提供创建的接口。
// 而抽象工厂方法适用于产品种类结构多的场合，主要用于创建一组相关的产品，为它们提供创建的接口，
// 就是当具有多个抽象角色时，抽象工厂便可以派上用场。

void func(Factory *f) {
  Body *pb = f->createBody();
  Clothes *pc = f->createClothes();
  Shoes *ps = f->createShoes();

  pb->showBody();
  pc->showClothes();
  ps->showShoes();

  delete pb;
  delete pc;
  delete ps;
}

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 3]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';

  Factory *f;
  switch (type) {
    case 0:
      f = new ChinaFactory();
      break;
    case 1:
      f = new JapanFactory();
      break;
    case 2:
      f = new AmericaFactory();
      break;
    default:
      std::cout << "invalid type" << std::endl;
      return -1;
  }

  func(f);
  delete f;

  return 0;
}
