#include <stdio.h>

// 数组（Array）是一系列具有相同类型的数据的集合，
// 每一份数据叫做一个数组元素（Element）。
// 数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。
// 定义数组时，要给出数组名和数组长度，
// 数组名可以认为是一个指针，它指向数组的第0个元素。
// 在C语言中，将第0个元素的地址称为数组的首地址。
// 数组名的本意是表示整个数组，也就是表示多份数据的集合，
// 但在使用过程中经常会转换为指向数组第0个元素的指针，
// 所以上面使用了认为一词，表示数组名和数组首地址并不总是等价。
// 如果一个指针指向了数组，就称它为数组指针（Array Pointer）。
// 数组指针指向的是数组中的一个具体元素，而不是整个数组，
// 所以数组指针的类型和数组元素的类型有关。

// 引入数组指针后，就有两种方案来访问数组元素了，
// 一种是使用下标，另外一种是使用指针：
// 1.使用下标，也就是采用arr[i]的形式访问数组元素。
//   如果p是指向数组arr的指针，
//   那么也可以使用p[i]来访问数组元素，它等价于arr[i]。
// 2.使用指针，也就是使用*(p+i)的形式访问数组元素。
//   另外数组名本身也是指针，
//   也可以使用*(arr+i)来访问数组元素，它等价于*(p+i)。
// 不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。
// 不同的是，数组名是常量，它的值不能改变，
// 而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。
// 也就是说，数组名只能指向数组的开头，
// 而数组指针可以先指向数组开头，再指向其他元素。

// 关于数组指针的谜题
// 假设p是指向数组arr中第n个元素的指针，
// 那么*p++、*++p、(*p)++分别是什么意思呢？
// 1.*p++等价于*(p++)，表示先取得第n个元素的值，再将p指向下一个元素。
// 2.*++p等价于*(++p)，会先进行++p运算，使得p的值增加，
//   指向下一个元素，整体上相当于*(p+1)，会获得第n+1个数组元素的值。
// 3.(*p)++就非常简单了，会先取得第n个元素的值，再对该元素的值加1。
//   假设p指向第0个元素，并且第0个元素的值为99，
//   执行完该语句后，第0个元素的值就会变为100。

// 字符串指针（指向字符串的指针）
// C语言中没有特定的字符串类型，通常是将字符串放在一个字符数组中。
// 字符数组归根结底还是一个数组，关于指针和数组的规则同样也适用于字符数组。
// 除了字符数组，C语言还支持另外一种表示字符串的方法，
// 就是直接使用一个指针指向字符串，
// 例如：char *str = "http://c.biancheng.net";
// 或者：char *str;str = "http://c.biancheng.net";
// 看起来和字符数组是多么地相似，它们都可以使用%s输出整个字符串，
// 都可以使用*或[]获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？
// 有！它们最根本的区别是在内存中的存储区域不一样，
// 字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。
// 全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，
// 而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。
// 内存权限的不同导致的一个明显结果就是，
// 字符数组在定义后可以读取和修改每个字符，
// 而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，
// 任何对它的赋值都是错误的。
// 在编程过程中如果只涉及到对字符串的读取，
// 那么字符数组和字符串常量都能够满足要求；
// 如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。
// C语言有两种表示字符串的方法，一种是字符数组，另一种是字符串常量，
// 它们在内存中的存储位置不同，使得字符数组可以读取和修改，
// 而字符串常量只能读取不能修改。

// 数组和指针绝不等价，数组是另外一种类型
// 数组和指针不等价的一个典型案例就是求数组的长度，
// 这个时候只能使用数组名，不能使用数组指针。
// 数组是一系列数据的集合，没有开始和结束标志，p仅仅是一个指向int类型的指针，
// 编译器不知道它指向的是一个整数还是一堆整数，
// 对p使用sizeof求得的是指针变量本身的长度。
// 也就是说，编译器并没有把p和数组关联起来，p仅仅是一个指针变量，
// 不管它指向哪里，sizeof求得的永远是它本身所占用的字节数。
// 站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。
// 变量名用来指代一份数据，数组名用来指代一组数据（数据集合），
// 它们都是有类型的，以便推断出所指代的数据的长度。
// 数组也有类型，可以将int、float、char等理解为基本类型，
// 将数组理解为由基本类型派生得到的稍微复杂一些的类型。
// sizeof就是根据符号的类型来计算长度的。
// 与普通变量名相比，数组名既有一般性也有特殊性：
// 1.一般性表现在数组名也用来指代特定的内存块，也有类型和长度；
// 2.特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。

// 数组到底在什么时候会转换为指针
// C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、
// sizeof或&的操作数时，它才表示整个数组本身，在其他的表达式中，
// 数组名会被转换为指向第0个元素的指针（地址）。
// C语言标准还规定，数组下标与指针的偏移量相同。
// 通俗地理解，就是对数组下标的引用总是可以写成：
// 一个指向数组的起始地址的指针加上偏移量。
// 取下标操作符的两个操作数是可以交换的，它并不在意操作数的先后顺序，
// 就像在加法中3+5和5+3并没有什么不一样。
// 使用下标时，编译器会自动把下标的步长调整到数组元素的大小。
// C语言标准规定，作为类型的数组的形参应该调整为类型的指针。
// 在函数形参定义这个特殊情况下，
// 编译器必须把数组形式改写成指向数组第0个元素的指针形式。
// 编译器只向函数传递数组的地址，而不是整个数组的拷贝。
// 这种隐式转换意味着下面三种形式的函数定义是完全等价的：
// void func(int *parr){ ...... }
// void func(int arr[]){ ...... }
// void func(int arr[5]){ ...... }
// 在函数内部，arr会被转换成一个指针变量，编译器为arr分配4个字节的内存，
// 用sizeof(arr)求得的是指针变量的长度，而不是数组长度。
// 要想在函数内部获得数组长度必须额外增加一个参数，在调用函数之前求得数组长度。
// 参数传递是一次赋值的过程，赋值也是一个表达式，
// 函数调用时不管传递的是数组名还是数组指针，
// 效果都是一样的，相当于给一个指针变量赋值。
// 把作为形参的数组和指针等同起来是出于效率方面的考虑。
// 数组是若干类型相同的数据的集合，数据的数目没有限制，
// 可能只有几个，也可能成千上万，如果要传递整个数组，
// 无论在时间还是内存空间上的开销都可能非常大。
// 关于数组和指针可交换性的总结:
// 1.用a[i]这样的形式对数组进行访问，
//   总是会被编译器改写成（或者说解释为）像*(a+i)这样的指针形式。
// 2.指针始终是指针，它绝不可以改写成数组。
//   你可以用下标形式访问数组，一般都是指针作为函数参数时，
//   而且你知道实际传递给函数的是一个数组。
// 3.在特定的环境中，也就是数组作为函数形参，
//   也只有这种情况，一个数组可以看做是一个指针。
//   作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。
// 4.当希望向函数传递数组时，
//   可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），
//   也可以定义为指针。
//   不管哪种形式，在函数内部都要作为指针变量对待。

int main() {
  // 可以定义一个指向数组的指针：
  int arr[] = {99, 15, 100, 888, 252};
  // arr本身就是一个指针这种表述并不准确，
  // 严格来说应该是arr被转换成了一个指针。

  // 它们都指向数组第0个元素，或者说指向数组的开头：
  int *p1 = arr;
  int *p2 = &arr[0];
  printf("%#X, %#X\n", p1, p2);
  // 0XBFA08540, 0XBFA08540

  int i, *p = arr, len = sizeof(arr) / sizeof(int);
  for (i = 0; i < len; i++) {
    printf("%d  ", arr[i]);
  }
  printf("\n");
  for (i = 0; i < len; i++) {
    printf("%d  ", p[i]);
  }
  printf("\n");
  for (i = 0; i < len; i++) {
    printf("%d  ", *(p + i));
  }
  printf("\n");
  for (i = 0; i < len; i++) {
    printf("%d  ", *(arr + i));
  }
  printf("\n");
  for (i = 0; i < len; i++) {
    printf("%d  ", *p++);
  }
  printf("\n");
  // 数组在内存中只是数组元素的简单排列，没有开始和结束标志，
  // 在求数组的长度时不能使用sizeof(p)/sizeof(int)，
  // 因为p只是一个指向int类型的指针，
  // 编译器并不知道它指向的到底是一个整数还是一系列整数（数组），
  // 所以sizeof(p)求得的是p这个指针变量本身所占用的字节数，
  // 而不是整个数组占用的字节数。
  // 根据数组指针不能逆推出整个数组元素的个数，
  // 以及数组从哪里开始、到哪里结束等信息。
  // 不像字符串，数组本身也没有特定的结束标志，
  // 如果不知道数组的长度，那么就无法遍历整个数组。
  printf("len: %d, %d\n", len, sizeof(p) / sizeof(int));  // 5 2

  int arr1[5] = {1, 2, 3, 4, 5};
  p = &arr1[3];
  printf("%x\n", p);     // d187704c
  printf("%d\n", *p++);  // 4
  printf("%d\n", *p);    // 5
  printf("%x\n", p);     // d1877050
  p = &arr1[3];
  printf("%d\n", *++p);  // 5
  printf("%d\n", *p);    // 5
  printf("%x\n", p);     // d1877050
  p = &arr1[3];
  printf("%d\n", (*p)++);  // 4
  printf("%d\n", *p);      // 5
  printf("%x\n", p);       // d187704c

  // C语言中的指针使得代码的编写非常灵活，
  // 如果指针能够和数组结合，那将会有更多的花招：
  char str[20] = "c.biancheng.net";
  char *s1 = str;
  // 1.str既是数组名称，也是一个指向字符串的指针；
  //   指针可以参加运算，加1相当于数组下标加1。
  char *s2 = str + 2;
  // 3.其实，数组元素的访问形式可以看做address[offset]，
  //   address为起始地址，offset为偏移量:
  //   表示以地址str为起点，向后偏移4个字符，为'a'；
  char c1 = str[4];
  char c2 = *str;
  // 2.指针可以参加运算，str+4表示第4个字符的地址，
  //   c3 = *(str+4)表示第4个字符，即'a'。
  char c3 = *(str + 4);
  // 4.字符与整数运算时，先转换为整数（字符对应的ASCII码）。
  //   num1与c4右边的表达式相同，对于num1，
  //   *str+2 == 'c'+2 == 99+2 == 101，
  //   即num1的值为101，对于c4，101对应的字符为‘e’，所以c4的输出值为'e'。
  char c4 = *str + 2;
  //   表示以地址str+1为起点，向后偏移5个字符，等价于str[6]，为'c'。
  char c5 = (str + 1)[5];
  int num1 = *str + 2;
  // 5.num2和num3分别为字符串str的首地址和第2个元素的地址。
  long num2 = (long)str;
  long num3 = (long)(str + 2);
  printf("  s1 = %s\n", s1);
  printf("  s2 = %s\n", s2);
  printf("  c1 = %c\n", c1);
  printf("  c2 = %c\n", c2);
  printf("  c3 = %c\n", c3);
  printf("  c4 = %c\n", c4);
  printf("  c5 = %c\n", c5);
  printf("num1 = %d\n", num1);
  printf("num2 = %ld\n", num2);
  printf("num3 = %ld\n", num3);

  char str1[20] = {0};
  for (i = 0; i < 10; i++) {
    *(str1 + i) = 97 + i;  // 97为字符a的ASCII码值
  }
  printf("%s\n", str1);           // abcdefghij
  printf("%s\n", str1 + 2);       // cdefghij
  printf("%c\n", str1[2]);        // c
  printf("%c\n", (str1 + 2)[2]);  // e

  char *str2 = "http://c.biancheng.net";
  int len2 = strlen(str2);
  // 直接输出字符串
  printf("%s\n", str2);
  // 使用*(str+i)
  for (i = 0; i < len2; i++) {
    printf("%c", *(str2 + i));
  }
  printf("\n");
  // 使用str[i]
  for (i = 0; i < len2; i++) {
    printf("%c", str2[i]);
  }
  printf("\n");

  char *str3 = "Hello World!";
  str3 = "I love C!";  // 正确，可以更改指针变量本身的指向
  // str3[3] = 'P';  // 错误()，不能修改字符串中的字符
  // 能够正常编译和链接，
  // 但在运行时会出现段错误（Segment Fault）或者写入位置错误。

  int a[6] = {0, 1, 2, 3, 4, 5};
  int *p6 = a;
  int len_a = sizeof(a) / sizeof(int);
  int len_p = sizeof(p6) / sizeof(int);
  printf("len_a = %d, len_p = %d\n", len_a, len_p);  // len_a = 6, len_p = 2

  for (i = 0; i < sizeof(a) / sizeof(int); ++i) {
    printf("%d ", a[i]);
  }
  printf("\n");  // 0 1 2 3 4 5
  for (i = 0; i < sizeof(a) / sizeof(int); ++i) {
    printf("%d ", i[a]);
  }
  printf("\n");  // 0 1 2 3 4 5
  for (i = 0; i < sizeof(a) / sizeof(int); ++i) {
    printf("%d ", *(p6 + i));
  }
  printf("\n");  // 0 1 2 3 4 5

  return 0;
}