#include <iostream>

using namespace std;

// 让自己习惯使用标准C++语言

// 在ARM之后发生的最主要变化是以下内容：
// 1.增加了新的特性：RTTI、命名空间、bool，
//   关键字mutable和explicit，对枚举的重载操作，
//   已及在类的定义中初始化const static成员变量。
// 2.模板被扩展了：现在允许了成员模板，增加了强迫模板实例化的语法，
//   模板函数允许无类型参数，模板类可以将它们自己作为模板参数。
// 3.异常处理被细化了：异常规格申明在编译期被进行更严格的检查，
//   unexpected()函数现在可以抛一个bad_exception对象了。
// 4.内存分配函数被改良了：
//   增加了operator new[]和operator delete[]函数，
//   operator new/new[]在内存分配失败时将抛出一个异常，
//   并有一个返回为0（不抛异常）的版本供选择。
// 5.增加了新的类型转换形式：
//   static_cast、dynamic_cast、const_cast和reinterpret_cast。
// 6.语言规则进行了重定义：
//   重定义一个虚函数时，其返回值不需要完全的匹配了，
//   临时对象的生存期进行了精确地定义。
//   如果原来返回基类对象或指针或引用，
//   派生类可以返回派生类的对象、指针或引用。
// 绝大部分变化都描述于《The Design and Evolution of C++》

// 标准运行库的功能分为下列类别:
// 1.支持标准C运行库，不用担心，C++仍然记得它的根源。
//   进行了一些细微的调整，
//   使得C++版本的C运行库顺应了C++更严格的类型检查，
//   但其功能和效果，在C运行库是怎么样的，在C++中还是怎么样。
// 2.支持string类型，标准C++运行库实现组的领衔人物Mike Vilot被告知：
//   如果没有一个标准的string类型，那么将血流于街！
//   平静一下，把板斧和棍子放下，标准C++运行库有了string类型。
// 3.支持本地化。
//   不同的文化有不同的字符集，以及在显示日期和时间、排序字符串、
//   输出货币值……等等时有不同的习惯。
//   标准运行库对本地化的支持便于开发同时 供不同文化地区使用的程序。
// 4.支持I/O操作。流运行库仍然有部分保留在C++标准中，
//   但标准委员会作了小量的修补。
//   虽然部分类被去除了（特别是iostram和fstram），部分类被替换了。
//   例如，以string为基础的stringstream类替换了，
//   以char*为基础的strstream类，
//   现在已不提倡使用strstream类了。
//   但标准流类的基本功能含概了以前的实现的基本功能。
// 5.支持数学运算。复数，C++教课书必谈的东西，最终纳入了标准运行库。
//   另外，运行库包含了特别的数组类（valarray）以免混淆。
//   这些数组类比内建类型的数组有更好的性能，尤其在多CPU系统下。
//   运行库也提供了部分常用的运算函数如加法和减法。
// 6.支持通用容器和运算。
//   标准C++运行库带了一组模板类和模板函数，称为标准模板库（STL）。
//   STL是标准C++运行库中最革命性的部分。

// 必须先知道标准C++运行库的两个特性。
// 第一，在运行库中的几乎任何东西都是模板。
// 在本书中，我谈到过运行库中的string类，实际上没有这样的类。
// 其实，有一个模板类叫basic_string来描述字符序列，
// 它接受一个字符类型的参数来构造此序列，
// 这使得它能表示char串、wide char串、Unicode char串等等。
// 我们通常认为的string类是从basic_string<char>实例化而成的。
// 用于它被用得如此广泛，标准运行库作了一个类型定义：
// typedef basic_string<char> string;
// 这其实仍然隐藏了很多细节，因为basic_string模板带三个参数；
// 除了第一个外都有默认参数。
// 要全面理解string类型，必须面对这个未经删节的 basic_string：
// template<class charT, class traits = string_char_traits<charT>,
//          class Allocator = allocator>
//  class basic_string;
// 使用string类型并不需要了解这个官方文章，
// 因为类型定义使得它表现得如同不是模板类。
// 无论你需要定制存入string的字符集，或调整这些字符的行为，
// 或控制分配给string的内存，这个basic_string模板都能让你完成这些事。
// 设计string类型时采用的逼近法：
// 归纳其行为然后推广为模板，被标准C++运行库广泛采用。
// IOstream？它们是模板；一个类型参数决定了这个流的特征。
// 复数？也是模板；一个类型参数决定了数字被怎么样存储。
// Valarray？模板；一个类型参数表明了数组里面存了什么。
// 如果你不熟悉模板，现在正是个熟悉的好机会。
// 另外需要知道的是：标准运行库将几乎所有内容都包含在命名空间std中。
// 要想使用标准运行库里面的东西而无需特别指明运行库的名称，
// 你可以使用using指示或使用（更方便的）using申明。
// 幸运的是，这种重复工作在你#include恰当的头文件时自动进行。

// 标准模板库
// STL基于三个基本概念：
// 包容器（container）、选择子（iterator）和算法（algorithms）。
// 1.包容器是被包容对象的封装；
// 2.选择子是类指针的对象，
//   让你能如同使用指针操作内建类型的数组一样操作STL的包容器；
// 3.算法是对包容器进行处理的函数，并使用选择子来实现的。
// 联想一下C++（和C）中数组的规则，就太容易理解STL的想法了。
// 真的只需要明确一点：
// 一个指向数组的指针可以正确地指出数组的任意元素或刚刚超出数组范围的那个元素。
// 如果指向了那个超范围的元素，它将只能与其它指向此数组的指针进行地址比较；
// 对其进行反引用，其结果为未定义。
// int *find(int *begin, int *end, int value) {
//   while (begin != end && *begin != value) ++begin;
//   return begin;
// }
// 返回end来表示没找到，看起来有些可笑，返回0（NULL指针）不是更好吗？
// 确实NULL看起来更自然，但并不意味着更好。
// find()函数必须返回特别的指针值来表明查找失败，
// 就此目的而言，end指针与NULL指针效果相同。
// 但，如我们将要看到的，end指针在推广到其它包容器类型时比NULL指针好。
// 选择子就是被设计为操作STL的包容器的类指针对象。
// 它们是灵巧指针的堂兄，只是灵巧指针的功能更强大。
// 但从技术角度看，它们的实现使用了同样的技巧。
// STL中的包容器：
// bitset、vector、list、deque、queue、priority-queue、stack、set和map，
// 你可以在其中任一类型上使用find()。
// STL其实非常简单，它只是收集了遵从同样规则的类模板和函数模板。
// STL的类提供如同begin()和end()这样的函数，
// 这些函数返回类型定义在此类内的选择子对象。
// STL的算法函数使用选择子对象操作这些类，
// STL的选择子类似于指针，这就是STL的全部。
// 它没有庞大的继承层次，也没有虚函数，
// 只是影响类模板和函数模板，及它们所遵守的规则。
// 这导致了另外一个发现：STL是可扩充的。
// 你可以在STL家族中加入自己的包容器，算法和选择子。
// 总要你遵守STL的规则，STL中的包容器将可以使用你的算法，
// 你的包容器上也可使用STL的算法。
// 当然，你的模板不会成为标准C++运行库的一部分，
// 但它们将用同样的规则来编译，并可被重用。

int main() { return 0; }