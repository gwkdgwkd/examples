#version 330 core
layout (location = 0) in vec3 aPos;

// 我们会将投影和模型矩阵存储到一个叫做Matrices的Uniform块中。我们不会将模型矩阵存在这里，因为模型矩阵在不同的着色器中会不断改变，所以使用Uniform缓冲对象并不会带来什么好处。
// 将projection和view矩阵存储到所谓的Uniform块(Uniform Block)中：
layout (std140) uniform Matrices // layout (std140)是说当前定义的Uniform块对它的内容使用一个特定的内存布局。设置了Uniform块布局(Uniform Block Layout)。
{
    mat4 projection;
    mat4 view;
};
uniform mat4 model;

void main()
{
    // Uniform块中的变量可以直接访问，不需要加块名作为前缀。
    gl_Position = projection * view * model * vec4(aPos, 1.0);

    // gl_PointSize = gl_Position.z; // 将点的大小设置为裁剪空间位置的z值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。
}  

// GLSL的内建变量:
// 着色器都是最简化的，如果需要当前着色器以外地方的数据的话，我们必须要将数据传进来。我们已经学会使用顶点属性、uniform和采样器来完成这一任务了。
// 然而，除此之外，GLSL还定义了另外几个以gl_为前缀的变量，它们能提供给我们更多的方式来读取/写入数据。我们已经在前面教程中接触过其中的两个了：顶
// 点着色器的输出向量gl_Position，和片段着色器的gl_FragCoord。

// 顶点着色器变量:
// gl_Position:顶点着色器的裁剪空间输出位置向量。如果你想在屏幕上显示任何东西，在顶点着色器中设置gl_Position是必须的步骤。
// gl_PointSize:GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。
// 在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。
// 在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE：glEnable(GL_PROGRAM_POINT_SIZE);
// gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个
// 有趣的输入变量，我们只能对它进行读取，它叫做gl_VertexID。
// gl_VertexID:整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当
// （使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。没有什么具体的用途，但知道我们能够访问这个信息总是好的。

// Uniform缓冲对象:
// 当使用多于一个的着色器时，尽管大部分的uniform变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？
// OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。当使用Uniform
// 缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。
// 因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。
// 在Uniform缓冲对象中储存数据是有一些规则的.
// 在我们大多数的例子中，我们都会在每个渲染迭代中，对每个着色器设置projection和view Uniform矩阵。现在我们只需要存储这些矩阵一次就可以了。
// 在OpenGL代码中将这些矩阵值存入缓冲中，每个声明了这个Uniform块的着色器都能够访问这些矩阵。

// Uniform块布局:
// Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部
// 分对应着着色器中的哪一个uniform变量。
// 我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。
// 每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。
// OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。
// 默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL是
// 可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。因为我们无法知道每个uniform变量的偏移量，我们也就不知道如何准确地填充我们的Uniform
// 缓冲了。我们能够使用像是glGetUniformIndices这样的函数来查询这个信息
// 虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。
// std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。
// 每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算
// 出来的。接下来对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。
// GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。
// layout (std140) uniform ExampleBlock
// {
//                      // 基准对齐量       // 对齐偏移量
//     float value;     // 4               // 0 
//     vec3 vector;     // 16              // 16  (必须是16的倍数，所以 4->16)
//     mat4 matrix;     // 16              // 32  (列 0)
//                      // 16              // 48  (列 1)
//                      // 16              // 64  (列 2)
//                      // 16              // 80  (列 3)
//     float values[3]; // 16              // 96  (values[0])
//                      // 16              // 112 (values[1])
//                      // 16              // 128 (values[2])
//     bool boolean;    // 4               // 144
//     int integer;     // 4               // 148
// }; 
// 标量，比如int和bool 	每个标量的基准对齐量为N。
// 向量 	           2N或者4N。这意味着vec3的基准对齐量为4N。
// 标量或向量的数组 	每个元素的基准对齐量与vec4的相同。
// 矩阵 	          储存为列向量的数组，每个向量的基准对齐量与vec4的相同。
// 结构体 	          等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。
// 虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。通过在Uniform块定义之前添加layout (std140)语句，我们告诉
// OpenGL这个Uniform块使用的是std140布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过shared布局了，剩下的一个
// 布局是packed。当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在
// 每个着色器中都可能是不同的。
