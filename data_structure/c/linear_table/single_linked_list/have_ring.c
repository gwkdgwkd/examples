#include "have_ring.h"

// 有环链表并不一定就是循环链表。循环链表指的是“首尾相连”的单链表，而有环链表则指的是单链表中存在一个循环子链表。

// 那么，如果给定一个单链表，如何判断其是否为有环链表呢？常用的判断方法有如下2种。
// 1) 最直接的实现思想就是：从给定链表的第一个节点开始遍历，每遍历至一个节点，都将其和所有的前驱节点进行比对，如果为同一个节点，则表明当前链表中有环；
//    反之，如果遍历至链表最后一个节点，仍未找到相同的节点，则证明该链表中无环。
//    注意，如果一个单链表为有环链表，基于单链表中各节点有且仅有1个指针域的特性，则势必该链表是没有尾结点的。
//    换句话说，有环链表的遍历过程是无法自行结束的，需要使用break语句手动结束遍历。
bool HaveRing(link* H) {
  link* Htemp = H;
  // 存储所遍历节点所有前驱节点的存储地址，64位环境下地址占8个字节，所以这里用long long类型
  long long addr[20] = {0};
  int length = 0, i = 0;
  // 逐个遍历链表中各个节点
  while (Htemp) {
    // 依次将Htemp和addr数组中记录的已遍历的地址进行比对
    for (i = 0; i < length; i++) {
      // 如果比对成功，则证明有环
      if (Htemp == addr[i]) {
        return True;
      }
    }
    // 比对不成功，则记录Htemp节点的存储地址
    addr[length] = Htemp;
    length++;
    Htemp = Htemp->next;
  }
  return False;
}
// 当函数的返回值为True，表示该链表有环；反之若函数返回值为False，表明链表中无环。显然，此实现方案的时间复杂度为O(n2)。

// 2) 相比上一种实现方案，这是一种时间复杂度为O(n)的算法。
//    该算法的实现思想需要借助一个论点，即在一个链表中，如果2个指针（假设为H1和H2）都从表头开始遍历链表，其中H1每次移动2个节点的长度（H1=H1->next->next）,
//    而H2每次移动1个节点的长度（H2=H2->next），如果该链表为有环链表，则H1、H2最终必定会相等；反之，如果该链表中无环，则H1、H2永远不会相遇。
//    有关在有环链表中H1和H2必定会相遇的结论，假设有环链表中的环包含n个节点，则第一次遍历，H1和H2相差1个节点；第二次遍历，H1和H2相差2个节点；
//    第三次遍历，H1和H2相差3个节点...，最终经过多次遍历，H1和H2会相差n-1个节点，此时就会在环中重合，此时H1和H2相等。
bool HaveRing(link* H) {
  link* H1 = H->next;
  link* H2 = H;
  while (H1) {
    if (H1 == H2) {
      // 链表中有环
      return True;
    } else {
      H1 = H1->next;
      if (!H1) {
        // 链表中无环
        return False;
      } else {
        H1 = H1->next;
        H2 = H2->next;
      }
    }
  }
  // 链表中无环
  return False;
}
// 当函数返回False时，表明当前链表中无环；反之若返回True，则表明该链表为有环链表。和第一种算法相比，本算法的时间复杂度为O(n)。
