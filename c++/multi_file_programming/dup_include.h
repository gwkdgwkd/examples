// C++多文件编程中，处理“多次#include导致重复引入”问题的方式有以下3种。
// 事实上，无论是C语言还是C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了3种结构中的一种，
// 这也是为什么重复引入系统库文件编译器也不会报错的原因。
// 其中#pragma once和_Pragma("once")可算作一类，其特点是编译效率高，
// 但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；
// 而#ifndef的特点是可移植性高，编译效率差。
// 除非对项目的编译效率有严格的要求，强烈推荐选用#ifndef/#define/#endif组合解决头文件被重复引入。

// 1.使用宏定义避免重复引入。在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：
#ifndef _NAME_H
#define _NAME_H
// 头文件内容
#endif
// 其中，_NAME_H是宏的名称。
// 需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同，一般用路径+文件名表示。
// 当程序中第一次#include该文件时，由于_NAME_H尚未定义，所以会定义_NAME_H并执行“头文件内容”部分的代码；
// 当发生多次#include时，因为前面已经定义了_NAME_H，所以不会再重复执行“头文件内容”部分的代码。

// 2.使用#pragma once避免重复引入
// 除了前面第一种最常用的方式之外，还可以使用#pragma one指令，
// 将其附加到指定文件的最开头位置，则该文件就只会被#include一次。
// 我们知道，#ifndef是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。
// 但考虑到C和C++都支持宏定义，所以项目中使用#ifndef规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。
// 和ifndef相比，#pragma once不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。
// 但值得一提的是，并不是每个版本的编译器都能识别#pragma once指令，
// 一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即#pragma once指令的兼容性不是很好。
// 目前，几乎所有常见的编译器都支持#pragma once指令，甚至于Visual Studio 2017新建头文件时就会自带该指令。
// 可以这么说，在C/C++中，#pragma once是一个非标准但却逐渐被很多编译器支持的指令。
// 除此之外，#pragma once只能作用于某个具体的文件，而无法向#ifndef那样仅作用于指定的一段代码。
#pragma once
// 头文件内容

// 3.使用_Pragma操作符
// C99标准中新增加了一个和#pragma指令类似的_Pragma操作符，其可以看做是#pragma的增强版，
// 不仅可以实现#pragma所有的功能，更重要的是，_Pragma还能和宏搭配使用。
// 当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：
_Pragma("once")
// 头文件内容

// 另外在某些场景中，考虑到编译效率和可移植性，
// #pragma once和#ifndef经常被结合使用来避免头文件被重复引入。
// 当编译器可以识别#pragma once时，则整个文件仅被编译一次；
// 反之，即便编译器不识别#pragma once指令，此时仍有#ifndef在发挥作用。
#pragma once
#ifndef _STUDENT_H
#define _STUDENT_H
// 头文件内容
#endif
