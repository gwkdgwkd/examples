#include <stdio.h>
#include <stdlib.h>

// 堆的含义：在含有n个元素的序列中，如果序列中的元素满足下面其中一种关系时，此序列可以称之为堆。
//  ki≤k2i且ki≤k2i+1（在n个记录的范围内，第i个关键字的值小于第2*i个关键字，同时也小于第2*i+1个关键字）
//  ki≥k2i且ki≥k2i+1（在n个记录的范围内，第i个关键字的值大于第2*i个关键字，同时也大于第2*i+1个关键字）
// 对于堆的定义也可以使用完全二叉树来解释，因为在完全二叉树中第i个结点的左孩子恰好是第2i个结点，右孩子恰好是2i+1个结点。
// 如果该序列可以被称为堆，则使用该序列构建的完全二叉树中，每个根结点的值都必须不小于（或者不大于）左右孩子结点的值。
// 堆用完全二叉树表示时，其表示方法不唯一，但是可以确定的是树的根结点要么是无序表中的最小值，要么是最大值。

// 通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，
// 如此反复执行就可以得到一个有序序列，此过程为堆排序。
// 堆排序过程的代码实现需要解决两个问题：
//  1 如何将得到的无序序列转化为一个堆？
//  2 在输出堆顶元素之后（完全二叉树的树根结点），如何调整剩余元素构建一个新的堆？(从根结点到叶子结点的整个调整的过程，被称为“筛选”)

// 堆排序在最坏的情况下，其时间复杂度仍为O(nlogn)。这是相对于快速排序的优点所在。
// 同时堆排序相对于树形选择排序，其只需要一个用于记录交换（rc）的辅助存储空间，比树形选择排序的运行空间更小。

#define MAX 9
// 单个记录的结构体
typedef struct { int key; } SqNote;
// 记录表的结构体
typedef struct {
  SqNote r[MAX];
  int length;
} SqList;
// 将以r[s]为根结点的子树构成堆，堆中每个根结点的值都比其孩子结点的值大
void HeapAdjust(SqList *H, int s, int m) {
  // 先对操作位置上的结点数据进行保存，放置后序移动元素丢失。
  SqNote rc = H->r[s];
  // 对于第s个结点，筛选一直到叶子结点结束
  for (int j = 2 * s; j <= m; j *= 2) {
    // 找到值最大的孩子结点
    if (j + 1 < m && (H->r[j].key < H->r[j + 1].key)) {
      j++;
    }
    // 如果当前结点比最大的孩子结点的值还大，则不需要对此结点进行筛选，直接略过
    if (!(rc.key < H->r[j].key)) {
      break;
    }
    // 如果当前结点的值比孩子结点中最大的值小，则将最大的值移至该结点，由于rc记录着该结点的值，所以该结点的值不会丢失
    H->r[s] = H->r[j];
    s = j;  // s相当于指针的作用，指向其孩子结点，继续进行筛选
  }
  H->r[s] = rc;  // 最终需将rc的值添加到正确的位置
}
// 交换两个记录的位置
void swap(SqNote *a, SqNote *b) {
  int key = a->key;
  a->key = b->key;
  b->key = key;
}
void HeapSort(SqList *H) {
  // 构建堆的过程
  for (int i = H->length / 2; i > 0; i--) {
    // 对于有孩子结点的根结点进行筛选
    HeapAdjust(H, i, H->length);
  }
  // 通过不断地筛选出最大值，同时不断地进行筛选剩余元素
  for (int i = H->length; i > 1; i--) {
    // 交换过程，即为将选出的最大值进行保存大表的最后，同时用最后位置上的元素进行替换，为下一次筛选做准备
    swap(&(H->r[1]), &(H->r[i]));
    // 进行筛选次最大值的工作
    HeapAdjust(H, 1, i - 1);
  }
}

int main() {
  SqList *L = (SqList *)malloc(sizeof(SqList));
  L->length = 8;
  L->r[1].key = 49;
  L->r[2].key = 38;
  L->r[3].key = 65;
  L->r[4].key = 97;
  L->r[5].key = 76;
  L->r[6].key = 13;
  L->r[7].key = 27;
  L->r[8].key = 49;
  HeapSort(L);
  for (int i = 1; i <= L->length; i++) {
    printf("%d ", L->r[i].key);
  }
  printf("\n");  // 13 27 38 49 49 65 76 97

  return 0;
}
