#include <iostream>

#include "class_adapter.h"
#include "object_adapter.h"

// Adapter 适配器

// 动机（Motivation）：
// 1.在软件系统中，由于应用环境的变化，常常需要将一些现存的对象放在新的环境中应用，
//   但是新环境要求的接口是这些现存对象所不满足的；
// 2.如何应对这种迁移的变化？
//   如何既能利用现有的良好实现，同时又能满足新的应用环境所要求的接口？

// 定义：
// 1.适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作；
// 2.适配器模式把一个类的接口转换成客户希望的另一个接口，
//   使得原本由于接口不兼容而不能一起工作的那些类能一起工作；
// 3.适配器模式分为类适配器模式和对象适配器模式两种，前者类之间的耦合度比后者高，
//   且要求程序员了解现有组件的接口，所以应用相对较少。

// 适配器模式适合的业务场景：
// 1.系统需要使用现有的类，而此类的接口不符合现有的系统需求，
//   需要改进，但不能修改现有的类的情况；
// 2.想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，
//   包括一些可能在将来引进的类一起工作；
// 3.两个类所做的事情相同或相似，但是接口不一致，需要通过适配器来适配；
// 4.可以通过封装适配器类来模拟一个类的行为。

// 适配器模式包含如下角色：
// 1.目标抽象类Target，定义客户端使用的接口，包含一个或多个方法，用于与客户端交互；
// 2.适配者类Adaptee，定义已有的接口，但不符合客户端的期望，
//   包含一些有用的行为，但其接口与客户端不兼容；
// 3.适配器类Adapter，实现目标接口，并包含对被适配者接口的引用，
//   包含必要的方法调用以调用被适配者的方法，并在其基础上添加额外的功能，
//   拥有同时与Client和Adaptee交互的能力的类，
//   通过接受Client的接口调用并将其转换为合适的方法调用，以调用Adaptee类的方法；
// 4.客户端类Client，真实使用适配器进行业务代码编写的类，
//   负责组装不同适配器的业务，以达到满足目标接口要求的目的。

// 要点总结：
// 1.Adapter模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，
//   在遗留代码复用、类库迁移等方面非常有用；
// 2.GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器，
//   但类适配器采用多继承的实现方式，一般不推荐使用，
//   对象适配器采用对象组合的方式，更符合松耦合精神；
// 3.Adapter模式可以实现的非常灵活，不比拘泥于GoF23中定义的两种结构，
//   完全可以将Adapter模式中的现存对象作为新的接口方法参数，来达到适配的目的。

// 在Adapter模式的两种模式中，有一个很重要的概念就是接口继承和实现继承的区别和联系。
// 接口继承和实现继承是面向对象领域的两个重要的概念，接口继承指的是通过继承，
// 子类获得了父类的接口，而实现继承指的是通过继承子类获得了父类的实现（并不统共接口）。
// 在C++中的public继承既是接口继承又是实现继承，
// 因为子类在继承了父类后既可以对外提供父类中的接口操作，又可以获得父类的接口实现。
// 当然可以通过一定的方式和技术模拟单独的接口继承和实现继承，
// 例如可以通过private继承获得实现继承的效果，通过纯抽象基类模拟接口继承的效果，
// private继承后，父类中的接口都变为private，当然只能是实现继承了，
// 但是在C++中pure virtual function也可以提供默认实现，
// 因此这是不纯正的接口继承，但是在Java中可以interface来获得真正的接口继承了。

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 1]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';

  Target* adt;
  switch (type) {
    case 0: {
      Target* adt = new ClassAdapter();
      adt->Request();  // Adaptee::SpecificRequest
      break;
    }
    case 1: {
      Adaptee* ade = new Adaptee;
      Target* adt = new ObjectAdapter(ade);
      adt->Request();  // Adaptee::SpecificRequest
      break;
    }
    default:
      return -1;
      break;
  }

  return 0;
}