#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// 小数分为整数部分和小数部分。最常见的小数形式，4.023，称为十进制形式。小数也可以采用指数形式,2.1E5。C语言同时支持以上两种形式的小数。
// C语言中常用的小数有两种类型，分别是float或double；float称为单精度浮点型，double称为双精度浮点型。
// 小数的长度是固定的，float始终占用4个字节，double始终占用8个字节。
// 一个数字，是有默认类型的：对于整数，默认是int类型；对于小数，默认是double类型。如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：
//  在整数后面紧跟l或者L（不区分大小写）表明该数字是long类型；
//  在小数后面紧跟f或者F（不区分大小写）表明该数字是float类型。
// 在C语言中，整数和小数之间可以相互赋值：
//  将一个整数赋值给小数类型，在小数点后面加0就可以，加几个都无所谓。
//  将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值。
// 由于将小数赋值给整数类型时会“失真”，所以编译器一般会给出警告。

typedef struct {
  unsigned int nMant : 23;  // 尾数部分
  unsigned int nExp : 8;    // 指数部分
  unsigned int nSign : 1;   // 符号位
} FP_SINGLE;

const static int INT_BIT_COUNT = CHAR_BIT * sizeof(int);
char *itobs(int n, char *ps) {
  for (int j = INT_BIT_COUNT - 1; j >= 0; --j, n >>= 1) {
    ps[j] = (1 & n) + '0';
  }
  ps[INT_BIT_COUNT] = '\0';
  return ps;
}

int main() {
  float a = 0.302;
  float b = 128.101;
  double c = 123;
  float d = 112.64E3;
  double e = 0.7623e-2;
  float f = 1.23002398;
  printf("a=%e \nb=%f \nc=%lf \nd=%lE \ne=%lf \nf=%f\n", a, b, c, d, e, f);
  // a=3.020000e-01
  // b=128.100998
  //   128.101转换为浮点格式后，尾数部分过长，被丢掉了，不能“真实”地存储了。128.101转换成二进制为：
  //   10000000.0001100111011011001000101101……（无限循环）
  //   向左移动7位后为：1.00000000001100111011011001000101101……
  //   由此可见，尾数部分为：000 0000 0001 1001 1101 1011 001000101101……
  //   将多出的二进制丢掉后为：000 0000 0001 1001 1101 1011
  //   使用printf输出时，还需要进行还原，还原后的二进制为：10000000.0001100111011011
  //   转换成十进制为128.1009979248046875，按照四舍五入的原则取6位小数，就是128.100998。
  // c=123.000000
  // d=1.126400E+05
  // e=0.007623
  // f=1.230024
  // 1) %f和%lf默认保留六位小数，不足六位以0补齐，超过六位按四舍五入截断。
  // 2) 将整数赋值给float变量时会变成小数。
  // 3) 以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 < 10。

  // 小数还有一种更加智能的输出方式，就是使用%g。%g会对比小数的十进制形式和指数形式，以最短(占用最少的字符)的方式来输出小数，让输出结果更加简练。
  float a1 = 0.00001;
  float b1 = 30000000;
  float c1 = 12.84;
  float d1 = 1.229338455;
  printf("a=%g \nb=%g \nc=%g \nd=%g\n", a1, b1, c1, d1);
  // a=1e-05
  // b=3e+07
  // c=12.84
  // d=1.22934
  // %g默认最多保留六位有效数字，包括整数部分和小数部分；%f和%e默认保留六位小数，只包括小数部分。
  // %g不会在最后强加0来凑够有效数字的位数，而%f和%e会在最后强加0来凑够小数部分的位数。
  // 总之，%g要以最短的方式来输出小数，并且小数部分表现很自然，不会强加零，比%f和%e更有弹性，这在大部分情况下是符合用户习惯的。
  // 除了%g，还有%lg、%G、%lG：
  // %g和%lg分别用来输出float类型和double类型，并且当以指数形式输出时，e小写。
  // %G和%lG也分别用来输出float类型和double类型，只是当以指数形式输出时，E大写。

  float f1 = 251;
  int w = 19.427;
  int x = 92.78;
  int y = 0.52;
  int z = -87.27;
  printf("f = %f, w = %d, x = %d, y = %d, z = %d\n", f1, w, x, y, z);
  // f = 251.000000, w = 19, x = 92, y = 0, z = -87

  char strBin[33] = {0};
  char strBintmp[33] = {0};
  float f2 = 19.625;
  FP_SINGLE *p = (FP_SINGLE *)&f2;
  itobs(p->nSign, strBintmp);
  printf("sign: %s\n", strBintmp);
  memcpy(strBin, strBintmp, 1);
  itobs(p->nExp, strBintmp);
  printf("exp: %s\n", strBintmp);
  memcpy(strBin + 1, strBintmp + 24, 8);
  itobs(p->nMant, strBintmp);
  printf("mant: %s\n", strBintmp);
  memcpy(strBin + 9, strBintmp + 9, 23);
  printf("19.625: %s\n", strBin);
  // sign: 00000000000000000000000000000000
  // exp: 00000000000000000000000010000011
  // mant: 00000000000111010000000000000000
  // 19.625: 01000001100111010000000000000000

  return 0;
}

// 小数在内存中是如何存储的，揭秘诺贝尔奖级别的设计:
// 小数在内存中是以浮点数的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。浮点数是数字在内存中的一种存储格式，它和定点数是相对的。
// C语言使用定点数格式来存储short、int、long类型的整数，使用浮点数格式来存储float、double类型的小数。整数和小数在内存中的存储格式不一样。
// 其实，整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，C语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值
// 精度”两项重要指标之间追求平衡的结果。
// 浮点数和定点数中的“点”指的就是小数点！对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。

// 定点数
// 所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动。
// 假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分。
// 小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的31位都是精确数字。从二进制的角度看，这种定点格式的小数，
// 最多有32位有效数字，但是能保证的是31位；也就是说，整体的精度为31~32。
// 将内存中的所有位（Bit）都置为1，小数的值最大，为2^16-2^-16，极其接近2^16，换算成十进制为65536。将内存中最后一位（第32位）置1，其它位都置0，小数的值最小，
// 为2^-16。这里所说的最小值不是0值，而是最接近0的那个值。
// 用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。
// 在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。
//  电子的质量为：0.0000000000000000000000000009 克 = 9 × 10-28 克
//  太阳的质量为：2000000000000000000000000000000000 克 = 2 × 1033 克
// 如果使用定点数，那么只能按照=前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。

// 浮点数
// C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：flt = (-1)^sign × mantissa × base^exponent
//  flt 是要表示的小数。
//  sign 用来表示flt的正负号，它的取值只能是0或1：取值为0表示flt 是正数，取值为1表示flt是负数。
//  base 是基数，或者说进制，它的取值大于等于2（2、10、16）。数学中常见的科学计数法是基于十进制的，例如6.93×10^13；
//       计算机中的科学计数法可以基于其它进制，例如1.001×2^7 就是基于二进制的，它等价于10010000。
//  mantissa 为尾数，或者说精度，是base进制的小数，并且1≤mantissa＜base，这意味着，小数点前面只能有一位数字；
//  exponent 为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。
// 当base取值为10时，19.625的浮点形式为：19.625 = 1.9625 × 10^1
// 当base取值为2时，将19.625转换成二进制为10011.101，用浮点形式来表示为：19.625 = 10011.101 = 1.0011101×2^4
// 可以看出，当基数（进制）base确定以后，指数exponent实际上就成了小数点的移动位数：
//  exponent大于零，mantissa中的小数点右移exponent位即可还原小数的值；
//  exponent小于零，mantissa中的小数点左移exponent位即可还原小数的值。
// 换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由exponent决定，所以我们将这种表示小数的方式称为浮点数。
// 虽然C语言标准没有规定base使用哪种进制，但是在实际应用中，各种编译器都将base实现为二进制，这样不仅贴近计算机硬件，还能减少转换次数。
// 在基数base已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号sign、尾数mantissa、指数exponent这三个不确定的元素就可以了。
// 以19.625为例，将它转换成二进制形式的浮点数格式：19.625 = 1.0011101×2^4此时符号sign为0，尾数mantissa为1.0011101，指数exponent为4。
// 1) 符号的存储:符号的存储很容易，就像存储short、int等普通整数一样，单独分配出一个位来，用0表示正数，用1表示负数。
//             对于19.625，这一位的值是0。
// 2) 尾数的存储:当采用二进制形式后，尾数部分的取值范围为1≤mantissa＜2，这意味着：尾数的整数部分一定为1，是一个恒定的值，这样就无需在内存中提现出
//             来(其他进制不能省略)，可以将其直接截掉（二进制的优势），只要把小数点后面的二进制数字放入内存中即可。
//             对于1.0011101，就是把0011101放入内存。
// 3) 指数的存储:指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。指数的存储并没有采用像整数一样的补码加符号位的形式。
//             float的指数部分占用8Bits，能表示从0~255的值，取其中间值127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。
//             19.625转换后的指数为4，4+127=131，131换算成二进制为10000011，这就是19.626的指数部分在float中的最终存储形式。
// 综上所述，float类型的19.625在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。

// 为二进制浮点数分配内存
// C语言中常用的浮点数类型为float和double；float始终占用4个字节，double始终占用8个字节:
//  float :符号位(1)|指数部分(8)|尾数部分(23)
//  double:符号位(1)|指数部分(11)|尾数部分(52)
// 先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。
// 中间值的求取有固定的公式。设中间值为 median，指数部分占用的内存为n位，那么中间值为：median = 2^(n-1) - 1
// 对于float，中间值为2^(8-1) - 1 = 127；对于double，中间值为2^(11-1) -1 = 1023。

// 精度问题
// 对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以2，直到余数为0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一
// 定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以2，直到小数部分为0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是5的小数
// 才有可能转换成有限位数的二进制，其它的小数都不行。
// float和double的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须
// 四舍五入，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。
// 对于float，尾数部分有23位，再加上一个隐含的整数1，一共是24位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以
// 外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有24位有效数字，但是能保证的是23位；也就是说，整体的精度为23~24位。如果转换成
// 十进制，2^24 =16777216，一共8位；也就是说，最多有8位有效数字，但是能保证的是7位，从而得出整体精度为7~8位。
// 对于double，同理可得，二进制形式的精度为52~53位，十进制形式的精度为15~16位。

// IEEE754标准
// 浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最
// 复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是性能。
// PC和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。
// Intel在研发8087浮点数协处理器时，聘请到加州大学伯克利分校的William Kahan 教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为8087协处理器设计浮
// 点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被IEEE组织采用为浮点数的业界标准，并于1985年正式发布，这就是IEEE754标准，
// 它等同于国际标准ISO/IEC/IEEE 60559。
// IEEE754简直是天才一般的设计，William Kahan教授也因此获得了1987年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。
// 不过，IEEE754标准的出现晚于C语言标准（最早的ANSI C标准于1983年发布），C语言标准并没有强制编译器采用IEEE754格式，只是说要使用科学计数法的形式来表示
// 浮点数，但是编译器在实现浮点数时，都采用了IEEE754格式，这既符合C语言标准，又符合IEEE标准，何乐而不为。

// 特殊值和非规格化浮点数
// IEEE 754标准规定，当指数exp的所有位都为1时，不再作为“正常”的浮点数对待，而是作为特殊值处理：
//  如果此时尾数mant的二进制位都为0，则表示无穷大：
//  如果符号sign为1，则表示负无穷大；
//  如果符号sign为0，则表示正无穷大。
//  如果此时尾数mant的二进制位不全为0，则表示NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。
// 当指数exp的所有二进制位都为0时，情况也比较特殊。
// 当指数exp的所有二进制位都是0时，我们将这样的浮点数称为“非规格化浮点数”；
// 当指数exp的所有二进制位既不全为0也不全为1时，我们称之为“规格化浮点数”；
// 当指数exp的所有二进制位都是1时，作为特殊值对待。
// 也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数exp。
//  +0 和 -0 的表示
// 对于非规格化浮点数，当尾数mant的所有二进制位都为0时，整个浮点数的值就为0：
//  如果符号sign为0，则表示+0；
//  如果符号sign为1，则表示-0。

// IEEE754为什么增加非规格化浮点数，以float类型为例来说明。
// 对于规格化浮点数，当尾数mant的所有位都为0、指数exp的最低位为1时，浮点数的绝对值最小（符号sign的取值不影响绝对值），为1.0×2^-126，也即2^-126。
// 对于一般的计算，这个值已经很小了，非常接近0值了，但是对于科学计算，它或许还不够小，距离0值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以
// 让最小值更小，更加接近0值。
// 对于非规格化浮点数，当尾数的最低位为1时，浮点数的绝对值最小，为2^-23×2^-126 = 2^-149，这个值比2^-126小了23个数量级，更加即接近0值。
// 最大非规格化数和最小规格化数，它们是连在一起的，是平滑过渡的。

// 舍入模式
// 浮点数的尾数部分mant所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，
// IEEE754列出了四种不同的舍入模式:
// 1) 舍入到最接近的值
//    就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。
//    对于最近舍入模式，IEEE754规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就
//    是对.5的舍入上采用偶数的方式，请看下面的例子。
//     最近舍入模式：Round(0.5) = 0、Round(1.5) = 2、Round(2.5) = 2
//     四舍五入模式：Round(0.5) = 1、Round(1.5) = 2、Round(2.5) = 3
// 2) 向+∞方向舍入（向上舍入）
//    会将结果朝正无穷大的方向舍入。标准库函数ceil()使用的就是这种舍入模式，例如，ceil(1.324) = 2，Ceil(-1.324) = -1。
// 3) 向-∞方向舍入（向下舍入）
//    会将结果朝负无穷大的方向舍入。标准库函数floor() 使用的就是这种舍入模式，例如，floor(1.324) = 1，floor(-1.324) = -2。
// 4) 向0舍入（直接截断）
//    会将结果朝接近 0 的方向舍入，也就是将多余的位数直接丢掉。C语言中的类型转换使用的就是这种舍入模式，例如，(int)1.324 = 1，(int) -1.324 = -1。
// 总结:与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。
