#include <stdio.h>

// 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（缓存）。
// 缓冲区位于用户程序和硬件设备之间，用来缓存数据，目的是让快速的CPU不必等待慢速的输入输出设备，同时减少操作硬件的次数。对于IO密集型的网络应用程序，比如网站、数据库、DNS、CDN
// 等，缓冲区的设计至关重要，它能十倍甚至一百倍得提高程序性能。

// 为什么要引入缓冲区（缓存）
// 缓冲区是为了让低速的输入输出设备和高速的用户程序能够协调工作，并降低输入输出设备的读写次数。
// 硬盘的速度要远低于 CPU，它们之间有好几个数量级的差距，当向硬盘写入数据时，程序需要等待，不能做任何事情，就好像卡顿了一样，用户体验非常差。计算机上绝大多数应用程序都需要和硬
// 件打交道，例如读写硬盘、向显示器输出、从键盘输入等，如果每个程序都等待硬件，那么整台计算机也将变得卡顿。
// 但是有了缓冲区，就可以将数据先放入缓冲区中（内存的读写速度也远高于硬盘），然后程序可以继续往下执行，等所有的数据都准备好了，再将缓冲区中的所有数据一次性地写入硬盘，这样程序就
// 减少了等待的次数，变得流畅起来。
// 缓冲区的另外一个好处是可以减少硬件设备的读写次数。从用户程序到硬件设备要经过好几层的转换，每一层的转换都有时间和空间的开销，而且开销不一定小；一旦用户程序需要密集的输入输出操
// 作，这种开销将变得非常大，会成为制约程序性能的瓶颈。
// 缓冲区其实就是一块内存空间，它用在硬件设备和用户程序之间，用来缓存数据，目的是让快速的 CPU 不必等待慢速的输入输出设备，同时减少操作硬件的次数。

// 缓冲区的类型
// 根据缓冲区对应的是输入设备还是输出设备，可以分为输入缓冲区和输出缓冲区。
// 根据数据刷新（也可以称为清空缓冲区，就是将缓冲区中的数据“倒出”）的时机，可以分为全缓冲、行缓冲、不带缓冲。
// 1) 全缓冲
//    在这种情况下，当缓冲区被填满以后才进行真正的输入输出操作。缓冲区的大小都有限制的，比如 1KB、4MB 等，数据量达到最大值时就清空缓冲区。全缓冲的典型代表是对硬盘文件的读写。
//    在实际开发中，将数据写入文件后，打开文件并不能立即看到内容，只有清空缓冲区，或者关闭文件，或者关闭程序后，才能在文件中看到内容。这种现象，就是缓冲区在作怪。
// 2) 行缓冲
//    在这种情况下，当在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作。行缓冲的典型代表就是标准输入设备（也即键盘）和标准输出设备（也即显示器）。
//    对于printf(),如果不输出\n，那么内容都先保存到缓冲区中。
//    对于scanf()，不管用户输入多少内容，只要不按下回车键，就不进行真正的读取。这是因为scanf()是带有行缓冲的，用户输入的内容会先放入缓冲区，直到用户按下回车键，产生换行符\n，
//    才会刷新缓冲区，进行真正的读取。
// 3) 不带缓冲
//    不带缓冲区，数据就没有地方缓存，必须立即进行输入输出。
//    getche()、getch()就不带缓冲区，输入一个字符后立即就执行了，根本不用按下回车键。Windows下的printf()也不带缓冲区，不管最后有没有换行符\n，都会立即输出。
//    错误信息输出函数perror()也没有缓冲区。错误信息必须刻不容缓、立即、马上显示出来，缓冲区将会增加捕获错误的时间，这是毫无理由的。

// C语言标准的模棱两可
// C语言标准规定，输入输出缓冲区要具有以下特征：
//  当且仅当输入输出不涉及交互设备时，它们才可以是全缓冲的。
//  错误显示设备不能带有缓冲区。
// C标准虽然规定它们不能是全缓冲的，但并没有规定它们到底是行缓冲还是不带缓冲，这就导致不同的平台有不同的实现。
//  1) 输入设备
//     scanf()、getchar()、gets()就是从输入设备（键盘）上读取内容。对于输入设备，没有缓冲区将导致非常奇怪的行为，比如，我们本来想输入一个整数947，没有缓冲区的话，输入9就立
//     即读取了，根本没有机会输入47，所以，没有输入缓冲区是不能接受的。Windows、Linux、Mac OS在实现时都给输入设备带上了行缓冲，所以scanf()、getchar()、gets()在每个平台下
//     的表现都一致。
//     但是在某些特殊情况下，又希望程序能够立即响应用户按键，例如在游戏中，用户按下方向键人物要立即转向，而且越快越好，这肯定就不能带有缓冲区了。Windows下特有的getche()和getch()
//     就是为这种特殊需求而设计的，它们都不带缓冲区。
//  2) 输出设备
//     printf()、puts()、putchar()就是向输出设备（显示器）上显示内容。对于输出设备，有没有缓冲区其实影响没有那么大，顶多是晚一会看到内容，不会有功能性的障碍，
//     所以Windows和Linux、Mac OS 采用了不同的方案：
//      Windows平台下，输出设备是不带缓冲区的；
//      Linux和Mac OS平台下，输出设备带有行缓冲区。

// 缓冲区的刷新（清空）
// 所谓刷新缓冲区，就是将缓冲区中的内容送达到目的地。缓冲区的刷新遵循以下的规则：
//  不管是行缓冲还是全缓冲，缓冲区满时会自动刷新；
//  行缓冲遇到换行符\n时会刷新；
//  关闭文件时会刷新缓冲区；
//  程序关闭时一般也会刷新缓冲区，这个是由标准库来保障的；
//  使用特定的函数也可以手动刷新缓冲区

// scanf()是从标准输入设备（键盘）读取数据，带有行缓冲区的，这让scanf()具有了一些独特的“性格”，例如可以连续输入、可以输入多余的数据等。反过来，scanf()也出现了一些奇怪的行为，
// 例如，有时候两份数据之间有空格会读取失败，而有时候两份数据之间又必须有空格。
// scanf()的这些特性都是有章可循的，其根源就是行缓冲区。
// 当遇到scanf()函数时，程序会先检查输入缓冲区中是否有数据：
//  如果没有，就等待用户输入。用户从键盘输入的每个字符都会暂时保存到缓冲区，直到按下回车键，产生换行符\n，输入结束，scanf()再从缓冲区中读取数据，赋值给变量。
//  如果有数据，那就看是否符合控制字符串的规则：
//   如果能够匹配整个控制字符串，那最好了，直接从缓冲区中读取就可以了，就不用等待用户输入了。
//   如果缓冲区中剩余的所有数据只能匹配前半部分控制字符串，那就等待用户输入剩下的数据。
//   如果不符合，scanf()还会尝试忽略一些空白符，例如空格、制表符、换行符等：
//    如果这种尝试成功（可以忽略一些空白符），那么再重复以上的匹配过程。
//    如果这种尝试失败（不能忽略空白符），那么只有一种结果，就是读取失败。
// 你看，scanf()并不是直接让用户从键盘输入数据，而是先检查缓冲区，处理缓冲区中的数据。
// 注意，scanf()、gets()在读取字符串时会忽略换行符，不会把换行符作为字符串的内容。
// scanf()只有当控制字符串以格式控制符开头时，才会忽略换行符。

// 缓冲区的优点很明显，它加快了程序的运行速度，减少了硬件的读写次数，让整个计算机变得流畅起来；但是，缓冲区也带来了一些负面影响。
// 那么，该如何消除这些负面影响呢？思路其实也很简单，在输入输出之前清空（刷新）缓冲区即可：
//  对于输出操作，清空缓冲区会使得缓冲区中的所有数据立即显示到屏幕上；很明显，这些数据没有地方存放了，只能输出了。
//  对于输入操作，清空缓冲区就是丢弃残留字符，让程序直接等待用户输入，避免引发奇怪的行为。
// 清空输出缓冲区很简单，使用下面的语句即可：fflush(stdout);
// fflush()是一个专门用来清空缓冲区的函数，stdout是standard output的缩写，表示标准输出设备，也即显示器。整个语句的意思是，清空标准输出缓冲区，或者说清空显示器的缓冲区。
// Windows平台下的printf()、puts()、putchar()等输出函数都是不带缓冲区的，所以不用清空。
// 没有一种既简洁明了又适用于所有平台的清空输入缓冲区的方案。只有一种很蹩脚的方案能适用于所有平台，那就是将输入缓冲区中的数据都读取出来，但是却不使用。
// 先说两种通用的方案，虽然它很蹩脚，但是却行之有效:
// 1) 使用getchar()清空缓冲区
//    getchar()是带有缓冲区的，每次从缓冲区中读取一个字符，包括空格、制表符、换行符等空白符，只要我们让getchar()不停地读取，直到读完缓冲区中的所有字符，就能达到清空缓冲区的效果。
//    int c;while((c = getchar()) != '\n' && c != EOF);
//    这种方案的关键之处在于，getchar()是带有缓冲区的，并且一切字符通吃，或者说一切字符都会读取，不会忽略。不过有个缺点，就是要额外定义一个变量c，对于有强迫症的读者来说可能有点难受。
// 2) 使用scanf()清空缓冲区
//    scanf()还有一种高级用法，就是使用类似于正则表达式的通配符，这样它就可以读取所有的字符了，包括空格、换行符、制表符等空白符，不会再忽略它们了。
//    并且，scanf()还允许把读取到的数据直接丢弃，不用赋值给变量。
//    scanf("%*[^\n]"); 第一个scanf()将逐个读取缓冲区中\n之前的其它字符，%后面的*表示将读取的这些字符丢弃，遇到\n字符时便停止读取。此时，缓冲区中尚有一个\n遗留。
//    scanf("%*c"); 第二个scanf()将这个\n读取并丢弃。由于所有从键盘的输入都是以回车结束的，而回车会产生一个\n字符，所以将\n连同它之前的字符全部读取并丢弃之后，也就清除了输入缓冲区。
//    相比使用getchar()，这种方案不用额外定义一个变量，看起来更加整洁。
// 以上两种清空输入缓冲区的方案是通用的，在任何平台、任何编译器、任何情景下都奏效。除此以外，还有其它的方案，常见的有两种，分别是fflush(stdin)和rewind(stdin)。
// 1) fflush(stdin)
//    fflush(stdin)常用于Windows 平台，在VC 6.0、VS2010等较老的编译器下确实能够清空缓冲区。
//    C语言标准规定，当fflush()用于stdout时，必须要有清空输出缓冲区的作用；但是C语言标准并没有规定fflush()用于stdin时的作用，编译器的实现者可以自由决定，所以它的行为是未定义的。
//    较老的微软编译器进行了扩展，赋予了fflush(stdin)清空输入缓冲区的功能，例如VC 6.0、VS2010等；
//    但是，较新的微软编译器又取消了这种扩展，不再支持fflush(stdin)，例如VS2015、VS2017等，在这些版本的编译器下，fflush()是无效的。
//    较老的GCC是不支持fflush(stdin)的，但是最新的GCC又开始支持fflush(stdin)了。
//    LLVM/Clang编译器始终不支持fflush(stdin)。
//    总之，fflush(stdin)这种不标准的写法只适用于一部分编译器，通用性非常差，所以不建议使用。如果你由于个人习惯坚持使用，请测试你的编译器是否支持。
// 2) rewind(stdin)
//    rewind()函数并没有清空缓冲区的功能，但是rewind(stdin)偏偏在某些编译器下会导致清空缓冲区的假象，例如VS2015、LLVM/Clang。在GCC下，rewind(stdin)是没有任何效果的。
// 总结：最靠谱、最通用、最有效的清空输入缓冲区的方案就是使用getchar()或者scanf()将缓冲区中的数据逐个读取出来，其它方案都有或多或少的问题。

// scanf的高级用法：
// 1) 指定读取长度
//    printf()中可以指定最小输出宽度吗？就是在格式控制符的中间加上一个数字，例如，%10d表示输出的整数至少占用10个字符的位置：
//     如果整数的宽度不足10，那么在左边以空格补齐；
//     如果整数的宽度超过了10，那么以整数本身的宽度来输出，10不再起作用。
//    其实，scanf()也有类似的用法，也可以在格式控制符的中间加一个数字，用来表示读取数据的最大长度，例如：
//     %2d表示最多读取两位整数；
//     %10s表示读取的字符串的最大长度为10，或者说，最多读取10个字符。
// 2) 匹配特定的字符
//    %s控制符会匹配除空白符以外的所有字符，它有两个缺点：
//     %s不能读取特定的字符，比如只想读取小写字母，或者十进制数字等，%s就无能为力；
//     %s读取到的字符串中不能包含空白符，有些情况会比较尴尬，例如，无法将多个单词存放到一个字符串中，因为单词之间就是以空格为分隔的，%s遇到空格就读取结束了。
//    要想解决以上问题，可以使用scanf()的另外一种字符匹配方式，就是%[xxx]，[]包围起来的是需要读取的字符集合。例如，%[abcd]表示只读取字符abcd，遇到其它的字符就读取结束；
//    注意，这里并不强调字符的顺序，只要字符在abcd范围内都可以匹配成功，所以你可以输入abcd、dcba、ccdc、bdcca等。
//    为了简化字符集合的写法，scanf()支持使用连字符-来表示一个范围内的字符，例如%[a-z]、%[0-9]等。
//    连字符左边的字符对应一个ASCII码，连字符右边的字符也对应一个ASCII码，位于这两个ASCII码范围以内的字符就是要读取的字符。
//    注意，连字符左边的ASCII码要小于右边的，如果反过来，那么它的行为是未定义的。
//    常用的连字符举例：
//     %[a-z]表示读取abc...xyz范围内的字符，也即小写字母；
//     %[A-Z]表示读取ABC...XYZ范围内的字符，也即大写字母；
//     %[0-9]表示读取012...789范围内的字符，也即十进制数字。
//    你也可以将它们合并起来，例如：
//     %[a-zA-Z]表示读取大写字母和小写字母，也即所有英文字母；
//     %[a-z-A-Z0-9]表示读取所有的英文字母和十进制数字；
//     %[0-9a-f]表示读取十六进制数字。
//    假如现在有一种需求，就是读取换行符以外的所有字符，或者读取0~9以外的所有字符，该怎么实现呢？总不能把剩下的字符都罗列出来吧，一是麻烦，二是不现实。
//    C语言的开发者们早就考虑到这个问题了，scanf()允许我们在%[]中直接指定某些不能匹配的字符，具体方法就是在不匹配的字符前面加上^，例如：
//     %[^\n]表示匹配除换行符以外的所有字符，遇到换行符就停止读取；
//     %[^0-9]表示匹配除十进制数字以外的所有字符，遇到十进制数字就停止读取。
// 3) 丢弃读取到的字符
//    每个格式控制符都要对应一个变量，把读取到的数据放入对应的变量中。也可以不这样做，scanf()允许把读取到的数据直接丢弃，不往变量中存放，具体方法就是在%后面加一个*
//     %*d表示读取一个整数并丢弃；
//     %*[a-z]表示读取小写字母并丢弃；
//     %*[^\n]表示将换行符以外的字符全部丢弃。
//    清空缓冲区的操作：scanf("%*[^\n]"); scanf("%*c");
//    等到需要清空缓冲区的时候，缓冲区中的最后一个字符一定是换行符\n，因为输入缓冲区是行缓冲模式，用户按下回车键会产生换行符，结束本次输入，然后输入函数开始读取。
//    scanf("%*[^\n]");将换行符前面的所有字符清空，scanf("%*c");将最后剩下的换行符清空。
//    将这两条语句合并起来，写作：scanf("%*[^\n]%*c");合并以后的语句不能清空单个换行符，因为该语句要求换行符前边至少要有一个其它的字符，单个换行符会导致匹配失败。
// scanf()控制字符串的完整写法为： %{*} {width} type
// 其中，{}表示可有可无。各个部分的具体含义是：
//  type表示读取什么类型的数据，例如%d、%s、%[a-z]、%[^\n]等；type必须有。
//  width表示最大读取宽度，可有可无。
//  *表示丢弃读取到的数据，可有可无。

int main() {
  int flag = 13;
  if (1 == flag) {
    // scanf()连续输入：
    int a, b, c;
    // 执行到第一个scanf()，由于缓冲区中没有数据，所以会等待用户输入。从键盘输入100 200 300后按下回车键，输入就结束了，scanf()开始从缓冲区中读取数据。
    // 第一个scanf()的控制字符串是"%d"，会匹配到第一个整数，也就是100，于是将100赋值给变量a，并将内部的位置标记移动到100以后，此时缓冲区中剩下 200 300↙。
    // 注意，换行符也是一个字符，也会进入缓冲区。
    scanf("%d", &a);
    // 第二个scanf()的控制字符串也是"%d"，需要读取一个整数，而此时缓冲区中的内容是 200 300↙，开头是一个空格，并不是一个有效的数字，不符合控制字符串的规则。
    // 空格是一个空白符，此处是可以忽略的，于是scanf()忽略空格后再继续匹配，就得到了数字200，终于匹配成功了。
    scanf("%d", &b);
    // 到了第三个scanf()，缓冲区中剩下 300↙，同样会忽略开头的空格，匹配到数字300。
    scanf("%d", &c);
    // 最终，三个scanf()都匹配成功了，缓冲区中只留下了↙。嗯，那就留着吧，已经没用了，等程序运行结束了，会释放缓冲区内存，一切数据都灰飞烟灭了。
    printf("a=%d, b=%d, c=%d\n", a, b, c);
    // 100 200 300↙
    // a=100, b=200, c=300
  } else if (2 == flag) {
    // scanf() 读取失败：
    int a, b = 999;
    char str[30];
    printf("b=%d\n", b);
    // 第一个scanf()时等待用户输入，从键盘输入100 http://c.biancheng.net，按下回车键，scanf()匹配到100，赋值给变量a，同时将内部的位置指针移动到100后面。
    scanf("%d", &a);
    // 到了第二个scanf()，缓冲区中有数据，会直接读取。此时缓冲区中的内容为nihao↙，即使忽略开头的空格也不是scanf()想要的整数，所以匹配失败了，不会给变量b赋值，
    // b的值保持不变，这就是两次输出变量b的值相同的原因。
    scanf("%d", &b);
    // 匹配失败意味着不会移动内部的位置指针，此时缓冲区中的内容仍然是nihao↙。
    // 执行到底三个scanf()时，它想要一个字符串，这不是正好捡漏吗，把nihao赋值给str就好了。
    scanf("%s", str);
    printf("a=%d, b=%d, str=%s\n", a, b, str);
    // b=999
    // 100 niha↙
    // a=100, b=999, str=nihao
  } else if (3 == flag) {
    // 不能忽略空白符的情形：
    // 输入a=99，按下回车键，程序竟然运行结束了，只有第一个scanf()成功读取了数据，第二个scanf()仿佛没有执行一样，根本没有给用户任何机会去输入数据。这是为什么呢？
    int a = 1, b = 2;
    scanf("a=%d", &a);
    // 第一个scanf()后，将99赋值给了a，缓冲区中只剩下一个换行符\n；到了第二个scanf()，发现缓冲区中有内容，但是又不符合控制字符串的格式，于是尝试忽略这个空白符。
    // 注意，这个时候的空白符是不能忽略的，所以就没有办法了，只能读取失败了。
    // 空白符在大部分情况下都可以忽略。但是当控制字符串不是以格式控制符%d、%c、%f等开头时，空白符就不能忽略了，它会参与匹配过程，如果匹配失败，scanf()读取就失败了。
    // 第二个scanf()的开头并不是格式控制符，而是写死的b字符，所以不会忽略换行符，而换行符和b又不匹配，怎么办呢？没办法，只能读取失败了。
    scanf("b=%d", &b);
    printf("a=%d, b=%d\n", a, b);
    // a=99↙
    // a=99, b=2

    // 第二个scanf()也读取失败了。执行到第二个scanf()时，缓冲区中剩下b=200↙，开头的空格依然不能忽略，然而又和控制字符串不匹配，所以只能读取失败了。
    // a=99 b=200↙
    // a=99, b=2

    // 不要让两份数据之间有空白符。这样a和b都能够正确读取了。
    // a=99b=200↙
    // a=99, b=200
  } else if (4 == flag) {
    int a = 1, b = 2;
    scanf("a=%d", &a);
    // 第二个scanf()的控制字符串以%d开头，就可以忽略换行符了。忽略换行符以后，缓冲区中就没有内容了，所以会等待用户输入。输入200以后，第二个scanf()就匹配成功了，将200赋值给变量b。
    scanf("%d", &b);
    printf("a=%d, b=%d\n", a, b);
    // a=100↙
    // 200↙

    // a=100, b=200
    // a=99 200↙
    // a=99, b=200
  } else if (5 == flag) {
    int a = 1, b = 2;
    scanf("a=%d", &a);
    scanf(" b=%d", &b);
    printf("a=%d, b=%d\n", a, b);
    // a=99 b=200↙
    // a=99, b=200
  } else if (6 == flag) {
    // 使用getchar()清空缓冲区
    int a = 1, b = 2;
    char c;
    scanf("a=%d", &a);
    while ((c = getchar()) != '\n' && c != EOF)
      ;  // 在下次读取前清空缓冲区
    scanf("b=%d", &b);
    printf("a=%d, b=%d\n", a, b);
    // 按下第一个回车键后，只有第一个scanf()读取成功了，第二个scanf()并没有开始读取，等我们再次输入并按下回车键后，第二个scanf()才开始读取，这就符合我们的操作习惯了。
    // 如果没有清空缓冲区的语句，按下第一个回车键后，两个scanf()都读取了，只是第二个scanf()读取失败了。
    // a=100↙
    // b=200↙
    // a=100, b=200

    // 第一次输入的多余内容并没有起作用，就是因为它们在第二个scanf()之前被清空了。
    // a=100b=200↙
    // b=300↙
    // a=100, b=300
  } else if (7 == flag) {
    // 使用scanf()清空缓冲区
    int a = 1, b = 2;
    scanf("a=%d", &a);
    scanf("%*[^\n]");
    scanf("%*c");  // 在下次读取前清空缓冲区
    scanf("b=%d", &b);
    printf("a=%d, b=%d\n", a, b);
    // a=100↙
    // b=200↙
    // a=100, b=200

    // a=100b=200↙
    // b=300↙
    // a=100, b=300
  } else if (8 == flag) {
    // 指定读取长度
    // 限制读取数据的长度在实际开发中非常有用，最典型的一个例子就是读取字符串：我们为字符串分配的内存是有限的，用户输入的字符串过长就存放不了了，就会冲刷掉其它的数据，
    // 从而导致程序出错甚至崩溃；如果被黑客发现了这个漏洞，就可以构造栈溢出攻击，改变程序的执行流程，甚至执行自己的恶意代码，这对服务器来说简直是灭顶之灾。
    // 在用gets()函数读取字符串的时候，有一些编译器会提示不安全，建议替换为gets_s()函数，就是因为gets()不能控制读取到的字符串的长度，风险极高。
    // 虽然scanf()可以控制字符串的长度，但是字符串中却不能包含空白符，这是硬伤，所以scanf()暂时还无法替代gets()。
    int n;
    float f;
    char str[23];
    scanf("%2d", &n);
    scanf("%*[^\n]");
    scanf("%*c");  // 清空缓冲区
    scanf("%5f", &f);
    scanf("%*[^\n]");
    scanf("%*c");  // 清空缓冲区
    scanf("%5s", str);
    printf("n=%d, f=%g, str=%s\n", n, f, str);
    // 20↙
    // 100.5↙
    // nihao↙
    // n=20, f=100.5, str=nihao

    // 1234↙
    // 10.1234↙
    // nihaowoyehao↙
    // n=12, f=10.12, str=nihao
  } else if (9 == flag) {
    // 匹配特定的字符
    char str[30];
    scanf("%[abcd]", str);
    printf("%s\n", str);
    // asjdfbnihac↙
    // a

    // abcdefg↙
    // abcd

    // aaaa↙
    // aaaa

    // abdc↙
    // abdc
  } else if (10 == flag) {
    // 使用连接符
    char str[30];
    scanf("%[a-zA-Z]", str);  // 只读取字母
    printf("%s\n", str);
    // asdfAJKSDFsdsd↙
    // asdfAJKSDFsdsd

    // ASADSAsdfsd1012dfasdf↙
    // ASADSAsdfsd
  } else if (11 == flag) {
    // 不匹配某些字符
    char str1[30], str2[30];
    scanf("%[^0-9]", str1);
    scanf("%*[^\n]");
    scanf("%*c");  // 清空缓冲区
    scanf("%[^\n]", str2);
    printf("str1=%s \nstr2=%s\n", str1, str2);
    // asdfwer12↙
    // asdf↙
    // str1=asdfwer
    // str2=asdfd
  } else if (12 == flag) {
    // scanf()还可以指定字符串的最大长度，指定字符串中不能包含哪些字符，这是gets()不具备的功能。
    // 总之，scanf()不仅可以完全替代gets()，并且比gets()的功能更加强大。
    // 读取一行不能包含十进制数字的字符串，并且长度不能超过10：
    char str[11];
    scanf("%10[^0-9\n]", str);
    printf("str=%s\n", str);
    // aaabbbcccddd↙
    // str=aaabbbcccd
  } else if (13 == flag) {
    // 丢弃读取到的字
    int n;
    char str[30];
    // 整数100被第一个scanf()中的%*d读取后丢弃了，整数999被第%d读取到，并赋值给n。
    scanf("%*d %d", &n);
    // 此时缓冲区中剩下abcxyzABCXYZ，第二个scanf()将abcxyz 读取并丢弃。
    scanf("%*[a-z]");
    // 剩下的ABCXYZ被最后一个scanf()读取到并赋值给str。
    scanf("%[^\n]", str);
    printf("n=%d, str=%s\n", n, str);
    // 100 999abcxyzABCXYZ↙
    // n=999, str=ABCXYZ
  }

  return 0;
}