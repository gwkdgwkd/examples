#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 通过统计序列中各个元素出现的次数，完成对整个序列的升序或降序排序，这样的排序算法称为计数排序算法。

// 使用计数排序算法完成升序排序的过程为：
// 1.找到序列中的最大值（用max表示）。对于{4, 2, 2, 8, 3, 3, 1}序列来说，最大值是8。
// 2.创建一个长度为max+1、元素初值全部为0的数组，为数组中[1,max]区域内的各个空间建立索引：
//   找到序列中的最小值（用min表示），作为数组下标为1的存储空间的索引；
//   将max作为数组下标为max的存储空间的索引；
//   将max-1作为数组下标为max-1的存储空间的索引；
//   将max-2作为数组下标为max-2的存储空间的索引；
//   ......
//   为某个存储空间建立索引，其实就是为这个存储空间贴上一个独一无二的标签，
//   借助索引（标签），我们可以快速地找到此空间并访问内部的数据。
//   对于长度为max+1的数组，计数排序算法的实现过程不会用到下标为0的数组空间。
// 3.统计待排序序列中各个元素的出现次数，存储到以该元素为索引的数组空间中。
//   例如，待排序序列中元素2出现了两次，所以索引（下标）为2的数组空间中存储2。
//   更新后的数组：[0(0),1(1),2(2),2(3),1(4),0(5),0(6),0(7),1(8)]
// 4.进一步加工数组中存储的数据。从数组下标为1的位置开始，按照如下公式修改数组中存储的元素：
//   array[i] = array[i-1] + array[i]，其中i的取值范围是[1, max]
//   修改后的数组为：[0(0),1(1),3(2),5(3),6(4),6(5),6(6),6(7),7(8)]
// 5.遍历待排序列中的元素，以该元素为索引获取数组中存储的值，此值即为序列排序后元素应处的位置。
// 6.当确定了一个元素排序后的位置，需要将数组中该元素为索引对应的值减去1。
// 以上6步就是计数排序算法的整个实现思路，对应的时间复杂度为O(n)。

// 缺点：
// 1.基本上只有在排序后立刻输出时有作用。
//   这是因为，如果你把输入放在一个数组中，计数排序是无法改变这个数组的，
//   因为它需要另外一个数组来统计各个数字的出现个数。
// 2.计数排序只能排序非负整数：
//   这与我们数组的特性相关，数组的索引是非负整数，所以排序的数字也只能是非负整数。

#define MAX 100  // 待排序序列中的最大值不能超过100
int getMax(int *list, int size) {  // 找到数组中的最大值
  int i, max = list[0];
  for (i = 1; i < size; i++) {
    if (list[i] > max) max = list[i];
  }
  return max;
}
void countingSort(int *list, int size) {
  int i;
  // 第1步，找到序列中的最大值
  int max = getMax(list, size);
  // 第2步，创建一个数组，长度至少为max+1，并初始化为0
  int array[MAX] = {0};
  int *output = (int *)malloc(sizeof(int) * size);
  memset(output, 0, sizeof(int) * size);
  // 第3步，统计各个元素的出现次数，并存储在相应的位置上
  for (i = 0; i < size; i++) {
    array[list[i]]++;
  }
  // 第4步，累加array数组中的出现次数
  for (i = 1; i <= max; i++) {
    array[i] += array[i - 1];
  }
  // 第5步，根据array数组中的信息，找到各个元素排序后所在位置，存储在output数组中
  for (i = size - 1; i >= 0; i--) {
    output[array[list[i]] - 1] = list[i];
    // 第6步，数组相应位置上的值减1
    array[list[i]]--;
  }
  // 将output数组中的数据原封不动地拷贝到list数组中
  for (i = 0; i < size; i++) {
    list[i] = output[i];
  }
}
void print(int *list, int size) {
  for (int i = 0; i < size; ++i) {
    printf("%d ", list[i]);
  }
  printf("\n");
}
int main() {
  int list[] = {35, 33, 42, 10, 14, 19, 27, 44};
  countingSort(list, sizeof(list) / sizeof(int));  // 进行计数排序
  print(list, sizeof(list) / sizeof(int));         // 10 14 19 27 33 35 42 44
}