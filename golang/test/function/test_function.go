package word

import "unicode"

// Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测
// 试函数,测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的,而且它
// 很容易延伸到基准测试和示例文档。

// go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内,所有以_test.go为后缀
// 名的源文件在执行go build时不会被构建成包的一部分,它们是go test测试的一部分。

// 在*_test.go文件中,有三种类型的函数:测试函数、基准测试(benchmark)函数、示例函
// 数。一个测试函数是以Test为函数名前缀的函数,用于测试程序的一些逻辑行为是否正确;
// go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以
// Benchmark为函数名前缀的函数,它们用于衡量一些函数的性能;go test命令会多次运行基
// 准函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数,提供一个由
// 编译器保证正确性的示例文档。

// go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数,生成一个临时的main
// 包用于调用相应的测试函数,接着构建并运行、报告测试结果,最后清理测试中生成的临时文件。

// go test命令如果没有参数指定包那么将默认采用当前目录对应的包(和go build命令一样)。
// 参数-v可用于打印每个测试函数的名字和运行时间。
// 参数-run对应一个正则表达式,只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行。
// go test -v -run ="French|Canal"

// 一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需
// 要测试包公开的文档和API行为,内部实现对测试代码是透明的。相反,白盒测试有访问包内
// 部函数和数据结构的权限,因此可以做到一些普通客户端无法实现的测试。例如,一个白盒
// 测试可以在每个操作之后检测不变量的数据类型。(白盒测试只是一个传统的名称,其实称
// 为clear	box测试会更准确。)
// 黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮,随着软件实现的完善测试代码
// 很少需要更新。它们可以帮助测试者了解真实客户的需求,也可以帮助发现API设计的一些不
// 足之处。相反,白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。

// 考虑下这两个包:net/url包,提供了URL解析的功能;net/http包,提供了web服务和HTTP客
// 户端的功能。如我们所料,上层的net/http包依赖下层的net/url包。然后,net/url包中的一个测
// 试是演示不同URL和HTTP客户端的交互行为。也就是说,一个下层包的测试代码导入了上层的包。
// 这样的行为在net/url包的测试代码中会导致包的循环依赖,Go语言规范是禁止包的循环依赖的。
// 不过我们可以通过外部测试包的方式解决循环依赖的问题,也就是在net/url包所在的目录声明
// 一个独立的url_test测试包。
// 通过避免循环的导入依赖,外部测试包可以更灵活地编写测试,特别是集成测试(需要测试
// 多个组件之间的交互),可以像普通应用程序那样自由地导入其他包。
// 可以用go list命令查看包对应目录中哪些Go源文件是产品代码,哪些是包内测试,还有
// 哪些是外部测试包。我们以fmt包作为一个例子:GoFiles表示产品代码对应的Go源文件列
// 表;也就是go build命令要编译的部分。
// go list -f={{.GoFiles}} fmt // [doc.go errors.go format.go print.go scan.go]
// go list -f={{.TestGoFiles}} fmt // [export_test.go]
// go list -f={{.XTestGoFiles}} fmt // [errors_test.go example_test.go fmt_test.go
// gostringer_example_test.go scan_test.go stringer_example_test.go stringer_test.go]

// 许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测
// 试函数的机制(通常使用反射或元数据),通过设置一些“setup”和“teardown”的钩子函数来执
// 行测试用例运行的初始化和之后的清理操作,同时测试工具箱还提供了很多类似assert断言、
// 值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数(通常使用异常机
// 制)。虽然这些机制可以使得测试非常简洁,但是测试输出的日志却会像火星文一般难以理
// 解。此外,虽然测试最终也会输出PASS或FAIL的报告,但是它们提供的信息格式却非常不利
// 于代码维护者快速定位问题,因为失败信息的具体含义非常隐晦,比如“assert:0==1”或成页的海量跟踪日志。
// Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作,定义函数避免重
// 复,就像普通编程那样。编写测试并不是一个机械的填空过程;一个测试也有自己的接口,
// 尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息,
// 它只要清晰简洁地描述问题的症状即可,有时候可能还需要一些上下文信息。在理想情况
// 下,维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试
// 不应该在遇到一点小错误时就立刻退出测试,它应该尝试报告更多的相关的错误信息,因为
// 我们可能从多个失败测试的模式中发现错误产生的规律。
// 避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳
// 定。特别是对断言部分要有所选择。不要对字符串进行全字匹配,而是针对那些在项目的发
// 展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的
// 必要信息的函数,虽然这可能会带来很多前期的工作,但是它可以帮助迅速及时修复因为项
// 目演化而导致的不合逻辑的失败测试。

// 测试能证明缺陷存在,而无法证明没有缺陷。再多的测试也不能证明一个程序没有BUG。在最好的情况
// 下,测试可以增强我们的信心:代码在很多重要场景下是可以正常工作的。
// 语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。
// -coverprofile标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说,在运行每个测
// 试前,它将待测代码拷贝一份并做修改,在每个词法块都会设置一个布尔标志变量。当被修
// 改后的被测试代码运行退出时,将统计日志数据写入c.out文件,并打印一部分执行的语句的
// 一个总结。(如果你需要的是摘要,使用go test -cover)
// 如果使用了-covermode=count标志参数,那么将在每个代码块插入一个计数器而不是布尔标
// 志量。在统计结果中记录了每个块的执行次数,这可以用于衡量哪些是被频繁执行的热点代码。
// go test -coverprofile=c.out
// go tool cover -html=c.out // 生成一个HTML报告,然后在浏览器中打开
// go tool命令运行Go工具链的底层可执行程序。这些底层可执行程序放在
// $GOROOT/pkg/tool/${GOOS}_${GOARCH}目录。因为有go uild命令的原因,很少直接调用这些底层工具。
// 实现100%的测试覆盖率听起来很美,但是在具体实践中通常是不可行的,也不是值得推荐的
// 做法。因为那只能说明代码被执行过而已,并不意味着代码就是没有BUG的;因为对于逻辑
// 复杂的语句需要针对不同的输入执行多次。有一些语句,例如上面的panic语句则永远都不会
// 被执行到。另外,还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试
// 从本质上来说是一个比较务实的工作,编写测试代码和编写应用代码的成本对比是需要考虑
// 的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方,但是设计好的测试用例和编写
// 应用代码一样需要严密的思考。

// 基准测试是测量一个程序在固定工作负载下的性能。在Go语言中,基准测试函数和普通测试
// 函数写法类似,但是以Benchmark为前缀名,并且带有一个*testing.B类型的参数;*testing.B
// 参数除了提供和*testing.T类似的方法,还有额外一些和性能测量相关的方
// 法。它还提供了一个整数N,用于指定操作执行的循环次数。
// go test -bench=.
// BenchmarkIsPalindrome-8,表示运行时对应的GOMAXPROCS的值,这对于一些与并发相关的基准测试是重要的信息。
// go test -bench=. -benchmem // -benchmem 命令行标志参数将在报告中包含内存的分配数据统计。

// 只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需
// 要当心,因为一项分析操作可能会影响其他项的分析结果。
// $go test -cpuprofile=cpu.out // CPU剖析数据标识了最耗CPU时间的函数。
// $go test -blockprofile=block.out // 阻塞剖析则记录阻塞goroutine最久的操作,例如系统调用、管道发送和接收,还有获取锁等。
// $go test -memprofile=mem.out // 堆剖析则标识了最耗内存的语句。
// 一旦我们已经收集到了用于分析的采样数据,我们就可以使用pprof来分析这些数据。这是Go
// 工具箱自带的一个工具,但并不是一个日常工具,它对应go tool	pprof命令。该命令有许多
// 特性和选项,但是最基本的是两个参数:生成这个概要文件的可执行程序和对应的剖析数据。
// 虽然go test通常在测试完成后就丢弃临时用的测试程序,但是在启用分析的时候会将测试程序保存为
// foo.test文件,其中foo部分对应待测包的名字。
// go test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http
// -run=NONE参数禁止那些简单测试。
// -text用于指定输出格式,在这里每行是一个函数,根据使用CPU的时间长短来排序。
// -nodecount=10参数限制了只输出前10行的结果。
// 对于一些更微妙的问题,你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具,参数-web用于
// 生成函数的有向图,标注有CPU的使用和最热点的函数等信息。

// func IsPalindrome(s string) bool {
// 	for i := range s {
// 		if s[i] != s[len(s)-1-i] {
// 			return false
// 		}
// 	}
// 	return true
// }

func IsPalindrome(s string) bool {
	var letters []rune
	for _, r := range s {
		if unicode.IsLetter(r) {
			letters = append(letters, unicode.ToLower(r))
		}
	}
	for i := range letters {
		if letters[i] != letters[len(letters)-1-i] {
			return false
		}
	}
	return true
}
