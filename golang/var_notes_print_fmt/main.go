/*
Go语言的代码通过包(package)组织,包类似于其它语言里的库
(libraries)或者模块(modules)。一个包由位于单个目录下
的一个或多个.go源代码文件组成,目录定义包的作用。
*/
package main // 每个源文件都以一条package声明语句开始。

// Go的标准库提供了100多个包,以支持常见功能,如输入、输出、排序以及文本处理。
// import声明必须跟在文件的package声明之后。
import "fmt" // 含有格式化输出、接收输入的函数。

// go run main.go
// go build helloworld.go
// go get gopl.io/ch1/helloworld
func main() {
	// Go语言原生支持Unicode,它可以处理全世界任何语言的文本。
	fmt.Println("hello，世界") // 在输出内容的结尾添加一个换行符
	fmt.Print("hello，世界\n") // 直接输出内容
	fmt.Printf("%s\n", "hello，世界")

	// go语言中有两种注释的方法,单行//和多行/*...*/
	fmt.Println("A", "B", "C") // A B C
	fmt.Print("A", "B", "C\n") // ABC

	// go语音中变量定义了以后必须要使用,否则报错
	var a int = 10
	var b = "nihao"
	c := 1.5
	fmt.Println("a=", a, "b=", b, "c=", c)
	fmt.Printf("a=%v b=%v c=%v\n", a, b, c)

	// printf系列函数都支持format格式化参数:
	// 1.通用占位符
	// %v,值的默认格式表示
	fmt.Printf("%v\n", 100) // 100
	fmt.Printf("%v\n", false) // false
	o := struct{ name string }{"小王子"}
	fmt.Printf("%v\n", o) // {小王子}
	// %+v,类似%v，但输出结构体时会添加字段名
	fmt.Printf("%+v\n", o) // {name:小王子}
	// %#v,值的Go语法表示
	fmt.Printf("%#v\n", o) // struct { name string }{name:"小王子"}
	// %T,打印值的类型
	fmt.Printf("%T\n", o) // struct { name string }
	// %%,百分号
	fmt.Printf("100%%\n") // 100%

	// 2.布尔型
	// %t,true或false
	fmt.Printf("%t %t\n", true, false) // true false
	
	// 3.整型
	n := 75
	// %b,表示为二进制
	fmt.Printf("%b\n", n) // 1001011
	// %c,该值对应的unicode码值
	fmt.Printf("%c\n", n) // K
	// %d,表示为十进制
	fmt.Printf("%d\n", n) // 75
	// %o,表示为八进制
	fmt.Printf("%o\n", n) // 113
	// %x,表示为十六进制，使用a-f
	fmt.Printf("%x\n", n) // 4b
	// %X,表示为十六进制，使用A-F
	fmt.Printf("%X\n", n) // 4B
	// %U,表示为Unicode格式：U+1234，等价于”U+%04X”
	fmt.Printf("%x %U\n", '我', '我') // 6211 U+6211
	// %q,该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
	fmt.Printf("%q\n", n) // 'K'

	// 4.浮点数与复数
	f := 12.34
	// %b,无小数部分、二进制指数的科学计数法，如-123456p-78
	fmt.Printf("%b\n", f) // 6946802425218990p-49
	// %e,科学计数法，如-1234.456e+78
	fmt.Printf("%e\n", f) // 1.234000e+01
	// %E,科学计数法，如-1234.456E+78
	fmt.Printf("%E\n", f) // 1.234000E+01
	// %f,有小数部分但无指数部分，如123.456
	fmt.Printf("%f\n", f) // 12.340000
	// %F,等价于%f
	fmt.Printf("%F\n", f) // 12.340000
	// %g,根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
	fmt.Printf("%g\n", f) // 12.34
	// %G,根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）
	fmt.Printf("%G\n", f) // 12.34

	// 5.字符串和[]byte
	s := "小王子"
	// %s,直接输出字符串或者[]byte
	fmt.Printf("%s\n", s) // 小王子 
	// %q,该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
	fmt.Printf("%q\n", s) // "小王子"
	// %x,每个字节用两字符十六进制数表示（使用a-f)
	fmt.Printf("%x\n", s) // e5b08fe78e8be5ad90
	// %X,每个字节用两字符十六进制数表示（使用A-F）
	fmt.Printf("%X\n", s) // E5B08FE78E8BE5AD90

	// 6.指针
	p := 10
	// %p,表示为十六进制，并加上前导的0x
	fmt.Printf("%p\n", &p) // 0xc420012160
	fmt.Printf("%#p\n", &p) // c420012160

	// 7.宽度标识符
	/*
	宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。
	精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点
	号后没有跟数字，表示精度为0。
	*/
	// %f,默认宽度，默认精度
	fmt.Printf("%f\n", f) // 12.340000
	// %9f,宽度9，默认精度
	fmt.Printf("%9f\n", f) // 12.340000
	// %.2f,默认宽度，精度2
	fmt.Printf("%.2f\n", f) // 12.34
	// %9.2f,宽度9，精度2
	fmt.Printf("%9.2f\n", f) //     12.34
	// %9.f,宽度9，精度0
	fmt.Printf("%9.f\n", f) //        12

	// 8.其他falg
	// '+',总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；
	fmt.Printf("%+d %+d\n", 5, -6) // +5 -6
	fmt.Printf("%+q\n","是什么") // "\u662f\u4ec0\u4e48"
	// ' ',对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格
	fmt.Printf("% d % d\n", 5, -6) //  5 -6
	fmt.Printf("% x\n","是什么") // e6 98 af e4 bb 80 e4 b9 88
	fmt.Printf("% X\n","是什么") // E6 98 AF E4 BB 80 E4 B9 88
	// '-',在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；
	fmt.Printf("[%-5s]\n","是什么") // [是什么  ]
	fmt.Printf("[%-5.2s]\n","是什么") // [是什   ]
	fmt.Printf("[%-5.7s]\n","是什么") // [是什么  ]
	fmt.Printf("[%5.7s]\n","是什么") // [  是什么]
	// '#',八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；
	fmt.Printf("%#o\n", 10) // 012
	fmt.Printf("%#x\n", 12) // 0xc
	fmt.Printf("%#X\n", 12) // 0xC
	fmt.Printf("%#p %p\n", &p, &p) // c420012160 0xc420012160
	fmt.Printf("%#q ;%q\n", "是什么", "是什么") // `是什么` ;"是什么"
	fmt.Printf("%#q ;%q\n", 5, 5) // '\x05' ;'\x05'
	fmt.Printf("%#U ;%U\n", '我', '我') // U+6211 '我' ;U+6211
	// '0',使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；
	fmt.Printf("[%05s]\n","是什么") // [00是什么]

}

/*
Go语言不需要在语句或者声明的末尾添加分号,除非一行上有多条语句。实际上,编译器会
主动把特定符号后的换行符转换为分号,	因此换行符添加的位置会影响Go代码的正确解析(译
注:比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、
fallthrough或return中的一个、运算符和分隔符++、-- ) 、]或}中的一个)。举个例子,
函数的左括号{必须和func数声明在同一行上,且位于末尾,不能独占一行,而在表达式x+y中,
可在+后换行,不能在+换行(译注:以+结尾的话不会被插入分号分隔符,但是以x结尾的话则会
分号分隔符,从而导致编译错误)。
*/

/*
Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式(译注:这个
格式化工具没有任何可以调整代码格式的参数,Go语言就是这么任性),并且go工具中的fmt子
命令会对指定包,	否则默认为当前目录,	中所有.go源文件应用gofmt命令。
*/

/*
Go语言是从Ken Thompson发明的B语言、Dennis M. Ritchie发明的C语言逐步演化过来的，
是C语言家族的成员，因此很多人将Go语言称为21世纪的C语言。
纵观这几年来的发展趋势，Go语言已经成为云计算、云存储时代最重要的基础编程语言。
*/

/*
在C语言发明之后约5年的时间之后（1978年），Brian W. Kernighan和Dennis M. Ritchie合作
编写出版了C语言方面的经典教材《The C Programming Language》，该书被誉为C语言程 序员的
圣经，作者也被大家亲切地称为K&R。同样在Go语言正式发布（2009年）约5年之后 （2014年开始写作，
2015年出版），由Go语言核心团队成员Alan A. A. Donovan和K&R中的 Brian W. Kernighan合作
编写了Go语言方面的经典教材《The Go Programming Language》。Go语言被誉为21世纪的C语言，
如果说K&R所著的是圣经的旧约，那么D&K所 著的必将成为圣经的新约。
*/

// Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。

/*
Go语言由来自Google公司的Robert Griesemer,Rob Pike和Ken Thompson三位大牛于2007年9月
开始设计和实现,然后于2009年的11月对外正式发布(译注:关于Go语言的创世纪过程请参考
http://talks.golang.org/2015/how-go-was-made.slide)。
*/

/*
Go语言有着和C语言类似的语法外表,和C语言一样是专业程序员的必备工具,可以用最小的
代价获得最大的战果。但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的
想法,同时避免引入过度的复杂性。Go语言中和并发编程相关的特性是全新的也是有效的,
同时对数据抽象和面向对象编程的支持也很灵活。Go语言同时还集成了自动垃圾收集技术用
于更好地管理内存。
*/

/*
Go语言尤其适合编写网络服务相关基础设施,同时也适合开发一些工具软件和系统软件。但
是Go语言确实是一个通用的编程语言,它也可以用在图形图像驱动编程、移动应用程序开发
和机器学习等诸多领域。目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者:因
为Go编写的程序通常比脚本语言运行的更快也更安全,而且很少会发生意外的类型错误。
*/

/*
Go语言还是一个开源的项目,可以免费获编译器、库、配套工具的源代码。Go语言的贡献
者来自一个活跃的全球社区。Go语言可以运行在类UNIX系统——	比如Linux、FreeBSD、
OpenBSD、Mac OSX——和Plan9系统和Microsoft Windows操作系统之上。	Go语言
编写的程序无需修改就可以运行在上面这些环境。
*/

/*
Go语言有时候被描述为“C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表
达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想,还有C语言一直所
看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。
但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus	Wirth
所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块
接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明
的语法,还有Oberon语言的面向对象特性所提供的方法的声明语法等。
Go语言的另一支祖先,带来了Go语言区别其他语言的重要特性,灵感来自于贝尔实验室的
Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程(
communicating sequential rocesses,缩写为CSP。在CSP中,程序是一组中间没有
共享状态的平行运行的处理过程,它们之间使用管道进行通信和控制同步。不过Tony Hoare
的CSP只是一个用于描述并发性基本概念的描述语言,并不是一个可以编写可执行程序的通
用编程语言。
接下来,Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引
入CSP特性的编程语言叫Squeak(老鼠间交流的语言),是一个提供鼠标和键盘事件处理的
编程语言,它的管道是静态创建的。然后是改进版的Newsqueak语言,提供了类似C语言语
句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式
语言,它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建
的,属于第一类值,可以保存到变量中。
在Plan9操作系统中,这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将
Newsqueak语言改造为系统编程语言,但是因为缺少垃圾回收机制而导致并发编程很痛苦。
(译注:在Aelf之后还有一个叫Limbo的编程语言,Go语言从其中借鉴了很多特性。	具体请
参考Pike的讲稿:http://talks.golang.org/2012/concurrency.slide#9	)
Go语言的其他的一些特性零散地来自于其他一些编程语言;比如iota语法是从APL语言借鉴,
词法作用域与嵌套函数来自于Scheme语言(和其他很多语言)。当然,我们也可以从Go中
发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能,这可能
会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。
*/
