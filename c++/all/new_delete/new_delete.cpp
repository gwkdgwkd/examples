#include <iostream>

// 创建：
// 1.在栈上创建出来的对象都有一个名字，使用指针指向它不是必须的；
// 2.通过new创建出来的对象就不一样了，它在堆上分配内存，没有名字，
//   只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，
//   否则以后再也无法找到这个对象了，更没有办法使用它。
//   也就是说，使用new在堆上创建出来的对象是匿名的，没法直接使用，
//   必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。

// 管理：
// 1.栈内存是程序自动管理的，不能使用delete删除在栈上创建的对象；
// 2.堆内存由程序员管理，对象使用完毕后可以通过delete删除。

// 和malloc()一样，new也是在堆区分配内存，必须手动释放，
// 否则只能等到程序运行结束由操作系统回收。
// 为了避免内存泄露，通常new和delete、new[]和delete[]操作符应该成对出现，
// 并且不要和C语言中malloc()、free()一起混用。
// 在C++中，建议使用new和delete来管理内存，它们可以使用C++的一些新特性，
// 最明显的是可以自动调用构造函数和析构函数。

void func1() {
  // 在C语言中，动态分配内存用malloc()函数，释放内存用free()函数，
  // 在C++中，这两个函数仍然可以使用：
  int *p = (int *)malloc(sizeof(int) * 10);
  free(p);
}

void func2() {
  // C++新增了两个关键字：new用来动态分配内存，delete用来释放内存。
  // new操作符会根据后面的数据类型来推断所需空间的大小：
  int *p = new int;
  delete p;
}

void func3() {
  // 分配一组连续的数据，可以使用new[]：
  int *p3 = new int[10];
  // 用new[]分配的内存需要用delete[]释放，它们是一一对应的：
  delete[] p3;
}

int main() {
  func1();
  func2();
  func3();

  return 0;
}