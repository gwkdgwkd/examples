#include <iostream>

// 认识template元编程

// Template metaprogramming（TMP,模板元编程）：
// 是编写template-based C++程序并执行于编译期的过程。
// 所谓的TMP是以C++写成、执行于C++编译器内的程序，一旦TMP程序结束执行，
// 其输出，也就是从template具现出来的若干C++源码，便会一如往常地被编译。

// TMP有两个优点：
// 1.它让某些事情更容易，如果没有它，那些事情将是困难的，甚至不可能的；
// 2.由于TMP执行于C++编译期，因此可将工作从运行期转移到编译期，
//   这导致的一个结果是，某些错误原本通常在运行期才能检测到，现在编译期就能找出来。
//   另一个结果是，使用TMP的C++程序可能在每一方面都个更高效：
//   较小的可执行文件、较短的运行期、较少的内存需求。
//   将工作从运行期转移至编译器的另一个结果是，编译远长于不使用TMP的对应版本。

// traits解法就是TMP，traits引发编译期发生于类型身上的if...else计算。

// TMP已被证明是个图灵完全机器，意思是它的威力大到足以计算任何事物。
// 使用TMP可以声明变量/执行循环/编写及调用函数等，但与正常的C++看起来很不同。
// TMP并没有真正的循环构件，所以循环效果通过递归完成。
// TMP主要是个函数式语言，而递归对于这类语言无法分割。
// TMP的递归不太一样，因为TMP循环并不涉及递归函数调用，而是涉及递归模板具现化。
template <unsigned n>
struct Factorial {
  enum { value = n * Factorial<n - 1>::value };
};
template <>
struct Factorial<0> {
  enum { value = 1 };
};

// 领悟TMP之所以值得学习，可以达成的目标，比如：
// 1.确保度量单位正确；
// 2.优化矩阵运算；
// 3.可以生成客户定制的设计模式实现品。

// TMP是一个在相对短时间之前才意外发现的语言，其编程方式还多少需要依赖经验。
// 尽管如此，将工作从运行期移往编译期所带来的效率改善还是令人深刻的。
// 而TMP对难以或甚至不可能运行期实现出来的行为的表现能力也很吸引人。
// TMP或许永远不会成为主流，但对一些人特别是库开发人员，几乎确定会成为他们的主要粮食。

// 请记住：
// 1.TMP可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率；
// 2.TMP可被用来生成基于政策选择组合的客户定制代码，
//   也可以用来避免生成对某些特殊类型并不适合的代码。

int main() {
  std::cout << Factorial<5>::value << std::endl;   // 120
  std::cout << Factorial<10>::value << std::endl;  // 3628800

  return 0;
}