#include <iostream>

using namespace std;

// 牢记80－20准则（80－20 rule）

// 如果想写出一个高效的C++程序，你必须首先能写出一个高效的算法。
// 太多的开发人员都忽视了这个简单的道理。
// 是的，循环能够被手工展开，移位操作（shift operation）能够替换乘法，
// 但是如果你所使用的高层算法其内在效率很低，这些微调就不会有任何作用。

// 80－20准则说的是:
// 1.大约20％的代码使用了80％的程序资源；
// 2.大约20%的代码耗用了大约80％的运行时间；
// 3.大约20％的代码使用了80％的内存；
// 4.大约20％的代码执行80％的磁盘访问；
// 4.80％的维护投入于大约20％的代码上；
// 通过无数台机器、操作系统和应用程序上的实验这条准则已经被再三地验证过。
// 80－20准则不只是一条好记的惯用语，它更是一条有关系统性能的指导方针，
// 它有着广泛的适用性和坚实的实验基础。

// 最困难的一般是找到系统瓶颈。
// 基本上有两个不同的方法用来寻找：大多数人用的方法和正确的方法。
// 大多数人寻找瓶颈的方法就是猜。
// 通过经验、直觉、算命纸牌、显灵板、传闻或者其它更荒唐的东西，
// 一个又一个程序员一本正经地宣称程序的性能问题已被找到，
// 因为网络的延迟，不正确的内存分配，
// 编译器没有进行足够的优化或者一些笨蛋主管拒绝在关键的循环里使用汇编语句。
// 这些评估总是以一种带有嘲笑的盛气凌人的架式发布出来，
// 通常这些嘲笑者和他们的预言都是错误的。
// 大多数程序员在他们程序性能特征上的直觉都是错误的，
// 因为程序性能特征往往不能靠直觉来确定。
// 结果为提高程序各部分的效率而倾注了大量的精力，
// 但是对程序的整体行为没有显著的影响。
// 例如在程序里使用能够最小化计算量的奇特算法和数据结构，
// 但是如果程序的性能限制主要在I/O上（I/O-bound）那么就丝毫起不到作用。
// 采用I/O性能强劲的程序库代替编译器本身附加的程序库，
// 如果程序的性能瓶颈主要在CPU上（CPU-bound），这种方法也不会起什么作用。

// 正确的方法是用profiler程序识别出令人讨厌的程序的20％部分。
// profiler告诉你每条语句执行了多少次或各函数被调用了多少次，
// 这是一个作用有限的工具。
// 从提高性能的观点来看，你不用关心一条语句或一个函数被调用了多少次。
// 毕竟很少遇到用户或程序库的调用者抱怨执行了太多的语句或调用了太多的函数。
// 如果软件足够快，没有人关心有多少语句被执行，
// 如果程序运行过慢，不会有人关心语句有多么的少。
// 不过，知道语句执行或函数调用的频繁程度，有时能帮助你洞察软件内部的行为。
// 例如如果你建立了100个某种类型的对象，
// 会发现你调用该类的构造函数有上千次，这个信息无疑是有价值的。
// 而且语句和函数的调用次数能间接地帮助你理解不能直接测量的软件行为。
// 例如，如果你不能直接测量动态内存的使用，
// 那么知道内存分配函数和内存释函数的调用频率也是有帮助的。
// 记住profiler仅能够告诉你在某一次运行（或某几次运行）时一个程序运行情况，
// 所以如果你用不具有代表性的输入数据profile一个程序，
// 那你所进行的profile也没有代表型。
// 必须确保每组数据在客户（或至少是最重要的客户）如何使用软件的方面能有代表性。
// 通常获取有代表性的数据是很容易的，
// 因为许多客户都愿意让你用他们的数据进行profile。
// 毕竟你是为了他们需求而优化软件。

int main() { return 0; }