#include <stdio.h>

// 整数是编程中常用的一种数据，C语言通常使用int来定义整数。
// 在现代操作系统中，int一般占用4个字节的内存，共计32位。
// 如果不考虑正负数，当所有的位都为1时它的值最大，
// 为2^32-1=4,294,967,295 ≈ 43亿，
// 这是一个很大的数，实际开发中很少用到，
// 而诸如1、99、12098等较小的数使用频率反而较高。
// 让整数占用更少的内存可以在int前边加short，
// 让整数占用更多的内存可以在int前边加long。
// short、int、long是C语言中常见的整数类型，
// 其中int称为整型，short称为短整型，long称为长整型。
// C语言并没有严格规定short、int、long的长度，只做了宽泛的限制：
// 1.short至少占用2个字节。
// 2.int建议为一个机器字长。
//   32位环境下机器字长为4字节，64位环境下机器字长为8字节。
// 3.short的长度不能大于int，long的长度不能小于int。
// 总结起来，它们的长度（所占字节数）关系为：2 ≤ short ≤ int ≤ long
// 这就意味着，short并不一定真的短，long也并不一定真的长，
// 它们有可能和int占用相同的字节数。
// 在16位环境下，short的长度为2个字节，int也为2个字节，long为4个字节。
// 16位环境多用于单片机和低级嵌入式系统，在PC和服务器上已经见不到了。
// 对于32位的Windows、Linux和Mac OS，
// short的长度为2个字节，int为4个字节，long也为4个字节。
// PC和服务器上的32位系统占有率也在慢慢下降，嵌入式系统使用32位越来越多。
// 在64位环境下，不同的操作系统会有不同的结果，如下所示：
// 操作系统 	  short int long
// Win64	       2  	4   4
// 类Unix系统	    2    4 	 8
// 包括Unix、Linux、Mac OS、BSD、Solaris等。
// 目前使用较多的PC系统为Win XP、Win 7、Win 8、Win 10、Mac OS、Linux，
// 在这些系统中，short和int的长度都是固定的，分别为2和4，大家可以放心使用，
// 只有long的长度在Win64和类Unix系统下会有所不同，使用时要注意移植性。

// 一个数字默认就是十进制的，表示一个十进制数字不需要任何特殊的格式。
// 八进制由0~7八个数字组成，使用时必须以0开头（注意是数字0，不是字母o）
// 十六进制由数字0~9、字母A~F或a~f（不区分大小写）组成，
// 使用时必须以0x或0X（不区分大小写）开头。
// 标准的C语言并不支持上面的二进制写法，
// 只是有些编译器自己进行了扩展，才支持二进制数字。

// 在C语言中也是一样，short、int、long都可以带上正负号。
// 如果不带正负号，默认就是正数。
// C语言规定，把内存的最高位作为符号位。
// 在符号位中，用0表示正数，用1表示负数。
// short、int和long默认都是带符号位的，符号位以外的内存才是数值位。
// 如果只考虑正数，那么各种类型能表示的数值范围就比原来小了一半。
// 如果不希望设置符号位，可以在数据类型前面加上unsigned关键字。
// 不能再表示负数了，但正数的取值范围更大了。

// 整数在内存中是如何存储的，为什么它堪称天才般的设计：
// 1.原码，通俗的理解，原码就是一个整数本来的二进制形式。
//   将一个整数转换成二进制形式，就是其原码。
//   6   : 0000 0000 0000 0110
//   -18 : 1000 0000 0001 0010
// 2.反码，谈到反码，正数和负数要区别对待，因为它们的反码不一样。
//   对于正数，它的反码就是其原码（原码和反码相同）；
//   负数的反码是将原码中除符号位以外的所有位（数值位）取反，
//   也就是0变成1，1变成0。
//   6   : 0000 0000 0000 0110
//   -18 : 1111 1111 1110 1101
// 3.补码，正数和负数的补码也不一样，也要区别对待。
//   对于正数，它的补码就是其原码（原码、反码、补码都相同）；
//   负数的补码是其反码加1。
//   补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫补码。
//   6   : 0000 0000 0000 0110
//   -18 : 1111 1111 1110 1110
// 原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。
// 在内存中，整数一律采用补码的形式来存储。
// 这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。
// 将补码转换为原码也很简单：先减去1，再将数值位取反即可。

// 补码到底是如何简化硬件电路的？
// 加法和减法是计算机中最基本的运算，
// 计算机时时刻刻都离不开它们，所以它们由硬件直接支持。
// 为了提高加减法的运算效率，硬件电路要设计得尽量简单。
// 对于有符号数，内存要区分符号位和数值位，对于人脑来说，
// 很容易辨别，但是对于计算机来说，就要设计专门的电路，
// 这无疑增加了硬件的复杂性，增加了计算的时间。
// 要是能把符号位和数值位等同起来，让它们一起参与运算，
// 不再加以区分，这样硬件电路就变得简单了。
// 如果能够实现上面的两个目标，那么只要设计一种简单的、
// 不用区分符号位和数值位的加法电路，
// 就能同时实现加法和减法运算，并且非常高效。
// 假设6和18都是short类型的，现在我们要计算6-18的结果，
// 根据运算规则，它等价于6+(-18)。
// 1.如果采用原码计算，那么运算过程为：
//   6 - 18 = 6 + (-18)
//   = [0000 0000 0000 0110]原 + [1000 0000 0001 0010]原
//   = [1000 0000 0001 1000]原
//   = -24
//   直接用原码表示整数，让符号位也参与运算，
//   对于类似上面的减法来说，结果显然是不正确的。
// 2.于是人们开始继续探索，不断试错，后来设计出了反码。
//   下面就演示了反码运算的过程：
//   6 - 18 = 6 + (-18)
//   = [0000 0000 0000 0110]反 + [1111 1111 1110 1101]反
//   = [1111 1111 1111 0011]反
//   = [1000 0000 0000 1100]原
//   = -12
//   这样一来，计算结果就正确了。
//   然而，这样还不算万事大吉，不妨将减数和被减数交换一下位置，
//   也就是计算18-6的结果：
//   18 - 6 = 18 + (-6)
//   = [0000 0000 0001 0010]反 + [1111 1111 1111 1001]反
//   = [1 0000 0000 0000 1011]反
//   = [0000 0000 0000 1011]反
//   = [0000 0000 0000 1011]原
//   = 11
//   按照反码计算的结果是11，而真实的结果应该是12才对，它们相差了1。
//   按照反码来计算，是不是小数减去大数正确，
//   大数减去小数就不对了，始终相差1呢？
//   5 - 13的运算过程为：
//   5 - 13 = 5 + (-13)
//   = [0000 0000 0000 0101]原 + [1000 0000 0000 1101]原
//   =  [0000 0000 0000 0101]反 + [1111 1111 1111 0010]反
//   = [1111 1111 1111 0111]反
//   = [1000 0000 0000 1000]原
//   = -8
//   13 - 5的运算过程为：
//   13 - 5 = 13 + (-5)
//   = [0000 0000 0000 1101]原 + [1000 0000 0000 0101]原
//   = [0000 0000 0000 1101]反 + [1111 1111 1111 1010]反
//   = [1 0000 0000 0000 0111]反
//   = [0000 0000 0000 0111]反
//   = [0000 0000 0000 0111]原
//   = 7
//   证明了小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差1。
// 3.相差的这个1要进行纠正，但是又不能影响小数减去大数，怎么办呢？
//   于是人们又设计出了补码，给反码打了一个补丁，终于把相差的1给纠正过来了。
//   6 - 18 = 6 + (-18)
//   = [0000 0000 0000 0110]补 + [1111 1111 1110 1110]补
//   = [1111 1111 1111 0100]补
//   = [1111 1111 1111 0011]反
//   = [1000 0000 0000 1100]原
//   = -12
//   18 - 6 = 18 + (-6)
//   = [0000 0000 0001 0010]补 + [1111 1111 1111 1010]补
//   = [1 0000 0000 0000 1100]补
//   = [0000 0000 0000 1100]补
//   = [0000 0000 0000 1100]反
//   = [0000 0000 0000 1100]原
//   = 12
//   5 - 13 = 5 + (-13)
//   = [0000 0000 0000 0101]补 + [1111 1111 1111 0011]补
//   = [1111 1111 1111 1000]补
//   = [1111 1111 1111 0111]反
//   = [1000 0000 0000 1000]原
//   = -8
//   13 - 5 = 13 + (-5)
//   = [0000 0000 0000 1101]补 + [1111 1111 1111 1011]补
//   = [1 0000 0000 0000 1000]补
//   = [0000 0000 0000 1000]补
//   = [0000 0000 0000 1000]反
//   = [0000 0000 0000 1000]原
//   = 8
// 小数减去大数，结果为负数，之前（负数从反码转换为补码要加1）加上的1，
// 后来（负数从补码转换为反码要减1）还要减去，正好抵消掉，所以不会受影响。
// 而大数减去小数，结果为正数，之前（负数从反码转换为补码要加1）加上的1，
// 后来（正数的补码和反码相同，从补码转换为反码不用减1）就没有再减去，
// 不能抵消掉，这就相当于给计算结果多加了一个1。
// 补码这种天才般的设计，一举达成了前面的两个目标，简化了硬件电路。

// short、int、long的长度分别是2、4、4或者8，只能存储有限的数值，
// 当数值过大或者过小时，超出的部分会被直接截掉，
// 数值就不能正确存储了，将这种现象称为溢出（Overflow）。
// 计算无符号数（unsigned）的取值范围（或者说最大值和最小值）很容易，
// 将内存中的所有位（Bit）都置为1就是最大值，都置为0就是最小值。
// 有符号数以补码的形式存储，计算取值范围也要从补码入手。
// 以char类型为例：
// 按照传统的由补码计算原码的方法，那么10000000是无法计算的，
// 因为计算反码时要减去1，10000000需要向高位借位，
// 而高位是符号位，不能借出去，所以这就很矛盾。
// 是不是该把10000000作为无效的补码直接丢弃呢？
// 然而，作为无效值就不如作为特殊值，这样还能多存储一个数字。
// 计算机规定，10000000这个特殊的补码就表示-128。
// 为什么偏偏是-128而不是其它的数字呢？
// 1.首先，-128使得char类型的取值范围保持连贯，中间没有空隙。
// 2.其次，再按照传统的方法计算一下-128的补码：
//   -128的数值位的原码是10000000共八位，而char的数值位只有七位，
//   所以最高位的1会覆盖符号位，数值位剩下0000000。
//   最终，-128的原码为10000000。
//   接着很容易计算出反码，为11111111。
//   反码转换为补码时，数值位要加上1，
//   变为10000000，而char的数值位只有七位，
//   所以最高位的1会再次覆盖符号位，数值位剩下0000000。
//   最终求得的-128的补码是10000000。
//   -128从原码转换到补码的过程中，符号位被1覆盖了两次，
//   而负数的符号位本来就是1，被1覆盖多少次也不会影响到数字的符号。
//   虽然从10000000这个补码推算不出-128，
//   但是从-128却能推算出10000000这个补码，
//   这多么的奇妙，-128这个特殊值选得恰到好处。
//   负数在存储之前要先转换为补码，从-128推算出补码10000000这一点非常重要，
//   这意味着-128能够正确地转换为补码，或者说能够正确的存储。
// 在char的取值范围内只有一个零值，没有+0和-0的区别，
// 并且多存储了一个特殊值，就是-128，这也是采用补码的另外两个小小的优势。
// 如果直接采用原码存储，那么00000000和10000000将分别表示+0和-0，
// 这样在取值范围内就存在两个相同的值，多此一举。
// 另外，虽然最大值没有变，仍然是127，但是最小值却变了，只能存储到-127，
// 不能存储-128了，因为-128的原码为10000000，这个位置已经被-0占用了。

int main() {
  // sizeof用来获取某个数据类型或变量所占用的字节数，
  // 如果后面跟的是变量名称，那么可以省略()，
  // 如果跟的是数据类型，就必须带上()：
  int a = 5;
  printf("size of a : %d\n", sizeof a);       // 4
  printf("size of int : %d\n", sizeof(int));  // 4

  short a1 = 0100;
  int b = -0x1;
  long c = 720;
  unsigned short m = 0xffff;
  unsigned int n = 0x80000000;
  unsigned long p = 100;
  printf("a=%#ho, b=%#x, c=%lu\n", a1, b, c);
  printf("m=%hd, n=%d, p=%ld\n", m, n, p);
  // a=0100, b=0xffffffff, c=720
  // m=-1, n=-2147483648, p=100

  unsigned int a2 = 0x100000000;
  int b2 = 0xffffffff;
  printf("a=%u, b=%d\n", a2, b2);
  // a=0, b=-1

  // 变量a2为unsigned int类型，长度为4个字节，
  // 能表示的最大值为0xFFFFFFFF，而0x100000000=0xFFFFFFFF+1，
  // 占用33位，已超出a所能表示的最大值，
  // 所以发生了溢出，导致最高位的1被截去，剩下的32位都是0。
  // a被存储到内存后就变成了0，printf从内存中读取到的也是0。
  // 变量b2是int类型的有符号数，在内存中以补码的形式存储。
  // 0xffffffff的数值位的原码为1111 1111 …… 1111 1111，
  // 共32位，而int类型的数值位只有31位，
  // 所以最高位的1会覆盖符号位，数值位只留下31个1。
  // 当printf读取到b时，由于最高位是1，
  // 所以会被判定为负数，要从补码转换为原码：
  // [1111 1111 …… 1111 1111]补
  // = [1111 1111 …… 1111 1110]反
  // = [1000 0000 …… 0000 0001]原
  // = -1

  return 0;
}