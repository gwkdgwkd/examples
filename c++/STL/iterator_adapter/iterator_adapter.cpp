#include <iostream>
#include <list>

// 可以将迭代器适配器视为普通迭代器，之所以称为迭代器适配器，
// 是因为这些迭代器是在输入迭代器、输出迭代器、正向迭代器、双向迭代器或者随机访问迭代器这些基础迭代器的基础上实现的。
// 也就是说，使用迭代器适配器的过程中，其本质就是在操作某种基础迭代器。
// 无论是序列式容器还是关联式容器（包括哈希容器），要想遍历容器中存储的数据，就只能用使用该容器模板类中提供的迭代器。
// C++ STL标准库中迭代器大致分为5种类型，分别是输入迭代器、输出迭代器、前向迭代器、双向迭代器以及随机访问迭代器。
// 这5种迭代器是STL标准库提供的最基础的迭代器，很多场景中遍历容器的需求，它们并不适合。
// 所谓迭代器适配器，其本质也是一个模板类，比较特殊的是，该模板类是借助以上5种基础迭代器实现的。
// 换句话说，迭代器适配器模板类的内部实现，是通过对以上5种基础迭代器拥有的成员方法进行整合、修改，
// 甚至为了实现某些功能还会添加一些新的成员方法。
// 由此，将基础迭代器“改头换面”，就变成了迭代器适配器。
// 本质上讲，迭代器适配器仍属于迭代器，可以理解为是基础迭代器的“翻新版”或者“升级版”。
// 同时，“xxx迭代器适配器”通常直接称为“xxx迭代器”。
// 5种迭代器适配器，分别是反向迭代器适配器、插入型迭代器适配器、流迭代器适配器、流缓冲区迭代器适配器、移动迭代器适配器。

// STL迭代器适配器种类:
// 1.反向迭代器（reverse_iterator） 又称“逆向迭代器”
//   其内部重新定义了递增运算符（++）和递减运算符（--），专门用来实现对容器的逆序遍历。
// 2.安插型迭代器（inserter或者insert_iterator）
//   通常用于在容器的任何位置添加新的元素，需要注意的是，此类迭代器不能被运用到元素个数固定的容器（比如array）上。
// 3.流迭代器（istream_iterator/ostream_iterator）
//   输入流迭代器用于从文件或者键盘读取数据；
//   相反，输出流迭代器用于将数据输出到文件或者屏幕上。
// 4.流缓冲区迭代器（istreambuf_iterator/ostreambuf_iterator）
//   输入流缓冲区迭代器用于从输入缓冲区中逐个读取数据；
//   输出流缓冲区迭代器用于将数据逐个写入输出流缓冲区。
// 5.移动迭代器（move_iterator）
//   此类型迭代器是C++11标准中新添加的，可以将某个范围的类对象移动到目标范围，而不需要通过拷贝去移动。

std::list<int> l{1, 2, 3, 4, 5};  // 需要逆序输出该容器中存储的所有元素
void func1() {
  // list容器模板类提供的是双向迭代器，如果使用该类型迭代器实现逆序操作:
  std::list<int>::iterator begin = --l.end();
  std::list<int>::iterator end = --l.begin();
  while (begin != end) {
    std::cout << *begin << " ";
    --begin;
  }
  std::cout << std::endl;  // 5 4 3 2 1
}
void func2() {
  // 用反向迭代器适配器遍历list容器的实现过程：
  std::reverse_iterator<std::list<int>::iterator> begin = l.rbegin();
  std::reverse_iterator<std::list<int>::iterator> end = l.rend();
  while (begin != end) {
    std::cout << *begin << " ";
    ++begin;
  }
  std::cout << std::endl;  // 5 4 3 2 1

  // 程序中通过调用list容器模板类提供的rbegin()和rend()，
  // 就可以获得逆序遍历容器所需要的反向迭代器，从而轻松实现逆序输出容器中存储的所有数据。
}

int main() {
  func1();
  func2();
  return 0;
}