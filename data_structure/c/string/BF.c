#include <stdio.h>
#include <string.h>

// 串的模式匹配算法，通俗地理解，是一种用来判断两个串之间是否具有主串与子串关系的算法。

// 实现串的模式匹配的算法主要有以下两种：
// 1.普通的模式匹配算法；
// 2.快速模式匹配算法；

// BF算法原理
// 普通模式匹配算法，其实现过程没有任何技巧，
// 就是简单粗暴地拿一个串同另一个串中的字符一一比对，得到最终结果。

// BF算法时间复杂度
// 该算法最理想的时间复杂度O(n)，n表示串A的长度，即第一次匹配就成功。
// BF算法最坏情况的时间复杂度为O(n*m)，n为串A的长度，m为串B的长度。
// 例如，串B为0000000001，而串A为01，这种情况下，两个串每次匹配，
// 都必须匹配至串A的最末尾才能判断匹配失败，因此运行了n*m次。
// BF算法的实现过程很无脑，不包含任何技巧，在对数据量大的串进行模式匹配时，算法的效率很低。

// 串普通模式匹配算法的实现函数，其中B是伪主串，A是伪子串
int mate(char *B, char *A) {
  int i = 0, j = 0;
  while (i < strlen(B) && j < strlen(A)) {
    if (B[i] == A[j]) {
      i++;
      j++;
    } else {
      i = i - j + 1;
      j = 0;
    }
  }
  // 跳出循环有两种可能，i=strlen(B)说明已经遍历完主串，匹配失败；
  // j=strlen(A),说明子串遍历完成，在主串中成功匹配
  if (j == strlen(A)) {
    // 成功模式匹配所用的次数，也就是串A移动的总次数。
    return i - strlen(A) + 1;
  }
  // 运行到此，为i==strlen(B)的情况
  return 0;
}

int main() {
  int number = mate("ababcabcacbab", "abcac");
  printf("%d\n", number);  // 6

  return 0;
}