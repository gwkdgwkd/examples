#include "have_ring.h"

// 有环链表并不一定就是循环链表，循环链表指的是首尾相连的单链表，
// 而有环链表则指的是单链表中存在一个循环子链表。

// 判断单链表是否有环，常用的方法有如下2种：
// 1.最直接的实现思想就是：从给定链表的第一个节点开始遍历，每遍历至一个节点，
//   都将其和所有的前驱节点进行比对，如果为同一个节点，则表明当前链表中有环；
//   反之，如果遍历至链表最后一个节点，仍未找到相同的节点，则证明该链表中无环。
//   注意，如果一个单链表为有环链表，基于单链表中各节点有且仅有1个指针域的特性，
//   则势必该链表是没有尾结点的，遍历过程是无法自行结束的，需要用break手动结束遍历。
bool HaveRing(link* H) {
  link* Htemp = H;
  // 存储所遍历节点所有前驱节点的存储地址，64位环境地址占8字节，所以用long long类型
  long long addr[20] = {0};
  int length = 0, i = 0;
  // 逐个遍历链表中各个节点：
  while (Htemp) {
    // 依次将Htemp和addr数组中记录的已遍历的地址进行比对：
    for (i = 0; i < length; i++) {
      // 如果比对成功，则证明有环：
      if (Htemp == addr[i]) {
        return True;
      }
    }
    // 比对不成功，则记录Htemp节点的存储地址：
    addr[length] = Htemp;
    length++;
    Htemp = Htemp->next;
  }
  return False;

  // 当函数的返回值为True，表示该链表有环，反之若函数返回值为False，
  // 表明链表中无环，显然，此实现方案的时间复杂度为O(n^2)。
}

// 2.相比上一种实现方案，这是一种时间复杂度为O(n)的算法。
//   该算法的实现思想需要借助一个论点，即在一个链表中，如果H1和H2都从表头开始遍历链表，
//   其中H1每次移动2个节点的长度，而H2每次移动1个节点的长度，如果该链表为有环链表，
//   则H1、H2最终必定会相等，反之，如果该链表中无环，则H1、H2永远不会相遇。
//   有关在有环链表中H1和H2必定会相遇的结论，假设有环链表中的环包含n个节点，
//   则第一次遍历，H1和H2相差1个节点；
//   第二次遍历，H1和H2相差2个节点；
//   第三次遍历，H1和H2相差3个节点，最终经过多次遍历，H1和H2会相差n-1个节点，
//   此时就会在环中重合，此时H1和H2相等。
bool HaveRing(link* H) {
  link* H1 = H->next;
  link* H2 = H;
  while (H1) {
    if (H1 == H2) {
      // 链表中有环
      return True;
    } else {
      H1 = H1->next;
      if (!H1) {
        // 链表中无环
        return False;
      } else {
        H1 = H1->next;
        H2 = H2->next;
      }
    }
  }
  // 链表中无环
  return False;

  // 当函数返回False时，表明当前链表中无环，反之若返回True，
  // 则表明该链表为有环链表，和第一种算法相比，本算法的时间复杂度为O(n)。
}
