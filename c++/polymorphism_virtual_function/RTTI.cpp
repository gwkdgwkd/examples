#include <iostream>
#include <typeinfo>

using namespace std;

// 一般情况下，在编译期间就能确定一个表达式的类型，
// 但是当存在多态时，有些表达式的类型在编译期间就无法确定了，必须等到程序运行后根据实际的环境来确定。
// C++的对象内存模型主要包含了以下几个方面的内容：
// 1.如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量。
// 2.如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表。
// 3.如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表。
// 4.如果类包含了虚函数，那么该类的对象内存中还会额外增加类型信息，也即type_info对象。

// 编译器会在虚函数表vftable的开头插入一个指针，指向当前类对应的type_info对象。
// 当程序在运行阶段获取类型信息时，可以通过对象指针p找到虚函数表指针vfptr，
// 再通过vfptr找到type_info对象的指针，进而取得类型信息。
// 编译器在编译阶段无法确定p指向哪个对象，也就无法获取*p的类型信息，但是编译器可以在编译阶段做好各种准备，
// 在运行后可以借助这些准备好的数据来获取类型信息。包括：
// 1.创建type_info对象，并在vftable的开头插入一个指针，指向type_info对象。
// 2.将获取类型信息的操作转换成类似**(p->vfptr-1)这样的语句。
// 这样做虽然会占用更多的内存，效率也降低了，但这是没办法的事情，编译器实在是无能为力了。
// 这种在程序运行后确定对象的类型信息的机制称为运行时类型识别（Run-Time Type Identification，RTTI）。
// 在C++中，只有类中包含了虚函数时才会启用RTTI机制，其他所有情况都可以在编译阶段确定类型信息。
// 多态（Polymorphism）是面向对象编程的一个重要特征，它极大地增加了程序的灵活性，
// C++、C#、Java等“正统的”面向对象编程语言都支持多态。
// 但是支持多态的代价也是很大的，有些信息在编译阶段无法确定下来，必须提前做好充足的准备，
// 让程序运行后再执行一段代码获取，这会消耗更多的内存和CPU资源。
class People {
 public:
  virtual void func() {}
};
class Student : public People {};

// C/C++用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供CPU使用。
// CPU通过地址来取得内存中的代码和数据，程序在执行过程中会告知CPU要执行的代码以及要读写的数据的地址。
// CPU访问内存时需要的是地址，而不是变量名和函数名，变量名和函数名只是地址的一种助记符，
// 当源文件被编译和链接成可执行程序后，它们都会被替换成地址。
// 编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
// 变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，
// 不用直接面对二进制地址，那场景简直让人崩溃。
// 不妨将变量名和函数名统称为符号（Symbol），找到符号对应的地址的过程叫做符号绑定。
// 函数调用是执行函数体中的代码，函数体是内存中的一个代码段，函数名是该代码段的首地址，函数执行时就从这里开始。
// 简单说就是必须要知道函数的入口地址，才能成功调用函数。
// 找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。
// 一般情况下，在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，
// 程序运行后直接使用这个地址即可，这称为静态绑定（Static binding）。
// 但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定，
// 这称为动态绑定（dynamic binding）。
// C++是一门静态性的语言，会尽力在编译期间找到函数的地址，以提高程序的运行效率，
// 但是有时候实在没办法，只能等到程序运行后再执行一段代码（很少的代码）才能找到函数的地址。
// 动态绑定的本质：编译器在编译期间不能确定指针指向哪个对象，只能等到程序运行后根据具体的情况再决定。

// 在C++中，除了typeid运算符，dynamic_cast运算符和异常处理也依赖于RTTI机制，
// 并且要能够通过派生类获取基类的信息，或者说要能够判断一个类是否是另一个类的基类，
// 必须要在基类和派生类之间再增加一条绳索，把它们连接起来，形成一条通路，让程序在各个对象之间游走。
// 在面向对象的编程语言中，称此为继承链（Inheritance Chain）。
// 将基类和派生类连接起来很容易，只需要在基类对象中增加一个指向派生类对象的指针，
// 然而考虑到多继承、降低内存使用等诸多方面的因素，真正的对象内存模型很复杂，C++标准并没有对对象内存模型的细节做出规定。
// 对于有虚函数的类，内存模型中除了有虚函数表，还会额外增加好几个表，以维护当前类和基类的信息，空间上的开销不小。
// typeid(type).name() 方法返回的类名就来自“当前类的信息表”。
// typeid经过固定次数的间接转换返回type_info对象，间接次数不会随着继承层次的增加而增加，对效率的影响很小，可以放心使用。
// 而dynamic_cast运算符和异常处理不仅要经过数次间接转换，还要遍历继承链，如果继承层次较深，那么它们的性能堪忧，应当谨慎使用！
// 类型是表达式的一个属性，不同的类型支持不同的操作，类型对于编程语言来说非常重要，编译器内部有一个类型系统来维护表达式的各种信息。
// 在C/C++中，变量、函数参数、函数返回值等在定义时都必须显式地指明类型，并且一旦指明类型后就不能再更改了，
// 所以大部分表达式的类型都能够精确的推测出来，编译器在编译期间就能够搞定这些事情，这样的编程语言称为静态语言。
// 除了C/C++，典型的静态语言还有Java、C#、Haskell、Scala等。
// 静态语言在定义变量时通常需要显式地指明类型，并且在编译期间会拼尽全力来确定表达式的类型信息，
// 只有在万不得已时才让程序等到运行后动态地获取类型信息（例如多态），这样做可以提高程序运行效率，降低内存消耗。
// 与静态语言（Static Language）相对的是动态语言（Dynamic Language）。
// 动态语言在定义变量时往往不需要指明类型，并且变量的类型可以随时改变（赋给它不同类型的数据），
// 编译器在编译期间也不容易确定表达式的类型信息，只能等到程序运行后再动态地获取。
// 典型的动态语言有JavaScript、Python、PHP、Perl、Ruby等。
// 动态语言为了能够使用灵活，部署简单，往往是一边编译一边执行，模糊了传统的编译和运行的过程。
// 总起来说，静态语言由于类型的限制会降低编码的速度，但是它的执行效率高，适合开发大型的、系统级的程序；
// 动态语言则比较灵活，编码简单，部署容易，在Web开发中大显身手。

int main() {
  People *p;
  int n;

  cin >> n;
  if (n <= 100) {
    p = new People();
  } else {
    p = new Student();
  }
  if (typeid(*p) == typeid(People)) {
    cout << "I am human." << endl;
  } else {
    cout << "I am a student." << endl;
  }

  return 0;
}