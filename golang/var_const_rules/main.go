package main

import "fmt"

// var h = 5 // 可以定义全局变量
// h := 5 // 不可以，只能用在局部变量

func main() {
	// Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则:
	// 一个名字必须由字母(Unicode字母)或下划线开头，后面可以跟任意数量的字母、数字或下划线。
	// Go语言中关键字(25个)和保留字(30多个)都不能用作变量名。
	// 变量名称严格区分大小写。
	// 标识符一定要见名思意：变量名建议用名称，方法名建议用动词。
	// 变量命名一般采用驼峰式（maxAge,小;MaxAge,大)，特有名词根据是否私有全大写或小写。
	// 名字的长度没有逻辑限制，尽量使用短小的名字，局部变量尤其如此。作用域大，生命周期长，长名字才有意义。

	// 25个关键字:
	// break,default,func,interface,select,case,defer,go,map,struct,chan,else,goto,
	// package,switch,const,fallthrough,if,range,type,continue,for,import,return,var

	// 四种类型的声明语句：var(变量)、const(常量)、type(类型)和func(函数)。

	// 30多个预定义名字:
	// 这些名字并不是关键字，可以在定义中重新使用。一些场景是有意义的，但要注意避免过度而引起语义混乱。
	// 内建常量:true,false,iota,nil
	// 内建类型:int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,
	//         float32,float64,complex128,complex64,bool,byte,rune,string,error
	// 内建函数:make,len,cap,new,append,copy,close,delete,complex,real,imag,panic,recover

	// 如果一个名字在函数内部定义，那么就只在函数内部有效。
	// 如果在函数外部定义，那么将在当前包的所有文件中都可以访问。
	// 名字的开头字母的大小写决定了名字在包外的可见性。大写，是导出的，可以被外部的包访问。

	// 变量声明的一般语法如下:
	// var 变量名字 类型 = 表达式
	// 其中“类型”或“= 表达式”两个部分可以省略其中的一个。
	var x = 5                    // 如果省略的是类型信息,那么将根据初始化表达式来推导变量的类型信息。
	fmt.Printf("%v(%T)\n", x, x) // 5(int)
	var y int                    // 如果初始化表达式被省略,那么将用零值初始化该变量。
	fmt.Printf("%v(%T)\n", y, y) // 0(int)
	// 数值类型变量对应的零值是0,布尔类型变量对应的零值是false,字符串类型对应的零
	// 值是空字符串,接口或引用类型(包括slice、指针、map、chan和函数)变量对应的零值是
	// nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
	// 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值,因此在Go语言中不存在
	// 未初始化的变量。

	var z1, z2, z3 int // 在一个声明语句中同时声明一组变量
	fmt.Println(z1, z2, z3)
	var p1, p2, p3 int = 1, 2, 3 // 用一组初始化表达式声明并初始化一组变量
	fmt.Println(p1, p2, p3)
	var q1, q2, q3 = true, 2.3, "four" // 如果省略每个变量的类型,将可以声明多个类型不同的变量
	fmt.Println(q1, q2, q3)
	// 初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前
	// 完成初始化,局部变量将在声明语句被执行到的时候完成初始化。

	// var f, err = os.Open(name) // 一组变量也可以通过调用一个函数,由函数返回的多个返回值初始化

	// xx := 55 // 在函数内部,有一种称为简短变量声明语句的形式可用于声明和初始化局部变量
	// 因为简洁和灵活的特点,简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形
	// 式的声明语句往往是用于需要显式指定变量类型地方,或者因为变量稍后会被重新赋值而初
	// 始值无关紧要的地方。
	// i, j := 0, 1 // 和var形式声明语句一样,简短变量声明语句也可以用来声明和初始化一组变量
	// f, err := os.Open(name) // 和var变量声明一样,简短变量声明也可以用函数返回值来声明和初始化变量
	// ":="是一个变量声明语句,而"="是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值，
	// 后者是将右边各个的表达式值赋值给左边对应位置的各个变量。
	// i, j = j, i // 交换i和j的值

	// 简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了,
	// 那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
	// 简短变量声明语句中必须至少要声明一个新的变量。
	// in, err := os.Open(infile)
	// out,	err	:= cos.Create(outfile) // err已经声明过，只赋值
	// out,	err	:= cos.Create(outfile) // 不能编译通过
	// 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价,如果变量是在外部词法域声明的,
	// 那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

	// 赋值，使用赋值语句可以更新一个变量的值,最简单的赋值语句是将要被赋值的变量放在=的左边,
	// 新值的表达式放在=的右边。

	// 元组赋值是另一种形式的赋值语句,它允许同时更新多个变量的值。在赋值之前,赋值语句
	// 右边的所有表达式将会先进行求值,然后再统一更新左边对应变量的值。这对于处理有些同
	// 时出现在元组赋值语句左右两边的变量很有帮助,例如我们可以这样交换两个变量的值:x,y = y,x

	// 赋值语句是显式的赋值形式,但是程序中还有很多地方会发生隐式的赋值行为:函数调用会
	// 隐式地将调用参数的值赋值给函数的参数变量,一个返回语句会隐式地将返回操作的值赋值
	// 给结果变量,一个复合类型的字面量也会产生赋值行为。
	// medals := []string{"gold","silver","bronze"} // 隐式地对slice的每个元素进行赋值操作
	// map和chan的元素,虽然不是普通的变量,但是也有类似的隐式赋值行为

	// 可赋值性规则是简单的:类型必须完全匹配,nil可以赋值给任何指针或引用类型的变量。
	// 常量则有更灵活的赋值规则,因为这样可以避免不必要的显式的类型转换。

	// 变量或表达式的类型定义了对应存储值的属性特征,例如数值在内存的存储大小(或者是元
	// 素的bit个数),它们在内部是如何表达的,是否支持一些操作符,以及它们自己关联的方法
	// 集等。
	// type 类型名字 底层类型 // 一个类型声明语句创建了一个新的类型名称,和现有类型具有相同的底层结构。
	// 类型声明语句一般出现在包一级,因此如果新创建的类型名字的首字符大写,则在外部包也可以使用。

	// 对于每一个类型T,都有一个对应的类型转换操作T(x),用于将x转为T类型(如果T是指针类型,可能会需要用小括弧包装T,
	// 比如 (*int)(0))。只有当两个类型的底层基础类型相同时,才允许这种转型操作,或者是两者都是指向相同底层结构的
	// 指针类型,这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值,那么x必然也可以被转为T类型,但是一
	// 般没有这个必要。类型转换不会改变值本身,但是会使它们的语义发生变化。

	// 数值类型之间的转型也是允许的,并且在字符串和一些特定类型的slice之间也是可以转换
	// 的,这类转换可能改变值的表现。

	// 一个命名的类型可以提供书写方便,特别是可以避免一遍又一遍地书写复杂类型。
	// 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合,我们称为类型的方法集。

	// 1.var声明变量:
	// var 变量名称 类型
	var username string            // 没有初始化，值为空
	var i int                      // 没有初始化，值为0
	var f float64                  // 没有初始化，值为0
	var b bool                     // 没有初始化，值位false
	fmt.Println(username, i, f, b) //  0 0 false

	// var 1a string // 错误
	// var if = "李四" // 错误
	// var m_a = "李四" // 正确，但不推荐

	// 2.变量的定义以及初始化
	// var a1 string
	// a1 = "张三" // 第一种方式
	// var a2 string = "张三" // 第二种方式
	// var a3 = "张三" // 第三种方式，类型推导

	// 3.一次定义多个变量
	// 第一种方式：var 变量名称，变量名称 类型
	// var b1, b2 string // 同一种类型
	/*
			第二种方式：类型可以不同
		    var （
				变量名称 类型
			    变量名称 类型
			）
			var (
				c1 int
				c2 float64
			)
			var (
				c1 int = 5
				c2 float64 = 12.34
			)
			var (
				c1 = 5
				c2 = 12.34
			)
	*/

	// 4.短变量声明法，只能用于声明局部变量，不能用于全局变量的声明
	d := 5
	fmt.Printf("%v,类型%T\n", d, d) // 5,类型int
	e, f, g := 5, 15.66, "nihao"
	fmt.Printf("%v(%T), %v(%T), %v(%T)\n", e, e, f, f, g, g) // 5(int), 15.66(float64), nihao(string)

	// 5.匿名变量，使用一个下划线_表示。使用多重赋值时，如果想忽略某个值，可以使用匿名变量。

	// 6.常量，定义常量时必须赋值;定义完后也不能改变其值。
	// const pi = 3.14159 // 定义时必须初始化
	// pi = 6.5 // 不能改变
	const ( // 多个常量也可以一起声明
		// D // 第一个必须初始化
		A = "A"
		B = "B"
		C // 如果忽略力值表示和上面一行的值相同
		E
	)
	fmt.Println(A, B, C, E) // A B B

	// 7.iota
	const a = iota // iota是0
	fmt.Println(a) // 0
	const (
		n1 = iota
		n2 // 第一个值是iota，后面的值如果不赋值，那么累加
		n3
		_ // 跳过一个值
		n4
		n5 = 100 // 声明中间插队
		n6 = iota
		n7
	)
	fmt.Println(n1, n2, n3, n4, n5, n6, n7) // 0 1 2 4 100 6 7

	// 8.多个iota定义在一行
	const (
		m1, m2 = iota + 1, iota + 2
		m3, m4
		m5, m6
	)
	fmt.Println(m1, m2, m3, m4, m5, m6) // 1 2 2 3 3 4

	// 9.包一级的各种类型的声明语句的顺序无关紧要
	fmt.Println(o) // 先声明后使用
}

var o = 15
