#include <stdio.h>
#include <cstdio>
#include <iostream>

// 一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突。
// 当所有人的代码都测试通过，没有问题时，将它们结合到一起就有可能会出现命名冲突。
// 为了解决合作开发时的命名冲突问题，C++引入了命名空间（Namespace）的概念，
// 命名空间有时也被称为名字空间、名称空间。
// namespace是C++中的关键字，用来定义一个命名空间，语法格式为：
// namespace name{
//     // variables, functions, classes
// }
// name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define等，最后由{}包围。
// 在using声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间中的变量。
// 命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，
// 同样也都能在命名空间内部进行声明或定义，例如类、函数、typedef、#define等都可以出现在命名空间中。
// 站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。
// 有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如typedef定义的类型别名。

// C++是在C语言的基础上开发的，早期的C++还不完善，不支持命名空间，没有自己的编译器，
// 而是将C++代码翻译成C代码，再通过C编译器完成编译。
// 这个时候的C++仍然在使用C语言的库，stdio.h、stdlib.h、string.h等头文件依然有效；
// 此外C++也开发了一些新的库，增加了自己的头文件，例如：
//  iostream.h：用于控制台输入输出头文件。
//  fstream.h：用于文件操作的头文件。
//  complex.h：用于复数计算的头文件。
// 和C语言一样，C++头文件仍然以.h为后缀，它们所包含的类、函数、宏等都是全局范围的。
// 后来C++引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是std。
// std是standard的缩写，意思是“标准命名空间”。
// 但是这时已经有很多用老式C++开发的程序了，它们的代码中并没有使用命名空间，直接修改原来的库会带来一个很严重的后果：
// 程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的C++代码。
// C++开发人员想了一个好办法，保留原来的库和头文件，它们在C++中可以继续使用，然后再把原来的库复制一份，
// 在此基础上稍加修改，把类、函数、宏等纳入命名空间std下，就成了新版C++标准库。
// 这样共存在了两份功能相似的库，使用了老式C++的程序可以继续使用原来的库，新开发的程序可以使用新版的C++库。
// 为了避免头文件重名，新版C++库也对头文件的命名做了调整，去掉了后缀.h，
// 所以老式C++的iostream.h变成了iostream，fstream.h变成了fstream。
// 而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字母，
// 所以C语言的stdio.h变成了cstdio，stdlib.h变成了cstdlib。
// 需要注意的是，旧的C++头文件是官方所反对使用的，已明确提出不再支持，但旧的C头文件仍然可以使用，以保持对C的兼容性。
// 实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的C++头文件在未来数年内还是会被支持。
// C++ 头文件的现状：
// 1.旧的C++头文件，如iostream.h、fstream.h等将会继续被支持，尽管它们不在官方标准中，不在命名空间std中。
// 2.新的C++头文件，如iostream、fstream等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间std中。
//   注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。
// 3.标准C头文件如stdio.h、stdlib.h等继续被支持，头文件的内容不在std中。
// 4.具有C库功能的新C++头文件具有如cstdio、cstdlib这样的名字，它们提供的内容和相应的旧的C头文件相同，只是内容在std中。
// 对于不带.h的头文件，所有的符号都位于命名空间std中，使用时需要声明命名空间std；
// 对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域，这也是C++标准所规定的。
// 虽然C++几乎完全兼容C语言，C语言的头文件在C++中依然被支持，但C++新增的库更加强大和灵活，
// 尽量使用这些C++新增的头文件，例如iostream、fstream、string等。
// 在main()函数中声明命名空间std，它的作用范围就位于main()函数内部，如果在其他函数中又用到了std，就需要重新声明。
// 如果希望在所有函数中都使用命名空间std，可以将它声明在全局范围中，这样虽然使用方便，
// 但在中大型项目开发中是不被推荐的，增加了命名冲突的风险，推荐在函数内部声明std。

namespace Li {  // 小李的变量定义
FILE *fp = NULL;
}
namespace Han {  // 小韩的变量定义
FILE *fp = NULL;
}

int main() {
  // ::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间：
  Li::fp = fopen("one.txt", "r");
  Han::fp = fopen("two.txt", "rb+");

  // 除了直接使用域解析操作符，还可以采用using关键字声明：
  using Li::fp;
  fp = fopen("one.txt", "r");
  Han::fp = fopen("two.txt", "rb+");

  // using声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间：
  using namespace Li;
  fp = fopen("one.txt", "r");
  Han::fp = fopen("two.txt", "rb+");

  // 不过现实情况和C++标准所期望的有些不同，对于原来C语言的头文件，即使按照C++的方式来使用，
  // #include <cstdio>这种形式，那么符号可以位于命名空间std中，也可以位于全局范围中:
  std::printf("http://c.biancheng.net\n");  // 标准写法，推荐
  printf("http://c.biancheng.net\n");
  // 这两种形式在Microsoft Visual C++和GCC下都能够编译通过
  // 也就是说，大部分编译器在实现时并没有严格遵循C++标准，它们对两种写法都支持，程序员可以使用std也可以不使用。

  return 0;
}