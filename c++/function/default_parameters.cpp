#include <iostream>

using namespace std;

// 在C++中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。
// 也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。
// 所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。

// C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。
// 实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。
// 下面的写法是正确的：
//  void func(int a, int b=10, int c=20){}
//  void func(int a, int b, int c=20){}
// 但这样写不可以：
//  void func(int a, int b=10, int c=20, int d){}
//  void func(int a, int b=10, int c, int d=20){}

// 默认参数并非编程方面的重大突破，而只是提供了一种便捷的方式。在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。

void func(int n, float b = 1.2, char c = '@') {
  cout << n << ", " << b << ", " << c << endl;
}

// 默认参数除了使用数值常量指定，也可以使用表达式指定
float d = 10.8;
void func1(int n, float b = d + 2.9, char c = '@') {
  cout << n << ", " << b << ", " << c << endl;
}

// 在函数定义处指定了默认参数。除了函数定义，也可以在函数声明处指定默认参数。
// 不过当出现函数声明时情况会变得稍微复杂，有时候你可以在声明处和定义处同时指定默认参数，有时候你只能在声明处指定
// void func(int a, int b = 10, int c = 36);
// void func(int a, int b = 10, int c = 36) {
//   cout << a << ", " << b << ", " << c << endl;
// }
// 编译时会报错，错误信息表明不能在函数定义和函数声明中同时指定默认参数。对代码稍作修改，将func()函数的定义放到其他源文件中是可以编译通过的。
void func2(int a, int b = 10, int c = 36);
// 这有点让人摸不着头脑，为什么将func()的定义放到其他源文件中就不一样了呢？这是因为C++规定，在给定的作用域中只能指定一次默认参数。
// C语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域），C++也有这几种作用域。
// 站在编译器的角度看，它不管当前作用域中是函数声明还是函数定义，只要有默认参数就可以使用。
void func3(int a, int b = 10, int c = 36);
// 在多文件编程时，我们通常的做法是将函数声明放在头文件中，并且一个函数只声明一次，但是多次声明同一函数也是合法的。
// 在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。
void func4(int a, int b, int c = 36);
void func4(int a, int b = 5, int c);  // 第二次声明时不能再次给c指定默认参数
void func4(int a, int b, int c) { cout << a << ", " << b << ", " << c << endl; }

int main() {
  func(10, 3.5, '#');
  // 指定了默认参数后，调用函数时就可以省略对应的实参了。
  func(20, 9.8);
  func1(30);

  func2(99);  // 99, 10, 36

  func3(99);  // 99, 10, 36

  func4(99);  // 99, 5, 36

  return 0;
}