#include <stdio.h>

// 没学指针就是没学C语言！指针是C语言的精华，也是C语言的难点。
// 所谓指针，也就是内存的地址；
// 所谓指针变量，也就是保存了内存地址的变量。
// 计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，
// 例如int占用4个字节，char占用1个字节。
// 为了正确地访问这些数据，必须为每个字节都编上号码，
// 就像门牌号、身份证号一样，每个字节的编号是唯一的，
// 根据编号可以准确地找到某个字节。

// 一切都是地址
// C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，
// 它们最终都要放到内存中才能供CPU使用。
// 数据和代码都以二进制的形式存储在内存中，
// 计算机无法从格式上区分某块内存到底存储的是数据还是代码。
// 当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，
// 拥有读取和执行权限的内存块就是代码，
// 而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
// CPU只能通过地址来取得内存中的代码和数据，
// 程序在执行过程中会告知CPU要执行的代码以及要读写的数据的地址。
// 如果程序不小心出错，或者开发者有意为之，
// 在CPU要写入数据时给它一个代码区域的地址，就会发生内存访问错误。
// 这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。
// CPU访问内存时需要的是地址，而不是变量名和函数名！
// 变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，
// 它们都会被替换成地址。
// 编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
// 需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，
// 它们都是地址的助记符，但在编写代码的过程中，认为变量名表示的是数据本身，
// 而函数名、字符串名和数组名表示的是代码块或数据块的首地址。

// 定义指针变量
// 数据在内存中的地址也称为指针，
// 如果一个变量存储了一份数据的指针，就称它为指针变量。
// 在C语言中，允许用一个变量来存放指针，称为指针变量。
// 指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，
// 也可以是另外的一个普通变量或指针变量。
// 定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，
// 格式为：datatype *name;
// 或者：datatype *name = value;
// 和普通变量一样，指针变量也可以被多次写入，
// 只要你想，随时都能够改变指针变量的值。
// 定义指针变量(包括定义并初始化)时必须带*，给指针变量赋值时不能带*。

// 通过指针变量取得数据
// *称为指针运算符，用来取得某个地址上的数据。
// 使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。
// 指针除了可以获取内存上的数据，也可以修改内存上的数据。

// 关于*和&的
// 假设有一个int类型的变量a，pa是指向它的指针，
// 那么*&a和&*pa分别是什么意思呢？
// 1.*&a可以理解为*(&a)，&a表示取变量a的地址（等价于pa），
//   *(&a)表示取这个地址上的数据（等价于*pa），
//   绕来绕去，又回到了原点，*&a仍然等价于a。
// 2.&*pa可以理解为&(*pa)，*pa表示取得pa指向的数据（等价于a），
//   &(*pa)表示数据的地址（等价于&a），所以&*pa等价于pa。

// 星号*主要有三种用途：
// 1.表示乘法，这是最容易理解的。
// 2.表示定义一个指针变量，以和普通变量区分开。
// 3.表示获取指针指向的数据，是一种间接操作。

// 指针变量的运算（加法、减法和比较运算）
// 指针变量保存的是地址，而地址本质上是一个整数，
// 所以指针变量可以进行部分运算，例如加法、减法、比较等。
// 数组中的所有元素在内存中是连续排列的，
// 如果一个指针指向了数组中的某个元素，那么加1就指向下一个元素，
// 减1就指向上一个元素，这样指针的加减运算就具有了现实的意义。
// C语言并没有规定变量的存储方式，如果连续定义多个变量，
// 它们有可能是挨着的，也有可能是分散的，
// 这取决于变量的类型、编译器的实现以及具体的编译模式，
// 所以对于指向普通变量的指针，往往不进行加减运算，虽然编译器并不会报错，
// 但这样做没有意义，因为不知道它后面指向的是什么数据。
// 指针变量除了可以参与加减运算，还可以参与比较运算。
// 当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。
// 如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。
// 另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，
// 除了会发生语法错误，也没有实际的含义。

// 二级指针
// 指针可以指向一份普通类型的数据，例如int、double、char等，
// 也可以指向一份指针类型的数据，例如int*、double*、char*等。
// 如果一个指针指向的是另外一个指针，就称它为二级指针，或者指向指针的指针。
// 指针变量也是一种变量，也会占用存储空间，也可以使用&获取它的地址。
// C语言不限制指针的级数，每增加一级指针，在定义指针时就得增加一个星号*，
// 实际开发中会经常使用一级指针和二级指针，几乎用不到高级指针。

// 空指针NULL
// 一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，
// 也不管该内存有没有使用权限，只要把地址给它，它就可以指向，
// C语言没有一种机制来保证指向的内存的正确性，程序员必须自己提高警惕。
// 对没有初始化的指针进行操作，这是非常危险的。
// 强烈建议对没有初始化的指针赋值为NULL，例如：char *str = NULL;
// NULL是零值、等于零的意思，在C语言中表示空指针。
// 从表面上理解，空指针是不指向任何数据的指针，是无效指针，使用它不会产生效果。
// NULL是在stdio.h中定义的一个宏，
// 它的具体内容为：#define NULL ((void *)0)
// (void*)0表示把数值0强制转换为void*类型，
// 最外层的()把宏定义的内容括起来，防止发生歧义。
// 从整体上来看，NULL指向了地址为0的内存，而不是前面说的不指向任何数据。
// 在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，
// 这个区域不存储有效数据，也不能被用户程序访问，
// 将NULL指向这块区域很容易检测到违规指针。
// C语言没有规定NULL的指向，只是大部分标准库约定成俗地将NULL指向0，
// 所以不要将NULL和0等同起来，例如下面的写法是不专业的：int *p = 0;
// 注意NULL和NUL的区别：
// 1.NULL表示空指针，是一个宏定义，可以在代码中直接使用。
// 2.而NUL表示字符串的结束标志'\0'，它是ASCII码表中的第0个字符。
//   NUL没有在C语言中定义，仅仅是对'\0'的称呼，不能在代码中直接使用。

// void指针
// void用在函数定义中可以表示函数没有返回值或者没有形式参数，
// 用在这里表示指针指向的数据的类型是未知的。
// 也就是说，void*表示一个有效指针，它确实指向实实在在的数据，
// 只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。
// C语言动态内存分配函数malloc()的返回值就是void*类型，
// 在使用时要进行强制类型转换。
// void*不是空指针的意思，而是实实在在的指针，
// 只是指针指向的内存中不知道保存的是什么类型的数据。

// 指针的总结
// 指针就是内存的地址，C语言允许用变量来存放指针，这种变量称为指针变量。
// 指针变量可以存放基本类型数据的地址，
// 也可以存放数组、函数以及其他指针变量的地址。
// 程序在运行过程中需要的是数据和指令的地址，
// 变量名、函数名、字符串名和数组名在本质上是一样的，
// 它们都是地址的助记符：在编写代码的过程中，认为变量名表示的是数据本身，
// 而函数名、字符串名和数组名表示的是代码块或数据块的首地址；
// 程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。
// int *p; 	   p可以指向int类型的数据，也可以指向类似int arr[n]的数组。
// int **p; 	 p为二级指针，指向int*类型的数据。
// int *p[n];  p为指针数组。[]的优先级高于*，所以应该理解为int *(p[n]);
// int (*p)[n];p为二维数组指针。
// int *p(); 	 p是一个函数，它的返回值类型为int*。
// int (*p)(); p是一个函数指针，指向原型为int func()的函数。
// 1.指针变量可以进行加减运算，例如p++、p+i、p-=i。
//   指针变量的加减运算并不是简单的加上或减去一个整数，
//   而是跟指针指向的数据类型有关。
// 2.给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，
//   例如int *p = 1000;是没有意义的，使用过程中一般会导致程序崩溃。
// 3.使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，
//   如果它指向的内存没有使用权限，程序就崩溃了。
//   对于暂时没有指向的指针，建议赋值NULL。
// 4.两个指针变量可以相减。
//   如果两个指针变量指向同一个数组中的某个元素，
//   那么相减的结果就是两个指针之间相差的元素个数。
// 5.数组也是有类型的，数组名的本意是表示一组类型相同的数据。
//   在定义数组或者和sizeof、&运算符一起使用时数组名才表示整个数组，
//   表达式中的数组名会转换为指向数组的指针。

int main() {
  int a = 10, *pa = &a, *paa = &a;
  double b = 99.9, *pb = &b;
  char c = '@', *pc = &c;
  // 最初的值
  printf("&a=%#X, &b=%#X, &c=%#X\n", &a, &b, &c);
  printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
  // &a=0X7D7B79DC, &b=0X7D7B79E0, &c=0X7D7B79DB
  // pa=0X7D7B79DC, pb=0X7D7B79E0, pc=0X7D7B79DB
  // 加法运算：
  pa++;
  pb++;
  pc++;
  printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
  // pa、pb、pc每次加1，它们的地址分别增加4、8、1，
  // 正好是int、double、char类型的长度：
  // pa=0X7D7B79E0, pb=0X7D7B79E8, pc=0X7D7B79DC

  // 减法运算：
  pa -= 2;
  pb -= 2;
  pc -= 2;
  printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
  // 减2时，地址分别减少8、16、2，
  // 正好是int、double、char类型长度的2倍。
  // pa=0X7D7B79D8, pb=0X7D7B79D8, pc=0X7D7B79DA

  // 比较运算：
  if (pa == paa) {
    printf("%d\n", *paa);
  } else {
    printf("%d\n", *pa);
  }
  // 1077937949
  if (pa == (char *)pa) {
    printf("don't care type\n");  // don't care type
  }

  int a1 = 100;
  int *p1 = &a1;
  int **p2 = &p1;
  int ***p3 = &p2;
  printf("%d, %d, %d, %d\n", a1, *p1, **p2, ***p3);
  printf("&p2 = %#X, p3 = %#X\n", &p2, p3);
  printf("&p1 = %#X, p2 = %#X, *p3 = %#X\n", &p1, p2, *p3);
  printf("&a  = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &a1, p1, *p2, **p3);
  // 100, 100, 100, 100
  // &p2 = 0X7905B118, p3 = 0X7905B118
  // &p1 = 0X7905B110, p2 = 0X7905B110, *p3 = 0X7905B110
  // &a  = 0X7905B104, p1 = 0X7905B104, *p2 = 0X7905B104, **p3 = 0X7905B104

  return 0;
}