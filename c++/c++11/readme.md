# C++11新特性

## C++11是什么，C++11标准的由来

C++11 是第二个真正意义上的 C++ 标准，也是 C++ 的一次重大升级。C++11 增加了很多现代编程语言的特性，比如自动类型推导、智能指针、lambda 表达式等，这使得 C++ 看起来又酷又潮，一点也不输 [Java](http://c.biancheng.net/java/) 和 [C#](http://c.biancheng.net/csharp/)。

---

虽然学习 C++11 需要花些时间，但这是非常值得的；C++11 非常实用，它不但提高了开发效率，还让程序更加健壮和优雅。程序员应该乐于升级换代已有的知识，而学习和使用 C++11 早就是大势所趋，请大家不要抗拒。

---

C++ 这门编程语言的历史可以追溯至 **1979 年**，当时的 Bjarne Stroustrup（C++ 之父，后续简称 Stroustrup）还在使用 Simula 语言进行开发工作。

由于实例开发中 Simula 语言的执行效率太低，所以此后不久，Stroustrup 开始从事“带类的C”编程语言的开发工作。

注意在开发初期，并没有 C++ 这个称谓。所谓“带类的C”，顾名思义就是在 C  语言的基础上，为其加入面向对象的思想（扩增一些写好的类和对象）。初期的 C++ 除了具备 C  语言的所有功能外，还具有类、基本继承、内联函数、默认函数参数以及强类型检查等简单功能。

---

**1983 年，“带类的C”正式被称为“C++”，其中“++”就取自 C 语言中的“++”运算符，这也从侧面表明了 Stroustrup 对于 C++ 这门编程语言的定位。** 与此同时，C++还增添了很多功能，比如虚函数、函数重载、引用、const 关键字以及 // 注释符号等。

直到** 1998 年**，C++ 标准委员会发布了第一版 C++ 标准，并将其命名为**C++ 98 标准**。

值得一提的是在 C++ 11 标准之前，C++ 标准委员会还在 **2003 年**对 C++ 98 标准做了一次修改（称为 **C++ 03 标准**），但由于其仅仅修复了一些 C++ 98 标准中存在的漏洞，并未修改核心语法，因此人们习惯将这次修订和 C++ 98 合称为 **C++98/03 标准**。

截止到目前（2020 年），C++ 的发展历经了以下 3 个个标准：

- **2011 年**，新的 **C++ 11 标准**诞生，用于取代 C++ 98 标准。此标准还有一个别名，为“**C++ 0x**"；

- **2014 年**，**C++ 14 标准**发布，该标准库对 C++ 11 标准库做了更优的修改和更新；

- **2017 年底**，**C++ 17 标准**正式颁布。

以上 3 个标准中，相比对前一个版本的修改和更新程度，C++ 11 标准无疑是颠覆性的，该标准在 C++ 98 的基础上修正了约 600 个 C++ 语言中存在的缺陷，同时添加了约 140 个新特性，这些更新使得 C++ 语言焕然一新。读者可以这样理解 C++ 11 标准，它在 C++ 98/03 标准的基础上孕育出了全新的 C++ 编程语言，造就了 C++ 新的开始。

新C++标准（也被称为C++11或C++0x）在2011年发布，带来一系列的变革让C++编程更加简单和高效。同时，委员会也确立了一种新的“列车模式”——每三年发布一个新的C++标准。从模式确立之后，委员会发布了两个标准：2014年的C++14标准和2017的C++17标准，以及若干个描述C++标准扩展的技术规范。
---
## C++ auto和decltype的区别

### 语法格式的区别

auto和decltype都是C++11新增的关键字，都用于自动类型推导，但是它们的语法格式是有区别的，如下所示：
> auto varname = value;  // auto的语法格式
> decltype(exp) varname [= value];  // decltype的语法格式

其中，varname表示变量名，value表示赋给变量的值，exp表示一个表达式，方括号[ ]表示可有可无。

auto和decltype都会自动推导出变量varname的类型：
> auto根据=右边的初始值value推导出变量的类型；
> decltype根据exp表达式推导出变量的类型，跟=右边的value没有关系。

另外，auto要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype不要求，初始化与否都不影响变量的类型。这很容易理解，因为auto是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。

auto将变量的类型和初始值绑定在一起，而decltype将变量的类型和初始值分开；虽然auto的书写更加简洁，但decltype的使用更加灵活。

---

### 对cv限定符的处理
「cv 限定符」是 const 和 volatile 关键字的统称：
> const关键字用来表示数据是只读的，也就是不能被修改；
> volatile和const是相反的，它用来表示数据是可变的、易变的，目的是不让CPU将数据缓存到寄存器，而是从原始的内存中读取。

在推导变量类型时，auto和decltype对cv限制符的处理是不一样的。decltype会保留cv限定符，而auto有可能会去掉cv限定符:
```
    //非指针非引用类型
    const int n1 = 0;
    auto n2 = 10;
    n2 = 99;  //赋值不报错,说明不带const，也就是const被auto抛弃了，这验证了auto的第一条推导规则
    decltype(n1) n3 = 20;
    n3 = 5;  //赋值报错,说明decltype不会去掉表达式的const属性。
    //指针类型
    const int *p1 = &n1;
    auto p2 = p1;
    *p2 = 66;  //赋值报错,说明是带const的，也就是const没有被auto抛弃，这验证了auto的第二条推导规则。
    decltype(p1) p3 = p1;
    *p3 = 19;  //赋值报错,说明decltype不会去掉表达式的const属性。
```

---

### 对引用的处理
当表达式的类型为引用时，auto和decltype的推导规则也不一样:
> decltype会保留引用类型
> auto会抛弃引用类型，直接推导出它的原始类型

```
    int n = 10;
    int &r1 = n;
    //auto推导
    auto r2 = r1;
    r2 = 20;
    cout << n << ", " << r1 << ", " << r2 << endl; // 10, 10, 20
    //decltype推导
    decltype(r1) r3 = n;
    r3 = 99;
    cout << n << ", " << r1 << ", " << r3 << endl; // 99, 99, 99
```
---
### 总结
auto虽然在书写格式上比decltype简单，但是它的推导规则复杂，有时候会改变表达式的原始类型；而decltype比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味。
从代码是否健壮的角度考虑，我推荐使用 decltype，它没有那么多是非；但是 decltype 总是显得比较麻烦，尤其是当表达式比较复杂时，例如：
> vector<int> nums;
> decltype(nums.begin()) it = nums.begin();

而如果使用auto就会清爽很多：
> vector<int> nums;
> auto it = nums.begin();

在实际开发中人们仍然喜欢使用auto关键字，因为它用起来简单直观，更符合人们的审美。如果你的表达式类型不复杂，我还是推荐使用auto关键字，优雅的代码总是叫人赏心悦目，沉浸其中。
