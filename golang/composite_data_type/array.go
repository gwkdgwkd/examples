package main

import "fmt"

func main() {

	// 数组是一个由固定长度的特定类型元素组成的序列,一个数组可以由零个或多个元素组成。
	// 因为数组的长度是固定的,因此在Go语言中很少直接使用数组。和数组对应的类型是
	// Slice(切片),它是可以增长和收缩动态序列,slice功能也更灵活。

	// 数组的每个元素可以通过索引下标来访问,索引下标的范围是从0开始到数组长度减1的位
	// 置。内置的len函数将返回数组中元素的个数。

	// 默认情况下,数组的每个元素都被初始化为元素类型对应的零值,对于数字类型来说就是0。

	// 可以使用数组字面值语法用一组值来初始化数组:
	var q [3]int = [3]int{1, 2, 3}
	var r [3]int = [3]int{1, 2}
	fmt.Println(r[2], len(q)) // 0 3
	// 在数组字面值中,如果在数组的长度位置出现的是“...”省略号,则表示数组的长度是根据初始
	// 化值的个数来计算。
	q1 := [...]int{1, 2, 3}
	fmt.Printf("%T\n", q1) // [3]int

	// 数组的长度是数组类型的一个组成部分,因此[3]int和[4]int是两种不同的数组类型。数组的长
	// 度必须是常量表达式,因为数组的长度需要在编译阶段确定。
	// q := [3]int{1, 2, 3}
	// q = [4]int{1, 2, 3, 4} //	compile	error:	cannot	assign	[4]int	to	[3]int

	// 数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供
	// 顺序初始化值序列,但是也可以指定一个索引和对应值列表的方式初始化
	type Currency int
	const (
		USD Currency = iota //	美元
		EUR                 //	欧元
		GBP                 //	英镑
		RMB                 //	人民币
	)
	symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RMB: "¥"}
	fmt.Println(RMB, symbol[RMB]) // 3 ¥

	// 初始化索引的顺序是无关紧要的,而且没用到的索引可以省略,和前面提到的规则一样,未指定初始值
	// 的元素将用零值初始化
	r1 := [...]int{99: -1}
	fmt.Printf("%T %d %d %d\n", r1, len(r1), r1[60], r1[99]) // [100]int 100 0 -1

	// 如果一个数组的元素类型是可以相互比较的,那么数组类型也是可以相互比较的,这时候我
	// 们可以直接通过==比较运算符来比较两个数组,只有当两个数组的所有元素都是相等的时候
	// 数组才是相等的。不相等比较运算符!=遵循同样的规则。
	a := [2]int{1, 2}
	b := [...]int{1, 2}
	c := [2]int{1, 3}
	fmt.Println(a == b, a == c, b == c) // true false false
	// d := [3]int{1, 2}
	// fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int

	// 当调用一个函数的时候,函数的每个调用参数将会被赋值给函数内部的参数变量,所以函数
	// 参数变量接收的是一个复制的副本,并不是原始调用的变量。因为函数参数传递的机制导致
	// 传递大的数组类型将是低效的,并且对数组参数的任何的修改都是发生在复制的数组上,并
	// 不能直接修改调用时原始的数组变量。在这个方面,Go语言对待数组的方式和其它很多编程
	// 语言不同,其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。

	// 可以显式地传入一个数组指针,那样的话函数通过指针对数组的任何修改都可以
	// 直接反馈到调用者。

	// 虽然通过指针来传递数组参数是高效的,而且也允许在函数内部修改数组的值,但是数组依
	// 然是僵化的类型,因为数组的类型包含了僵化的长度信息。接收[32]byte类型的数组并不能接收指向
	// [16]byte类型数组的指针,而且也没有任何添加或删除数组元素的方法。由于这些原因,除了
	// 像SHA256这类需要处理特定大小数组的特例外,数组依然很少用作函数参数;相反,一般使用slice来替代数组。
}
