#include <algorithm>
#include <iostream>

using namespace std;

// lambda源自希腊字母表中第11位的λ，在计算机科学领域，它则是被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为lambda函数或者lambda表达式。
// 继Python、Java、C#、PHP等众多高级编程语言都支持lambda匿名函数后，C++11标准终于引入了lambda。

// 定义一个lambda匿名函数很简单，可以套用如下的语法格式:
// [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
// {
//    函数体;
// };
// 其中各部分的含义分别为：
// 1) [外部变量方位方式说明符]
// []方括号用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用哪些“外部变量”。
// 所谓外部变量，指的是和当前lambda表达式位于同一作用域内的所有局部变量。
// 2) (参数)
// 和普通函数的定义一样，lambda匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()小括号一起省略；
// 3) mutable
// 此关键字可以省略，如果使用则之前的()小括号将不能省略（参数个数可以为0）。
// 默认情况下，对于以值传递方式引入的外部变量，不允许在lambda表达式内部修改它们的值（可以理解为这部分变量都是const常量）。而如果想修改它们，就必须使用mutable关键字。
// 注意，对于以值传递方式引入的外部变量，lambda表达式修改的是拷贝的那一份，并不会修改真正的外部变量；
// 4) noexcept/throw()
// 可以省略，如果使用，在之前的()小括号将不能省略（参数个数可以为0）。
// 默认情况下，lambda函数的函数体中可以抛出任何类型的异常。而标注noexcept关键字，则表示函数体内不会抛出任何异常；使用throw()可以指定lambda函数内部可以抛出的异常类型。
// 如果lambda函数标有noexcept而函数体内抛出了异常，又或者使用throw()限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用try-catch捕获，会导致程序执行失败。
// 5) -> 返回值类型
// 指明lambda匿名函数的返回值类型。如果lambda函数体内只有一个return语句，或者该函数返回void，则编译器可以自行推断出返回值类型，此情况下可以直接省略->返回值类型。
// 6) 函数体
// 和普通函数一样，lambda匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。
// 外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在lambda表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。

// 比如，如下就定义了一个最简单的lambda匿名函数：
// []{}
// 显然，此lambda匿名函数未引入任何外部变量（[]内为空），也没有传递任何参数，没有指定mutable、noexcept等关键字，没有返回值和函数体。所以，这是一个没有任何功能的lambda匿名函数。

// lambda匿名函数中的[外部变量]:
// []:空方括号表示当前lambda匿名函数中不导入任何外部变量。
// [=]:只有一个=等号，表示以值传递的方式导入所有外部变量；
// [&]:只有一个&符号，表示以引用传递的方式导入所有外部变量；
// [val1,val2,...]:表示以值传递的方式导入val1、val2等指定的外部变量，同时多个变量之间没有先后次序；
// [&val1,&val2,...]:表示以引用传递的方式导入val1、val2等指定的外部变量，多个变量之间没有前后次序；
// [val,&val2,...]:以上2种方式还可以混合使用，变量之间没有前后次序。
// [=,&val1,...]:表示除val1以引用传递的方式导入外，其它外部变量都以值传递的方式导入。
// [this]:表示以值传递的方式导入当前的this指针。
// 注意，单个外部变量不允许以相同的传递方式导入多次。例如[=，val1]中，val1先后被以值传递的方式导入了2次，这是非法的。

//自定义的升序排序规则
bool sort_up(int x, int y) { return x < y; }

int all_num = 0;

int main() {
  // lambda匿名函数的定义和使用:
  int num[4] = {4, 2, 3, 1};
  // sort(num, num + 4, sort_up);
  sort(num, num + 4, [=](int x, int y) -> bool { return x < y; });
  for (int n : num) {
    cout << n << " "; // 1 2 3 4
  }
  cout << endl;

  // 虽然lambda匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：
  auto display = [](int a, int b) -> void { cout << a << " " << b << endl; };
  // 程序中使用auto关键字为lambda匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。
  display(10, 20);

  // 值传递和引用传递的区别:
  int num_1 = 1;
  int num_2 = 2;
  int num_3 = 3;
  cout << "lambda1:" << endl;
  // lambda1匿名函数是以[=]值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这3个局部变量的值，但全局变量all_num除外。
  auto lambda1 = [=] {
    all_num = 10; // 全局变量可以访问甚至修改
    // 函数体内只能使用外部变量，而无法对它们进行修改
    // num_1 = 5; // assignment of read-only variable ‘num_1’
    cout << num_1 << " " << num_2 << " " << num_3 << endl; // 1 2 3
  };
  lambda1();
  cout << all_num << endl; // 10
  cout << "lambda2:\n";
  // lambda2匿名函数以[&]引用传递的方式导入这3个局部变量，因此在该函数的内部不就可以访问这3个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。
  auto lambda2 = [&] {
    all_num = 100;
    num_1 = 10;
    num_2 = 20;
    num_3 = 30;
    cout << num_1 << " " << num_2 << " " << num_3 << endl; // 10 20 30
  };
  lambda2();
  cout << all_num << endl; // 100

  // 当然，如果我们想在lambda1匿名函数的基础上修改外部变量的值，可以借助mutable关键字，例如:
  auto lambda3 = [=]() mutable {
    num_1 = 11;
    num_2 = 22;
    num_3 = 31;
    cout << num_1 << " " << num_2 << " " << num_3 << endl;
  };
  lambda3();
  // 但需要注意的是，lambda3修改的仅是num_1、num_2、num_3拷贝的那一份的值，真正外部变量的值并不会发生改变。
  cout << num_1 << " " << num_2 << " " << num_3 << endl;

  // 执行抛出异常类型:
  auto except = []() throw(int) { throw 10; };
  try {
    except();
  } catch (int) {
    cout << "捕获到了整形异常" << endl;
  }

  // 反例：
  // except1匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；
  auto except1 = []() noexcept { throw 100; };
  // except2匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。
  auto except2 = []() throw(char) { throw 10; };
  try {
    except1();
    except2();
  } catch (int) {
    cout << "捕获到了整形异常" << endl;
  }
  // 由于指定异常类型和真正发生的异常类型不匹配，导致try-catch无法捕获，最终程序运行崩溃。
  // 如果不使用noexcept或者throw()，则lambda匿名函数的函数体中允许发生任何类型的异常。

  return 0;
}