#include <stdio.h>

// C语言具有操作文件的能力，比如打开文件、读取和追加数据、
// 插入和删除数据、关闭文件、删除文件等。
// 在C语言中，为了统一对各种硬件的操作，简化接口，
// 不同的硬件设备也都被看成一个文件。
// 对这些文件的操作，等同于对磁盘上普通文件的操作。
// 常见硬件设备所对应的文件：
// 1.stdin，标准输入文件，一般指键盘；
//   scanf()、getchar()等函数默认从stdin获取输入。
// 2.stdout，标准输出文件，一般指显示器；
//   printf()、putchar()等函数默认向stdout输出数据。
// 3.stderr，标准错误文件，一般指显示器；
//   perror()等函数默认向stderr输出数据。
// 4.stdprn，标准打印文件，一般指打印机。
// 标准输入文件stdin、标准输出文件stdout、
// 标准错误文件stderr是由系统打开的，可直接使用。
// 文件是数据源的一种，除了文件，还有数据库、网络、键盘等；
// 数据传递到内存也就是保存到C语言的变量，例如整数、字符串、数组、缓冲区等。
// 把数据在数据源和程序（内存）之间传递的过程叫做数据流(Data Stream)。
// 相应的，数据从数据源到程序（内存）的过程叫做输入流(Input Stream)，
// 从程序（内存）到数据源的过程叫做输出流(Output Stream)。

// 使用<stdio.h>头文件中的fopen()函数即可打开文件，它的用法为：
// FILE *fopen(char *filename, char *mode);

// fopen()函数的返回值
// fopen()会获取文件信息，包括文件名、文件状态、当前读写位置等，
// 并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。
// 打开文件出错时，fopen()将返回一个空指针，也就是NULL，
// 可以利用这一点来判断文件是否打开成功：
// if((fp=fopen("D:\\demo.txt","rb") == NULL)

// fopen()函数的打开方式
// 控制读写权限：
// 1."r"以只读方式打开文件。
//   只允许读取，不允许写入，文件必须存在，否则打开失败。
// 2."w"以写入方式打开文件。
//   如果文件不存在，那么创建一个新文件；
//   如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
// 3."a"以追加方式打开文件。
//   如果文件不存在，那么创建一个新文件；
//   如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
// 4."r+"以读写方式打开文件。
//   既可以读取也可以写入，也就是随意更新文件。
//   文件必须存在，否则打开失败。
// 5."w+"以写入/更新方式打开文件，相当于w和r+叠加的效果。
//   既可以读取也可以写入，也就是随意更新文件。
//   如果文件不存在，那么创建一个新文件；
//   如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
// 6."a+"以“追加/更新”方式打开文件，相当于a和r+叠加的效果。
//   既可以读取也可以写入，也就是随意更新文件。
//   如果文件不存在，那么创建一个新文件；
//   如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
// 读写方式：
// 1."t"，文本文件，如果不写，默认为"t"。
// 2."b"，二进制文件。

// 调用fopen()函数时必须指明读写权限，
// 但是可以不指明读写方式（此时默认为"t"）。
// 读写权限和读写方式可以组合使用，
// 但是必须将读写方式放在读写权限的中间或者尾部，
// 换句话说，不能将读写方式放在读写权限的开头。
// 整体来说，文件打开方式由r、w、a、t、b、+六个字符拼成，各字符的含义是：
// 1.r(read)：读
// 2.w(write)：写
// 3.a(append)：追加
// 4.t(text)：文本文件
// 5.b(binary)：二进制文件
// 6.+：读和写

// 关闭文件
// 文件一旦使用完毕，应该用fclose()函数把文件关闭，
// 以释放相关资源，避免数据丢失。
// fclose()的用法为：int fclose(FILE *fp);
// 文件正常关闭时，fclose()的返回0，如果返回非零值则表示有错误发生。

// 文本文件和二进制文件的区别
// 根据我们以往的经验，文本文件通常用来保存肉眼可见的字符，
// 比如.txt文件、.c文件、.dat文件等，
// 用文本编辑器打开这些文件，能够顺利看懂文件的内容。
// 二进制文件通常用来保存视频、图片、程序等不可阅读的内容，
// 用文本编辑器打开这些文件，会看到一堆乱码，根本看不懂。
// 但是从物理上讲，二进制文件和字符文件并没有什么区别，
// 它们都是以二进制的形式保存在磁盘上的数据。
// 之所以能看懂文本文件的内容，
// 是因为文本文件中采用的是ASCII、UTF-8、GBK等字符编码，
// 文本编辑器可以识别出这些编码格式，并将编码值转换成字符展示出来。
// 而二进制文件使用的是mp4、gif、exe等特殊编码格式，
// 文本编辑器并不认识这些编码格式，只能按照字符编码格式胡乱解析，
// 所以就成了一堆乱七八糟的字符，有的甚至都没见过。
// 如果新建一个mp4文件，给它写入一串字符，
// 然后再用文本编辑器打开，你一样可以读得懂。
// 总起来说，不同类型的文件有不同的编码格式，
// 必须使用对应的软件才能正确解析，否则就是一堆乱码，或者无法使用。

// fopen()中的文本方式和二进制方式
// 在C语言中，二进制方式很简单，读取文件时，
// 会原封不动的读出文件的全部內容，写入数据时，
// 也是把缓冲区中的內容原封不动的写到文件中。
// 文本方式和二进制方式并没有本质上的区别，只是对于换行符的处理不同。
// C语言程序将\n作为换行符，
// 类UNIX/Linux系统在处理文本文件时也将\n作为换行符，
// 所以程序中的数据会原封不动地写入文本文件中，反之亦然。
// 但是Windows系统却不同，它将\r\n作为文本文件的换行符。
// 在Windows中，如果以文本方式打开文件，当读取文件时，
// 程序会将文件中所有的\r\n转换成一个字符\n。
// 也就是说，如果文本文件中有连续的两个字符是\r\n，
// 则程序会丢弃前面的\r，只读入\n。
// 当写入文件时，程序会将\n转换成\r\n写入。
// 也就是说，如果要写入的内容中有字符\n，
// 则在写入该字符前，程序会自动先写入一个\r。
// 因此，如果用文本方式打开二进制文件进行读写，
// 读写的内容就可能和文件的内容有出入。
// 总起来说，对于Windows平台，为了保险起见，
// 最好用"t"来打开文本文件，用"b"来打开二进制文件。
// 对于Linux平台，使用"r"还是"b"都无所谓，
// 既然默认是"r"，那什么都不写就行了。

int main() { return 0; }