#include <iostream>

// C++允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，
// 这就是函数的重载（Function Overloading）。
// 重载就是在一个作用范围内，同一个类、同一个命名空间等，
// 有多个名称相同但参数不同的函数。
// 重载的结果是让一个函数名拥有了多种用途，使得命名更加方便，调用更加灵活。
// 在使用重载函数时，同名函数的功能应当相同或相近，
// 不要用同一函数名去实现完全不相干的功能，
// 虽然程序也能运行，但可读性不好，使人觉得莫名其妙。

// 重载的规则：
// 1.函数名称必须相同；
// 2.参数列表（参数签名）必须不同，参数的类型、
//   参数的个数和参数的顺序只要有一个不同就叫做参数列表不同；
// 3.函数的返回类型可以相同也可以不相同；
// 4.仅仅返回类型不同不足以成为函数的重载。

namespace n1 {
// C++代码在编译时会根据参数列表对函数进行重命名，
// 不同的编译器有不同的重命名方式，例如：
// void Swap(int a, int b)会被重命名为_Swap_int_int，
// void Swap(float x, float y)会被重命名为_Swap_float_float。
// 当发生函数调用时，编译器会根据传入的实参去逐个匹配，
// 以选择对应的函数，匹配失败，就会报错，这叫做重载决议。
// 从这个角度讲，函数重载仅仅是语法层面的，
// 本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

// 函数调用时编译器会根据传入的实参的个数、类型、
// 顺序等信息去匹配要调用的函数，这在大部分情况下都能够精确匹配。
// 但当实参的类型和形参的类型不一致时情况就会变得稍微复杂，
// 例如函数形参的类型是int，调用函数时却将short类型的数据交给了它，
// 编译器就需要先将short类型转换为int类型才能匹配成功。
void func(char ch) { std::cout << "#1" << std::endl; }
void func(int n) { std::cout << "#2" << std::endl; }
void func(long m) { std::cout << "#3" << std::endl; }
void func(double f) { std::cout << "#4" << std::endl; }

void testN1() {
  short s = 99;
  float f = 84.6;

  func('a');  // #1 不需要类型转换，调用func(char)
  func(s);    // #2 将short转换成int，调用func(int)
  func(49);   // #2 不需要类型转换，调用func(int)
  func(f);    // #4 将float转换成double，调用func(double)
}
}  // namespace n1

namespace n2 {
void func(char ch) { std::cout << "#1" << std::endl; }
void func(long m) { std::cout << "#3" << std::endl; }
void func(double f) { std::cout << "#4" << std::endl; }
void testN2() {
  short s = 99;
  float f = 84.6;

  func('a');  // #1
  func(f);    // #4
  // 没有void func(int n)，下面两个调用可以匹配重载函数中的任何一个，
  // 编译器不知道如何抉择：
  // func(s);
  // func(49);

  // 根据以往的编程经验，s和49不都应该被转换成long类型，
  // 从而匹配3号函数void func(long m)吗？
  // 推论在一般的函数调用或者四则运算中没错，但它不一定适用于重载函数。
}
}  // namespace n2

namespace n3 {
// C++标准规定，在进行重载决议时编译器应该按照下面的优先级顺序来处理实参的类型：
// 优先级 	           包含的内容 	        举例说明
// 精确匹配 	         不做类型转换，直接匹配
//                    只是做微不足道的转换 	 从数组名到数组指针
//                                        从函数名到指向函数的指针
//                                        从非const类型到const类型
// 类型提升后匹配 	    整型提升 	            从bool、char、short提升为int
//                                        从char16_t、char32_t、wchar_t提升为int、long、long long
//                    小数提升 	           从float提升为double
// 使用自动类型转换后匹配 整型转换 	           从char到long、short到long、int到short、long到char
//                    小数转换 	           从double到float
//                    整数和小数转换 	      从int到double、short到float、float到int、double到long
//                    指针转换 	           从int *到void *
// int到long是类型提升还是类型转换？
// C++还规定，编译器应该按照从高到低的顺序来搜索重载函数，
// 首先是精确匹配，然后是类型提升，最后才是类型转换；
// 一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。
// 如果在一个优先级中找到多个（两个以及以上）合适的重载函数，
// 编译器就会陷入两难境地，不知道如何抉择，
// 编译器会将这种模棱两可的函数调用视为一种错误，
// 因为这些合适的重载函数同等优秀，没有一个脱颖而出，调用谁都一样。
// 这就是函数重载过程中的二义性错误。
// 类型提升和类型转换不是一码事，类型提升是积极的，
// 是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；
// 而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。

// C++标准规定，如果有且只有一个函数满足下列条件，则匹配成功：
// 1.该函数对每个实参的匹配都不劣于其他函数；
// 2.至少有一个实参的匹配优于其他函数。

// 在设计重载函数时，参数类型过少或者过多都容易引起二义性错误，
// 因为这些类型相近，彼此之间会相互转换。

void func(int i, int j) { std::cout << "#1: " << i << "," << j << std::endl; }
void func(char c, int i, float f) {
  std::cout << "#2: " << c << "," << i << "," << f << std::endl;
}
void func(char c, long l, double d) {
  std::cout << "#3: " << c << "," << l << "," << d << std::endl;
}

void testN3() {
  short n = 99;

  func('@', n, 99);  // #2: @,99,99
  // 重载决议：
  // 1.#1只有两个参数，不匹配，从#2和#3中选择；
  // 2.如果只考虑第一个实参'@'，#2和#3都能够精确匹配，
  //   谁也不比谁优秀，是平等的；
  // 3.如果只考虑第二个实参n，对于#2需要把short提升为int（类型提升），
  //   对于#3需要把short转换为long（类型转换）,
  //   类型提升的优先级高于类型转换，所以#2胜出；
  // 4.如果只考虑第三个参数99，#2和#3都要进行类型转换，
  //   没有哪一个能胜出，它们是平等的；
  // 5.从整体上看，第一、三个参数是平等的，但第二个参数#2胜出，
  //   也就是说，#2对每个实参的匹配都不劣于#3，
  //   第二个参数#2优于#3，所以#胜出，调用#2函数。

  // func('@', n, 99.5);
  // 重载决议：
  // 1.#1只有两个参数，不匹配，从#2和#3中选择；
  // 2.如果只考虑第一个实参'@'，#2和#3都能够精确匹配，
  //   谁也不比谁优秀，是平等的；
  // 3.如果只考虑第二个实参n，#2胜出；
  // 4.如果只考虑第三个参数，#3是精确匹配，#3胜出；
  // 5.从整体上看，它们最终打成了平手，分不清孰优孰劣，
  //   所以编译器不知道如何抉择，会产生二义性错误。
}
}  // namespace n3

namespace n4 {
// 在一个项目中，能否既包含C++程序又包含C程序呢？
// 换句话说，C++和C可以进行混合编程吗？
// 在C++出现之前，很多实用的功能都是用C语言开发的，
// 很多底层的库也是用C语言编写的。
// 这意味着，如果能在C++代码中兼容C语言代码，
// 无疑能极大地提高C++程序员的开发效率。
// C++和C可以进行混合编程。
// 但需要注意的是，由于C++和C在程序的编译、
// 链接等方面都存在一定的差异，而这些差异往往会导致程序运行失败。
// C++支持函数的重载，是因为C++会在程序的编译阶段对函数的函数名进行再次重命名。
// 但是，C语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动。
// 不同的编译器有不同的重命名方式，
// 但根据C++标准编译后的函数名几乎都由原有函数名和各个参数的数据类型构成，
// 而根据C语言标准编译后的函数名则仅有原函数名构成。
// 这也就意味着，使用C和C++进行混合编程时，考虑到对函数名的处理方式不同，
// 势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。

// 幸运的是，C++给出了相应的解决方案，即借助extern "C"，
// 就可以轻松解决C++和C在处理代码方式上的差异性。
// extern是C和C++的一个关键字，但对于extern "C"，
// 大可以将其看做一个整体，和extern毫无关系。
// extern "C"既可以修饰一句C++代码，也可以修饰一段C++代码，
// 可以让编译器以处理C语言的方式来处理C++代码。
// myfun.h：
// #ifdef __cplusplus
// extern "C" void display();
// #else
// void display();
// #endif
// 无论display()函数位于C++程序还是C语言程序，
// 都保证了display()函数可以按照C语言的标准来处理。
// 解决C++和C混合编程的问题，通常在头文件中使用如下格式：
// #ifdef __cplusplus
// extern "C" {
// #endif
// void display();
// #ifdef __cplusplus
// }
// #endif

// extern "C"大致有2种用法:
// 1.当仅修饰一句C++代码时，直接将其添加到该函数代码的开头即可；
// 2.如果用于修饰一段C++代码，只需为extern "C"添加一对大括号{}，
//   并将要修饰的代码囊括到括号内即可。
}  // namespace n4

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cout << argv[0] << " i [0 - 2]" << std::endl;
    return 0;
  }
  int type = argv[1][0] - '0';
  switch (type) {
    case 0:
      n1::testN1();
      break;
    case 1:
      n2::testN2();
      break;
    case 2:
      n3::testN3();
      break;
    default:
      std::cout << "invalid type" << std::endl;
      break;
  }

  return 0;
}